
// =============================================================================
// 6. 实际发包演示和响应处理
// POC库HTTP请求发送 HTTP发包 网络请求 响应处理 数据包发送
// 关键词: HTTP, HTTPEx, Get, Post, Put, Delete, Head, Options, 发包, 请求, 响应
// =============================================================================
println("\n6. 实际发包演示和响应处理")

// 创建本地测试服务器 - 用于模拟HTTP响应
// 关键词: 本地服务器, httpserver, 测试服务器, 模拟服务器
port = os.GetRandomAvailableTCPPort()
check = false  // JSON请求检查标志
check2 = false // 自定义头检查标志

go func {
    // 启动HTTP服务器 - httpserver.Serve函数使用示例
    // 关键词: httpserver.Serve, HTTP服务器, 服务器启动, 请求处理器
    httpserver.Serve(
        "127.0.0.1",
        port,
        httpserver.handler((rsp, req) => {
            // 获取原始请求数据 - http.dump函数使用
            // 关键词: http.dump, 请求转储, 原始请求, 请求数据
            raw = http.dump(req)~

            // 记录请求信息 - 用于验证请求内容
            // 关键词: JSON检测, Content-Type检查, 请求头验证
            if raw.Contains("application/json") {
                check = true  // 标记收到JSON请求
            }
            if raw.Contains("X-Test-Header") {
                check2 = true  // 标记收到自定义头
            }

            // 路由处理 - 根据请求路径返回不同的响应
            // 关键词: 路由, URL路径, 请求路径, 响应处理, 路径匹配
            if req.URL.Path == "/json" {
                // JSON响应路径 - 返回JSON格式数据
                rsp.Write(`{"status": "ok", "method": "` + req.Method + `", "path": "` + req.URL.Path + `"}`)
            } else if req.URL.Path == "/form" {
                // 表单响应路径 - 处理表单提交
                rsp.Write(`{"received": "form", "method": "` + req.Method + `"}`)
            } else if req.URL.Path == "/redirect" {
                // 重定向测试路径 - HTTP重定向演示
                // 关键词: 重定向, redirect, 302状态码, Location头
                rsp.SetHeader("Location", f"http://127.0.0.1:${port}/target")
                rsp.SetStatusCode(302)
                rsp.Write(`Redirecting...`)
            } else if req.URL.Path == "/target" {
                // 重定向目标路径 - 重定向的最终目标
                rsp.Write(`{"redirected": true, "final": true}`)
            } else if req.URL.Path == "/slow" {
                // 慢响应测试路径 - 模拟慢响应但不真的延迟
                // 关键词: 慢响应, 性能测试, 响应时间
                rsp.Write(`{"slow": "response", "method": "` + req.Method + `"}`)
            } else if req.URL.Path == "/delay" {
                // 延迟响应测试路径 - 用于超时测试
                // 关键词: 延迟, 超时测试, time.Sleep, 延迟响应
                time.Sleep(2 * time.Second)
                rsp.Write(`{"delayed": "response"}`)
            } else if str.HasPrefix(req.URL.Path, "/concurrent/") {
                // 并发请求测试路径 - 处理并发请求
                // 关键词: 并发, 并发请求, goroutine, 并行处理
                id = str.TrimPrefix(req.URL.Path, "/concurrent/")
                rsp.Write(`{"concurrent": "` + id + `", "method": "` + req.Method + `"}`)
            } else {
                // 默认响应路径 - 回显请求信息
                // 关键词: 默认响应, 回显, echo, 请求回显
                rsp.Write(`{"echo": "` + req.Method + ` ` + req.URL.Path + `"}`)
            }
        }),
    )~
}

// 等待服务器启动 - 确保服务器可用
// 关键词: WaitConnect, 连接等待, 服务器就绪, 端口检测
os.WaitConnect(f"127.0.0.1:${port}", 3)~

// ===== 6.1 poc.HTTP函数 - 发送原始HTTP数据包 =====
// 关键词: poc.HTTP, HTTP发包, 原始数据包, 基础HTTP请求, 数据包发送
println("6.1 HTTP - 发送原始数据包并处理响应")
// 构造原始HTTP请求包 - GET方法示例
// 关键词: 原始请求包, HTTP请求构造, GET请求, 请求头设置
packet = `GET /test HTTP/1.1
Host: 127.0.0.1:` + string(port) + `
User-Agent: POC-Test/1.0

`
// 发送HTTP请求 - poc.HTTP函数基本用法
// 关键词: poc.HTTP调用, 超时设置, poc.timeout, HTTP发送
rsp, req, err = poc.HTTP(packet, poc.timeout(5))
// HTTP请求错误处理 - 检查请求是否成功
// 关键词: 错误处理, error handling, 请求失败, 异常处理
if err != nil {
    println("HTTP 请求错误:", err)
    assert false, "HTTP 请求不应该失败"
} else {
    // 显示原始请求和响应数据包
    // 关键词: 原始数据包, 请求响应查看, 数据包内容
    println("原始请求数据包:")
    println(string(req))
    println("原始响应数据包:")
    println(string(rsp))

    // 响应解析 - 使用POC库解析HTTP响应
    // 关键词: 响应解析, GetStatusCodeFromResponse, GetHTTPPacketBody, 状态码获取
    statusCode = poc.GetStatusCodeFromResponse(rsp)  // 获取HTTP状态码
    body = poc.GetHTTPPacketBody(rsp)               // 获取响应体
    println("响应状态码:", statusCode)
    println("响应体:", string(body))
    
    // 严格验证 - 确保请求响应符合预期
    // 关键词: 断言验证, assert, 响应验证, 状态码验证, 内容验证
    assert statusCode == 200, f"期望状态码200，实际得到${statusCode}"
    assert len(body) > 0, "响应体不应该为空"
    assert str.Contains(string(body), "GET /test"), "响应体应该包含请求路径信息"
    println("✓ HTTP 请求验证通过")
}

// ===== 6.2 poc.HTTPEx函数 - 返回结构体对象 =====
// 关键词: poc.HTTPEx, 结构体响应, LowhttpResponse, 高级HTTP请求, 结构化响应
println("\n6.2 HTTPEx - 发送并返回结构体，处理结构体响应")
// 构造HTTP请求包 - 用于HTTPEx演示
// 关键词: HTTPEx请求包, JSON路径请求
packet2 = `GET /json HTTP/1.1
Host: 127.0.0.1:` + string(port) + `

`
// 发送HTTPEx请求 - 返回结构化对象
// 关键词: poc.HTTPEx调用, 结构体返回, rspStruct, reqStruct
rspStruct, reqStruct, err = poc.HTTPEx(packet2, poc.timeout(5))
if err != nil {
    println("HTTPEx 请求错误:", err)
    assert false, "HTTPEx 请求不应该失败"
} else {
    // 请求结构体信息访问 - reqStruct对象属性
    // 关键词: 请求结构体, reqStruct属性, Method, URL, 请求信息获取
    println("请求结构体信息:")
    println("请求方法:", reqStruct.Method)        // 获取HTTP方法
    println("请求URL:", reqStruct.URL.String())   // 获取请求URL

    // 响应结构体信息访问 - rspStruct对象方法
    // 关键词: 响应结构体, rspStruct方法, GetStatusCode, GetDurationFloat, ResponseBodySize
    println("响应结构体信息:")
    println("响应状态码:", rspStruct.GetStatusCode())      // 获取状态码
    println("响应URL:", rspStruct.Url)                    // 获取响应URL
    println("响应时间:", rspStruct.GetDurationFloat())     // 获取响应时间
    println("响应体大小:", rspStruct.ResponseBodySize)     // 获取响应体大小

    // 响应体处理 - 从结构体中提取原始数据包
    // 关键词: RawPacket, 原始数据包提取, 响应体获取
    body = poc.GetHTTPPacketBody(rspStruct.RawPacket)
    println("响应体内容:", string(body))
    
    // HTTPEx结构体验证 - 验证结构体对象的正确性
    // 关键词: 结构体验证, HTTPEx验证, 方法验证, 状态码验证
    assert reqStruct.Method == "GET", f"期望请求方法GET，实际得到${reqStruct.Method}"
    assert rspStruct.GetStatusCode() == 200, f"期望状态码200，实际得到${rspStruct.GetStatusCode()}"
    assert rspStruct.ResponseBodySize > 0, "响应体大小应该大于0"
    assert str.Contains(string(body), "json"), "响应体应该包含json相关信息"
    assert str.Contains(string(body), "GET"), "响应体应该包含请求方法信息"
    println("✓ HTTPEx 请求验证通过")
}

// ===== 6.3 GET请求演示 - 使用HTTP函数发送GET请求 =====
// 关键词: GET请求, HTTP GET, GET方法, 查询请求, 数据获取
println("\n6.3 Get - 使用 HTTP 函数发送 GET 请求")
// 构造GET请求包 - 标准GET请求格式
// 关键词: GET请求包, GET数据包构造, HTTP GET格式
getPacket = `GET /get HTTP/1.1
Host: 127.0.0.1:` + string(port) + `

`
// 发送GET请求 - 使用poc.HTTP发送GET请求
// 关键词: GET请求发送, poc.HTTP GET, GET请求执行
rsp, req, err = poc.HTTP(getPacket, poc.timeout(5))
if err != nil {
    println("GET 请求错误:", err)
    assert false, "GET 请求不应该失败"
} else {
    println("GET 请求发送成功")
    statusCode = poc.GetStatusCodeFromResponse(rsp)
    body = poc.GetHTTPPacketBody(rsp)
    println("GET 响应状态码:", statusCode)
    println("GET 响应体:", string(body))
    
    // 严格验证
    assert statusCode == 200, f"期望状态码200，实际得到${statusCode}"
    assert len(body) > 0, "GET响应体不应该为空"
    assert str.Contains(string(body), "GET /get"), "响应体应该包含GET请求路径"
    println("✓ GET 请求验证通过")
}

// ===== 6.4 POST请求演示 - 发送JSON数据 =====
// 关键词: POST请求, HTTP POST, POST方法, JSON提交, 数据提交, 表单提交
println("\n6.4 Post - 使用 HTTP 函数发送 POST 请求（JSON）")
// 构造JSON请求体 - POST请求的数据内容
// 关键词: JSON请求体, POST数据, JSON数据, 请求体构造
jsonBody = `{"action": "test", "data": "hello"}`
// 构造POST请求包 - 包含JSON数据的POST请求
// 关键词: POST请求包, JSON POST, Content-Type, Content-Length, POST数据包
postPacket = `POST /post HTTP/1.1
Host: 127.0.0.1:` + string(port) + `
Content-Type: application/json
Content-Length: ` + string(len(jsonBody)) + `

` + jsonBody

// 发送POST请求 - 提交JSON数据
// 关键词: POST请求发送, JSON提交, poc.HTTP POST, POST请求执行
rsp, req, err = poc.HTTP(postPacket, poc.timeout(5))
if err != nil {
    println("POST 请求错误:", err)
    assert false, "POST 请求不应该失败"
} else {
    println("POST 请求发送成功")
    // 验证 JSON 请求体是否正确发送
    assert check == true, "JSON 请求体未正确发送"
    println("JSON 请求体验证通过")

    statusCode = poc.GetStatusCodeFromResponse(rsp)
    body = poc.GetHTTPPacketBody(rsp)
    println("POST 响应体:", string(body))
    
    // 严格验证
    assert statusCode == 200, f"期望状态码200，实际得到${statusCode}"
    assert len(body) > 0, "POST响应体不应该为空"
    assert str.Contains(string(body), "POST /post"), "响应体应该包含POST请求路径"
    println("✓ POST 请求验证通过")
}

println("\n6.5 Do - 演示 Do 函数（使用 HTTP 函数替代）")
doPacket = `PUT /put HTTP/1.1
Host: 127.0.0.1:` + string(port) + `
Content-Type: application/json

{"method": "put"}`

rsp, req, err = poc.HTTP(doPacket, poc.timeout(5))
if err != nil {
    println("PUT 请求错误:", err)
    assert false, "PUT 请求不应该失败"
} else {
    println("PUT 请求发送成功")
    statusCode = poc.GetStatusCodeFromResponse(rsp)
    body = poc.GetHTTPPacketBody(rsp)
    println("PUT 响应体:", string(body))
    
    // 严格验证
    assert statusCode == 200, f"期望状态码200，实际得到${statusCode}"
    assert len(body) > 0, "PUT响应体不应该为空"
    assert str.Contains(string(body), "PUT /put"), "响应体应该包含PUT请求路径"
    println("✓ PUT 请求验证通过")
}

println("\n6.6 Head - 使用 HTTP 函数发送 HEAD 请求")
headPacket = `HEAD /head HTTP/1.1
Host: 127.0.0.1:` + string(port) + `

`
rsp, req, err = poc.HTTP(headPacket, poc.timeout(5))
if err != nil {
    println("HEAD 请求错误:", err)
    assert false, "HEAD 请求不应该失败"
} else {
    println("HEAD 请求发送成功")
    statusCode = poc.GetStatusCodeFromResponse(rsp)
    println("HEAD 响应数据包长度:", len(rsp))
    
    // 严格验证
    assert statusCode == 200, f"期望状态码200，实际得到${statusCode}"
    assert len(rsp) > 0, "HEAD响应数据包不应该为空"
    // HEAD 请求通常没有 body，但有 headers
    assert str.Contains(string(rsp), "HTTP/1.1 200"), "响应应该包含200状态码"
    println("✓ HEAD 请求验证通过")
}

println("\n6.7 Delete - 使用 HTTP 函数发送 DELETE 请求")
deletePacket = `DELETE /delete HTTP/1.1
Host: 127.0.0.1:` + string(port) + `

`
rsp, req, err = poc.HTTP(deletePacket, poc.timeout(5))
if err != nil {
    println("DELETE 请求错误:", err)
    assert false, "DELETE 请求不应该失败"
} else {
    println("DELETE 请求发送成功")
    statusCode = poc.GetStatusCodeFromResponse(rsp)
    body = poc.GetHTTPPacketBody(rsp)
    println("DELETE 响应体:", string(body))
    
    // 严格验证
    assert statusCode == 200, f"期望状态码200，实际得到${statusCode}"
    assert len(body) > 0, "DELETE响应体不应该为空"
    assert str.Contains(string(body), "DELETE /delete"), "响应体应该包含DELETE请求路径"
    println("✓ DELETE 请求验证通过")
}

println("\n6.8 Options - 使用 HTTP 函数发送 OPTIONS 请求")
optionsPacket = `OPTIONS /options HTTP/1.1
Host: 127.0.0.1:` + string(port) + `

`
rsp, req, err = poc.HTTP(optionsPacket, poc.timeout(5))
if err != nil {
    println("OPTIONS 请求错误:", err)
    assert false, "OPTIONS 请求不应该失败"
} else {
    println("OPTIONS 请求发送成功")
    statusCode = poc.GetStatusCodeFromResponse(rsp)
    body = poc.GetHTTPPacketBody(rsp)
    println("OPTIONS 响应体:", string(body))
    
    // 严格验证
    assert statusCode == 200, f"期望状态码200，实际得到${statusCode}"
    assert len(body) > 0, "OPTIONS响应体不应该为空"
    assert str.Contains(string(body), "OPTIONS /options"), "响应体应该包含OPTIONS请求路径"
    println("✓ OPTIONS 请求验证通过")
}

println("\n6.9 重定向处理演示")
redirectPacket = `GET /redirect HTTP/1.1
Host: 127.0.0.1:` + string(port) + `

`
rsp, req, err = poc.HTTP(redirectPacket, poc.redirectTimes(3), poc.timeout(5))
if err != nil {
    println("重定向请求错误:", err)
    // 重定向可能因为服务器实现问题而失败，这里不强制断言
    println("注意：重定向测试可能因为本地服务器实现而失败，这是正常的")
} else {
    println("重定向请求发送成功")
    statusCode = poc.GetStatusCodeFromResponse(rsp)
    body = poc.GetHTTPPacketBody(rsp)
    println("重定向最终响应体:", string(body))
    
    // 验证重定向结果
    assert statusCode == 200, f"重定向后期望状态码200，实际得到${statusCode}"
    assert len(body) > 0, "重定向后响应体不应该为空"
    println("✓ 重定向请求验证通过")
}

// =============================================================================
// 7. 请求构建选项测试和实际使用演示
// POC库选项系统 HTTP选项 请求选项 构建选项 参数选项
// 关键词: 选项, options, 请求构建, BuildRequest, 选项组合, 参数设置
// =============================================================================
println("\n7. 请求构建选项测试和实际使用演示")

// ===== 7.1 poc.json选项 - JSON请求体选项 =====
// 关键词: poc.json, JSON选项, JSON请求体, JSON数据, application/json
println("7.1 json - JSON 请求体选项创建和使用")
// 创建JSON选项 - 将数据转换为JSON格式的请求体
// 关键词: JSON选项创建, poc.json函数, JSON数据转换, 请求体选项
jsonOpt = poc.json({"name": "test", "value": 123})
println("JSON 选项创建成功")

// JSON选项使用 - 在BuildRequest中应用JSON选项
// 关键词: BuildRequest, JSON选项应用, 选项组合, 请求构建
jsonPacket = poc.BuildRequest(poc.BasicRequest(),
    poc.replaceMethod("POST"),          // 设置POST方法
    poc.replacePath("/json-post"),      // 设置请求路径
    poc.replaceHost("127.0.0.1"),      // 设置主机
    jsonOpt)                           // 应用JSON选项
// 发送带JSON选项的请求 - 验证JSON选项效果
// 关键词: JSON请求发送, 选项验证, JSON选项测试
rsp, req, err = poc.HTTP(jsonPacket, poc.port(port), poc.timeout(5))
if err != nil {
    println("JSON 选项测试错误:", err)
    assert false, "JSON 选项测试不应该失败"
} else {
    statusCode = poc.GetStatusCodeFromResponse(rsp)
    body = poc.GetHTTPPacketBody(rsp)
    println("使用 JSON 选项的响应:", string(body))
    
    // 严格验证JSON选项
    assert statusCode == 200, f"期望状态码200，实际得到${statusCode}"
    assert len(body) > 0, "JSON选项响应体不应该为空"
    
    // 验证请求包中包含JSON内容
    requestStr = string(jsonPacket)
    assert str.Contains(requestStr, "application/json"), "请求应该包含JSON Content-Type"
    assert str.Contains(requestStr, "name"), "请求体应该包含JSON字段"
    assert str.Contains(requestStr, "test"), "请求体应该包含JSON值"
    println("✓ JSON 选项验证通过")
}

println("\n7.2 body - 原始请求体选项创建和使用")
bodyOpt = poc.body("raw data content")
println("Body 选项创建成功")

// 实际使用 body 选项
bodyPacket = poc.BuildRequest(poc.BasicRequest(),
    poc.replaceMethod("POST"),
    poc.replacePath("/raw-body"),
    poc.replaceHost("127.0.0.1"),
    bodyOpt)
rsp, req, err = poc.HTTP(bodyPacket, poc.port(port), poc.timeout(5))
if err != nil {
    println("Body 选项测试错误:", err)
    assert false, "Body 选项测试不应该失败"
} else {
    statusCode = poc.GetStatusCodeFromResponse(rsp)
    body = poc.GetHTTPPacketBody(rsp)
    println("使用 body 选项的响应:", string(body))
    
    // 严格验证Body选项
    assert statusCode == 200, f"期望状态码200，实际得到${statusCode}"
    assert len(body) > 0, "Body选项响应体不应该为空"
    
    // 验证请求包中包含原始body内容
    requestStr = string(bodyPacket)
    assert str.Contains(requestStr, "raw data content"), "请求体应该包含原始数据内容"
    println("✓ Body 选项验证通过")
}

// ===== 7.3 poc.query选项 - URL查询参数选项 =====
// 关键词: poc.query, 查询参数, URL参数, GET参数, 查询字符串, query string
println("\n7.3 query - 查询参数选项创建和使用")
// 创建查询参数选项 - 添加URL查询参数
// 关键词: 查询参数创建, poc.query函数, URL参数设置, GET参数
queryOpt = poc.query({"page": 1, "size": 10})
println("Query 选项创建成功")

// 实际使用 query 选项
queryPacket = poc.BuildRequest(poc.BasicRequest(),
    poc.replacePath("/query-test"),
    poc.replaceHost("127.0.0.1"),
    queryOpt)
rsp, req, err = poc.HTTP(queryPacket, poc.port(port), poc.timeout(5))
if err != nil {
    println("Query 选项测试错误:", err)
    assert false, "Query 选项测试不应该失败"
} else {
    statusCode = poc.GetStatusCodeFromResponse(rsp)
    body = poc.GetHTTPPacketBody(rsp)
    println("使用 query 选项的响应:", string(body))
    
    // 严格验证Query选项
    assert statusCode == 200, f"期望状态码200，实际得到${statusCode}"
    assert len(body) > 0, "Query选项响应体不应该为空"
    
    // 验证请求包中包含查询参数
    requestStr = string(queryPacket)
    assert str.Contains(requestStr, "page=1"), "请求应该包含查询参数page"
    assert str.Contains(requestStr, "size=10"), "请求应该包含查询参数size"
    println("✓ Query 选项验证通过")
}

// ===== 7.4 poc.postParams选项 - 表单参数选项 =====
// 关键词: poc.postParams, 表单参数, POST参数, 表单提交, form data, urlencoded
println("\n7.4 postParams - 表单参数选项创建和使用")
// 创建表单参数选项 - 设置POST表单数据
// 关键词: 表单参数创建, poc.postParams函数, 表单数据, POST表单
postParamsOpt = poc.postParams({"username": "admin", "password": "pass"})
println("PostParams 选项创建成功")

// 实际使用 postParams 选项
paramsPacket = poc.BuildRequest(poc.BasicRequest(),
    poc.replaceMethod("POST"),
    poc.replacePath("/form-params"),
    poc.replaceHost("127.0.0.1"),
    postParamsOpt)
rsp, req, err = poc.HTTP(paramsPacket, poc.port(port), poc.timeout(5))
if err != nil {
    println("PostParams 选项测试错误:", err)
    assert false, "PostParams 选项测试不应该失败"
} else {
    statusCode = poc.GetStatusCodeFromResponse(rsp)
    body = poc.GetHTTPPacketBody(rsp)
    println("使用 postParams 选项的响应:", string(body))
    
    // 严格验证PostParams选项
    assert statusCode == 200, f"期望状态码200，实际得到${statusCode}"
    assert len(body) > 0, "PostParams选项响应体不应该为空"
    
    // 验证请求包中包含表单参数
    requestStr = string(paramsPacket)
    assert str.Contains(requestStr, "application/x-www-form-urlencoded"), "请求应该包含表单Content-Type"
    // postParams会被URL编码，检查参数名是否存在
    assert str.Contains(requestStr, "username="), "请求体应该包含username参数"
    assert str.Contains(requestStr, "password="), "请求体应该包含password参数"
    println("✓ PostParams 选项验证通过")
}

println("\n7.5 postData - POST 数据选项创建和使用")
postDataOpt = poc.postData("field1=value1&field2=value2")
println("PostData 选项创建成功")

// 实际使用 postData 选项
dataPacket = poc.BuildRequest(poc.BasicRequest(),
    poc.replaceMethod("POST"),
    poc.replacePath("/postdata"),
    poc.replaceHost("127.0.0.1"),
    postDataOpt)
rsp, req, err = poc.HTTP(dataPacket, poc.port(port), poc.timeout(5))
if err != nil {
    println("PostData 选项测试错误:", err)
    assert false, "PostData 选项测试不应该失败"
} else {
    statusCode = poc.GetStatusCodeFromResponse(rsp)
    body = poc.GetHTTPPacketBody(rsp)
    println("使用 postData 选项的响应:", string(body))
    
    // 严格验证PostData选项
    assert statusCode == 200, f"期望状态码200，实际得到${statusCode}"
    assert len(body) > 0, "PostData选项响应体不应该为空"
    
    // 验证请求包中包含POST数据
    requestStr = string(dataPacket)
    assert str.Contains(requestStr, "field1=value1"), "请求体应该包含field1参数"
    assert str.Contains(requestStr, "field2=value2"), "请求体应该包含field2参数"
    println("✓ PostData 选项验证通过")
}

// ===== 7.6 poc.header选项 - 自定义请求头选项 =====
// 关键词: poc.header, 请求头, HTTP头, 自定义头, header, 头部设置
println("\n7.6 header - 请求头选项创建和使用")
// 创建自定义请求头选项 - 添加HTTP头部
// 关键词: 请求头创建, poc.header函数, HTTP头设置, 自定义头部
headerOpt = poc.header("X-Custom", "value")
println("Header 选项创建成功")

// 实际使用 header 选项
headerPacket = poc.BuildRequest(poc.BasicRequest(),
    poc.replacePath("/header-test"),
    poc.replaceHost("127.0.0.1"),
    headerOpt)
rsp, req, err = poc.HTTP(headerPacket, poc.port(port), poc.timeout(5))
if err != nil {
    println("Header 选项测试错误:", err)
    assert false, "Header 选项测试不应该失败"
} else {
    statusCode = poc.GetStatusCodeFromResponse(rsp)
    body = poc.GetHTTPPacketBody(rsp)
    println("使用 header 选项的响应:", string(body))
    
    // 严格验证Header选项
    assert statusCode == 200, f"期望状态码200，实际得到${statusCode}"
    assert len(body) > 0, "Header选项响应体不应该为空"
    
    // 验证请求包中包含自定义头
    requestStr = string(headerPacket)
    assert str.Contains(requestStr, "X-Custom: value"), "请求应该包含自定义头X-Custom"
    println("✓ Header 选项验证通过")
}

println("\n7.7 ua - User-Agent 选项创建和使用")
uaOpt = poc.ua("Custom-Agent/1.0")
println("UA 选项创建成功")

// 实际使用 ua 选项
uaPacket = poc.BuildRequest(poc.BasicRequest(),
    poc.replacePath("/ua-test"),
    poc.replaceHost("127.0.0.1"),
    uaOpt)
rsp, req, err = poc.HTTP(uaPacket, poc.port(port), poc.timeout(5))
if err != nil {
    println("UA 选项测试错误:", err)
    assert false, "UA 选项测试不应该失败"
} else {
    statusCode = poc.GetStatusCodeFromResponse(rsp)
    body = poc.GetHTTPPacketBody(rsp)
    println("使用 ua 选项的响应:", string(body))
    
    // 严格验证UA选项
    assert statusCode == 200, f"期望状态码200，实际得到${statusCode}"
    assert len(body) > 0, "UA选项响应体不应该为空"
    
    // 验证请求包中包含自定义User-Agent
    requestStr = string(uaPacket)
    assert str.Contains(requestStr, "User-Agent: Custom-Agent/1.0"), "请求应该包含自定义User-Agent"
    println("✓ UA 选项验证通过")
}

// ===== 7.8 poc.cookie选项 - Cookie选项 =====
// 关键词: poc.cookie, Cookie, 会话Cookie, 认证Cookie, 状态保持, session
println("\n7.8 cookie - Cookie 选项创建和使用")
// 创建Cookie选项 - 设置请求Cookie
// 关键词: Cookie创建, poc.cookie函数, Cookie设置, 会话管理
cookieOpt = poc.cookie("session=abc123")
println("Cookie 选项创建成功")

// 实际使用 cookie 选项
cookiePacket = poc.BuildRequest(poc.BasicRequest(),
    poc.replacePath("/cookie-test"),
    poc.replaceHost("127.0.0.1"),
    cookieOpt)
rsp, req, err = poc.HTTP(cookiePacket, poc.port(port), poc.timeout(5))
if err != nil {
    println("Cookie 选项测试错误:", err)
    assert false, "Cookie 选项测试不应该失败"
} else {
    statusCode = poc.GetStatusCodeFromResponse(rsp)
    body = poc.GetHTTPPacketBody(rsp)
    println("使用 cookie 选项的响应:", string(body))
    
    // 严格验证Cookie选项
    assert statusCode == 200, f"期望状态码200，实际得到${statusCode}"
    assert len(body) > 0, "Cookie选项响应体不应该为空"
    
    // 验证请求包中包含Cookie
    requestStr = string(cookiePacket)
    assert str.Contains(requestStr, "Cookie: session=abc123"), "请求应该包含Cookie头"
    println("✓ Cookie 选项验证通过")
}

// =============================================================================
// 8. 连接配置选项实际使用演示
// 网络连接配置 超时设置 主机端口配置 连接参数
// 关键词: 连接配置, 网络配置, 超时, timeout, host, port, 连接参数
// =============================================================================
println("\n8. 连接配置选项实际使用演示")

// ===== 8.1 poc.host/poc.port选项 - 主机端口配置 =====
// 关键词: poc.host, poc.port, 主机配置, 端口配置, 连接目标, 网络地址
println("8.1 host/port - 主机和端口选项的使用")
// 创建主机和端口选项 - 指定连接目标
// 关键词: 主机选项, 端口选项, 连接目标设置, 网络地址配置
hostOpt = poc.host("127.0.0.1")  // 设置目标主机
portOpt = poc.port(port)         // 设置目标端口
println("Host/Port 选项创建成功")

// 实际使用 host/port 选项
hostPortPacket = poc.BuildRequest(poc.BasicRequest(),
    poc.replacePath("/host-port-test"),
    hostOpt, portOpt)
rsp, req, err = poc.HTTP(hostPortPacket, poc.timeout(5))
if err != nil {
    println("Host/Port 测试错误:", err)
} else {
    body = poc.GetHTTPPacketBody(rsp)
    println("使用 host/port 选项的响应:", string(body))
}

// ===== 8.2 poc.timeout选项 - 请求超时配置 =====
// 关键词: poc.timeout, 超时设置, 请求超时, 网络超时, timeout配置
println("\n8.2 timeout - 超时选项的使用")
// 创建超时选项 - 设置请求超时时间
// 关键词: 超时选项创建, poc.timeout函数, 超时时间设置, 网络超时
timeoutOpt = poc.timeout(2.0)  // 设置2秒超时
println("Timeout 选项创建成功")

// 实际使用 timeout 选项
slowPacket = `GET /slow HTTP/1.1
Host: 127.0.0.1:` + string(port) + `

`
startTime = time.Now()
rsp, req, err = poc.HTTP(slowPacket, timeoutOpt)
endTime = time.Now()
if err != nil {
    duration = endTime.Sub(startTime)
    println("Timeout 测试超时，耗时:", duration.Milliseconds(), "ms")
} else {
    duration = endTime.Sub(startTime)
    println("请求耗时:", duration.Milliseconds(), "ms (应该在2秒内完成)")
    body = poc.GetHTTPPacketBody(rsp)
    println("Timeout 测试响应:", string(body))
}

println("\n8.3 connectTimeout - 连接超时选项的使用")
connectTimeoutOpt = poc.connectTimeout(1.0)  // 设置1秒连接超时
println("ConnectTimeout 选项创建成功")

// 实际使用 connectTimeout 选项
connectPacket = `GET /connect-timeout HTTP/1.1
Host: 127.0.0.1:` + string(port) + `

`
startTime = time.Now()
rsp, req, err = poc.HTTP(connectPacket, connectTimeoutOpt)
endTime = time.Now()
if err != nil {
    duration = endTime.Sub(startTime)
    println("ConnectTimeout 测试超时，耗时:", duration.Milliseconds(), "ms")
} else {
    duration = endTime.Sub(startTime)
    println("连接耗时:", duration.Milliseconds(), "ms")
    body = poc.GetHTTPPacketBody(rsp)
    println("ConnectTimeout 测试响应:", string(body))
}

// =============================================================================
// 9. 重试和重定向选项实际使用演示
// =============================================================================
println("\n9. 重试和重定向选项实际使用演示")

println("9.1 retryTimes - 重试次数选项的使用")
retryTimesOpt = poc.retryTimes(2)
retryWaitOpt = poc.retryWaitTime(0.5)
println("RetryTimes 选项创建成功")

// 实际使用 retryTimes 选项（模拟可能失败的请求）
retryPacket = `GET /retry-test HTTP/1.1
Host: 127.0.0.1:` + string(port) + `

`
rsp, req, err = poc.HTTP(retryPacket, retryTimesOpt, retryWaitOpt, poc.timeout(5))
if err != nil {
    println("RetryTimes 测试错误:", err)
} else {
    body = poc.GetHTTPPacketBody(rsp)
    println("使用 retryTimes 选项的响应:", string(body))
}

println("\n9.2 redirectTimes - 重定向次数选项的使用")
redirectTimesOpt = poc.redirectTimes(3)
println("RedirectTimes 选项创建成功")

// 实际使用 redirectTimes 选项
redirectPacket2 = `GET /redirect HTTP/1.1
Host: 127.0.0.1:` + string(port) + `

`
rsp, req, err = poc.HTTP(redirectPacket2, redirectTimesOpt, poc.timeout(5))
if err != nil {
    println("RedirectTimes 测试错误:", err)
} else {
    body = poc.GetHTTPPacketBody(rsp)
    println("使用 redirectTimes 选项的响应:", string(body))
}

println("\n9.3 noRedirect - 禁用重定向选项的使用")
noRedirectOpt = poc.noRedirect(true)
println("NoRedirect 选项创建成功")

// 实际使用 noRedirect 选项
redirectPacket3 = `GET /redirect HTTP/1.1
Host: 127.0.0.1:` + string(port) + `

`
rsp, req, err = poc.HTTP(redirectPacket3, noRedirectOpt, poc.timeout(5))
if err != nil {
    println("NoRedirect 测试错误:", err)
} else {
    statusCode = poc.GetStatusCodeFromResponse(rsp)
    body = poc.GetHTTPPacketBody(rsp)
    println("禁用重定向后状态码:", statusCode)
    println("禁用重定向的响应:", string(body))
}

// =============================================================================
// 10. 高级功能选项实际使用演示
// =============================================================================
println("\n10. 高级功能选项实际使用演示")

println("10.1 session - 会话管理选项的使用")
sessionOpt = poc.session("advanced-session")
println("Session 选项创建成功")

// 实际使用 session 选项（多次请求使用相同会话）
sessionPacket1 = `GET /session1 HTTP/1.1
Host: 127.0.0.1:` + string(port) + `

`
sessionPacket2 = `GET /session2 HTTP/1.1
Host: 127.0.0.1:` + string(port) + `

`
rsp1, req1, err1 = poc.HTTP(sessionPacket1, sessionOpt, poc.timeout(5))
rsp2, req2, err2 = poc.HTTP(sessionPacket2, sessionOpt, poc.timeout(5))
if err1 == nil && err2 == nil {
    body1 = poc.GetHTTPPacketBody(rsp1)
    body2 = poc.GetHTTPPacketBody(rsp2)
    println("会话请求1响应:", string(body1))
    println("会话请求2响应:", string(body2))
} else {
    println("Session 测试错误:", err1, err2)
}

println("\n10.2 context - 上下文选项的使用")
ctx = context.Background()
contextOpt = poc.context(ctx)
println("Context 选项创建成功")

// 实际使用 context 选项
contextPacket = `GET /context HTTP/1.1
Host: 127.0.0.1:` + string(port) + `

`
rsp, req, err = poc.HTTP(contextPacket, contextOpt, poc.timeout(5))
if err != nil {
    println("Context 测试错误:", err)
} else {
    body = poc.GetHTTPPacketBody(rsp)
    println("使用 context 选项的响应:", string(body))
}

println("\n10.3 组合多个选项的使用")
combinedOpts = [
    poc.header("X-Test-Header", "test-value"),
    poc.ua("Combined-Test/1.0"),
    poc.cookie("test=value"),
    poc.timeout(5.0)
]

combinedPacket = poc.BuildRequest(poc.BasicRequest(),
    poc.replaceMethod("POST"),
    poc.replacePath("/combined"),
    poc.replaceHost("127.0.0.1"),
    poc.json({"combined": "test"}),
    combinedOpts...)
rsp, req, err = poc.HTTP(combinedPacket, poc.port(port))
if err != nil {
    println("组合选项测试错误:", err)
} else {
    body = poc.GetHTTPPacketBody(rsp)
    println("组合选项响应:", string(body))

    // 验证组合选项是否生效
    assert check2 == true, "组合选项中的自定义头未生效"
    println("组合选项验证通过")
}

// =============================================================================
// 11. 高级请求构建和处理演示
// =============================================================================
println("\n11. 高级请求构建和处理演示")

println("11.1 BuildRequest - 高级请求构建")
builtPacket = poc.BuildRequest(poc.BasicRequest(),
    poc.replaceMethod("POST"),
    poc.replacePath("/advanced-build"),
    poc.replaceHost("127.0.0.1"),
    poc.replaceHeader("User-Agent", "Advanced-Builder/1.0"),
    poc.appendHeader("X-Built-With", "POC-Lib"),
    poc.replaceBody(`{"advanced": "build", "test": true}`, false))

println("构建的请求包长度:", len(builtPacket))
println("构建的请求包内容:")
println(string(builtPacket))

// 发送构建的请求
rsp, req, err = poc.HTTP(builtPacket, poc.port(port), poc.timeout(5))
if err != nil {
    println("构建请求发送错误:", err)
} else {
    body = poc.GetHTTPPacketBody(rsp)
    println("构建请求的响应:", string(body))
}

println("\n11.2 错误处理演示")
println("11.2.1 网络错误处理")
rsp, req, err = poc.Get("http://non-existent-domain-12345.com", poc.timeout(2))
if err != nil {
    println("网络错误正确捕获:", err)
} else {
    println("意外地连接成功了")
}

println("11.2.2 超时错误处理")
delayUrl = "http://127.0.0.1:" + string(port) + "/delay"
startTime = time.Now()
rsp, req, err = poc.Get(delayUrl, poc.timeout(1))  // 1秒超时
endTime = time.Now()
if err != nil {
    duration = endTime.Sub(startTime)
    println("超时错误正确捕获，耗时:", duration.Milliseconds(), "ms, 错误:", err)
}

// ===== 11.3 并发请求演示 - goroutine并发HTTP请求 =====
// 关键词: 并发请求, goroutine, 并行HTTP, channel, 并发编程, 多线程请求
println("\n11.3 并发请求演示")
// 创建结果收集通道 - 用于收集并发请求结果
// 关键词: channel创建, 结果收集, 并发通信, make channel, 缓冲通道
println("创建 channel 来收集并发请求结果")
results = make(chan any, 5)  // 创建缓冲为5的通道

// 启动并发请求 - 使用goroutine实现并行请求
// 关键词: 并发启动, goroutine循环, 并行执行, 多线程请求
println("启动 5 个并发请求")
for i := 0; i < 5; i++ {
    // 启动goroutine - 每个请求在独立的goroutine中执行
    // 关键词: go func, goroutine启动, 并发函数, 异步执行
    go func(id) {
        // 构建并发请求包 - 为每个goroutine构建独立的请求
        // 关键词: 并发请求构建, 独立请求包, 并行请求构造
        concurrentPacket = poc.BuildRequest(poc.BasicRequest(),
            poc.replaceMethod("GET"),
            poc.replacePath("/concurrent/" + string(id)),  // 每个请求有唯一路径
            poc.replaceHost("127.0.0.1"))
        
        // 发送并发请求 - 在goroutine中执行HTTP请求
        // 关键词: 并发HTTP请求, goroutine请求, 并行发送
        rsp, req, err = poc.HTTP(concurrentPacket, poc.port(port), poc.timeout(5))
        
        // 构建结果对象 - 收集请求结果信息
        // 关键词: 结果构建, 请求结果, 并发结果收集
        singleResult = {
            "id": id,                    // 请求ID
            "success": err == nil,       // 请求是否成功
            "status": 0,                // HTTP状态码
            "body_length": 0            // 响应体长度
        }
        
        // 处理成功响应 - 提取响应信息
        // 关键词: 响应处理, 状态码提取, 响应体长度
        if err == nil {
            singleResult["status"] = poc.GetStatusCodeFromResponse(rsp)
            singleResult["body_length"] = len(poc.GetHTTPPacketBody(rsp))
        }
        
        // 发送结果到通道 - 通过channel传递结果
        // 关键词: channel发送, 结果传递, 并发通信, 结果收集
        results <- singleResult
    }(i)  // 传递循环变量到goroutine
}

// 等待并收集结果 - 从channel接收所有并发请求的结果
// 关键词: 结果等待, channel接收, 并发同步, 结果收集, 并发等待
println("等待并发请求完成")
successCount = 0  // 成功请求计数器
// 循环接收结果 - 从channel中依次接收每个goroutine的结果
// 关键词: 结果接收循环, channel读取, 并发结果处理, 同步等待
for i := 0; i < 5; i++ {
    // 从通道接收结果 - 阻塞等待goroutine完成
    // 关键词: channel接收, 结果读取, 并发同步, 阻塞等待
    result = <-results
    // 提取结果信息 - 解析并发请求的结果数据
    // 关键词: 结果解析, 数据提取, 并发结果处理
    id = result["id"]
    success = result["success"]
    status = result["status"]
    bodyLength = result["body_length"]
    println(f"并发请求 ${id}: 成功=${success}, 状态码=${status}, 响应长度=${bodyLength}")
    
    // 并发请求验证 - 严格验证每个并发请求的结果
    // 关键词: 并发验证, 请求结果验证, 并发测试断言, 结果检查
    assert success == true, f"并发请求${id}应该成功"
    assert status == 200, f"并发请求${id}应该返回状态码200，实际得到${status}"
    assert bodyLength > 0, f"并发请求${id}响应体长度应该大于0"
    
    // 统计成功请求 - 计算成功的并发请求数量
    // 关键词: 成功统计, 请求计数, 并发成功率
    if success {
        successCount = successCount + 1
    }
}

// 最终验证 - 确保所有并发请求都正确完成
// 关键词: 最终验证, 并发完成验证, 通道清空验证, 成功率验证
assert len(results) == 0, "所有并发请求结果已处理"
assert successCount == 5, f"期望5个并发请求都成功，实际成功${successCount}个"
println("✓ 并发请求测试完成，所有5个请求都成功")

println("\n=== POC 库请求功能完整验证完成 ===")
