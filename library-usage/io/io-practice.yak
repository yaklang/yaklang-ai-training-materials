/*
Yaklang IO (输入输出操作) 库实践

IO库是Yaklang中用于输入输出操作的核心模块，提供了Reader、Writer、
文件读写、数据复制、管道操作等基础IO功能。

关键词: IO操作, Reader, Writer, 文件读写, 数据流
关键词: 管道操作, 数据复制, 缓冲IO, 流处理, 数据传输
*/

// 基础IO功能演示
// 关键词: io基础功能, Reader, Writer
func testBasicIOFeatures() {
    println("测试基础IO功能")
    
    // IO库基本概念
    // 关键词: IO概念, 接口设计
    println("IO库基本概念:")
    println("  - Reader: 读取数据的接口")
    println("  - Writer: 写入数据的接口")
    println("  - Copy: 数据复制操作")
    println("  - Pipe: 管道操作")
    
    // IO常量和变量
    println("\nIO常量:")
    println(f"  - io.EOF: ${io.EOF}")
    println("  - io.Discard: 丢弃写入器")
    
    println("基础IO功能演示完成")
}

// 文件读写测试
// 关键词: 文件读写, ReadFile, WriteString
func testFileReadWrite() {
    println("测试文件读写操作")
    
    // 创建测试文件
    // 关键词: 临时文件, 文件创建
    testFile = "/tmp/yaklang_io_test.txt"
    testContent = "Hello Yaklang IO!\nThis is a test file.\n测试中文内容\n"
    
    println(f"创建测试文件: ${testFile}")
    
    // 写入文件内容
    err = file.Save(testFile, testContent)
    assert err == nil, f"文件写入失败: ${err}"
    
    println("文件写入成功")
    
    // 使用io.ReadFile读取文件
    // 关键词: io.ReadFile, 文件读取
    println("使用io.ReadFile读取文件...")
    
    readContent, err = io.ReadFile(testFile)
    assert err == nil, f"文件读取失败: ${err}"
    
    readStr = string(readContent)
    assert readStr == testContent, f"文件内容不匹配: 期望 ${len(testContent)} 字节, 实际 ${len(readStr)} 字节"
    
    println(f"文件读取成功，内容长度: ${len(readStr)} 字节")
    
    // 使用io.ReadAll读取文件
    println("使用io.ReadAll读取文件...")
    
    fileHandle, err = file.Open(testFile)
    assert err == nil, f"文件打开失败: ${err}"
    
    allContent, err = io.ReadAll(fileHandle)
    assert err == nil, f"ReadAll失败: ${err}"
    
    allStr = string(allContent)
    assert allStr == testContent, "ReadAll内容不匹配"
    
    println(f"ReadAll成功，内容长度: ${len(allStr)} 字节")
    
    // 清理测试文件
    file.Remove(testFile)
    
    println("文件读写测试完成")
}

// 数据复制测试
// 关键词: io.Copy, io.CopyN, 数据复制
func testDataCopy() {
    println("测试数据复制操作")
    
    // 准备源数据
    sourceData = "This is source data for copy test.\n包含中文的测试数据。\n"
    
    // 创建源文件和目标文件
    sourceFile = "/tmp/yaklang_source.txt"
    targetFile = "/tmp/yaklang_target.txt"
    
    // 写入源文件
    err = file.Save(sourceFile, sourceData)
    assert err == nil, f"源文件创建失败: ${err}"
    
    println("源文件创建成功")
    
    // 测试io.Copy完整复制
    // 关键词: io.Copy, 完整复制
    println("测试io.Copy完整复制...")
    
    srcReader, err = file.Open(sourceFile)
    assert err == nil, f"源文件打开失败: ${err}"
    
    dstWriter, err = file.Create(targetFile)
    assert err == nil, f"目标文件创建失败: ${err}"
    
    copiedBytes, err = io.Copy(dstWriter, srcReader)
    assert err == nil, f"Copy操作失败: ${err}"
    
    println(f"Copy操作成功，复制了 ${copiedBytes} 字节")
    
    // 验证复制结果
    targetContent, err = io.ReadFile(targetFile)
    assert err == nil, f"目标文件读取失败: ${err}"
    
    targetStr = string(targetContent)
    assert targetStr == sourceData, "复制内容不匹配"
    
    println("Copy操作验证成功")
    
    // 测试io.CopyN部分复制
    // 关键词: io.CopyN, 部分复制
    println("测试io.CopyN部分复制...")
    
    partialFile = "/tmp/yaklang_partial.txt"
    copyLength = 20
    
    srcReader2, err = file.Open(sourceFile)
    assert err == nil, f"源文件重新打开失败: ${err}"
    
    dstWriter2, err = file.Create(partialFile)
    assert err == nil, f"部分文件创建失败: ${err}"
    
    partialBytes, err = io.CopyN(dstWriter2, srcReader2, copyLength)
    assert err == nil, f"CopyN操作失败: ${err}"
    
    println(f"CopyN操作成功，复制了 ${partialBytes} 字节")
    
    // 验证部分复制结果
    partialContent, err = io.ReadFile(partialFile)
    assert err == nil, f"部分文件读取失败: ${err}"
    
    assert len(partialContent) == copyLength, f"部分复制长度不匹配: 期望 ${copyLength}, 实际 ${len(partialContent)}"
    
    expectedPartial = sourceData[:copyLength]
    actualPartial = string(partialContent)
    assert actualPartial == expectedPartial, "部分复制内容不匹配"
    
    println("CopyN操作验证成功")
    
    // 清理测试文件
    file.Remove(sourceFile)
    file.Remove(targetFile)
    file.Remove(partialFile)
    
    println("数据复制测试完成")
}

// Reader操作测试
// 关键词: LimitReader, MultiReader, TeeReader
func testReaderOperations() {
    println("测试Reader操作")
    
    // 准备测试数据
    testData1 = "First part of data. "
    testData2 = "Second part of data. "
    testData3 = "Third part of data."
    
    // 创建测试文件
    testFile1 = "/tmp/yaklang_reader1.txt"
    testFile2 = "/tmp/yaklang_reader2.txt"
    testFile3 = "/tmp/yaklang_reader3.txt"
    
    file.Save(testFile1, testData1)
    file.Save(testFile2, testData2)
    file.Save(testFile3, testData3)
    
    // 测试io.LimitReader
    // 关键词: io.LimitReader, 限制读取
    println("测试io.LimitReader...")
    
    reader1, err = file.Open(testFile1)
    assert err == nil, f"文件1打开失败: ${err}"
    
    limitedReader = io.LimitReader(reader1, 10)
    limitedData, err = io.ReadAll(limitedReader)
    assert err == nil, f"LimitReader读取失败: ${err}"
    
    assert len(limitedData) == 10, f"LimitReader长度不匹配: 期望 10, 实际 ${len(limitedData)}"
    
    expectedLimited = testData1[:10]
    actualLimited = string(limitedData)
    assert actualLimited == expectedLimited, "LimitReader内容不匹配"
    
    println(f"LimitReader测试成功，读取了 ${len(limitedData)} 字节")
    
    // 测试io.MultiReader
    // 关键词: io.MultiReader, 多Reader合并
    println("测试io.MultiReader...")
    
    reader2, err = file.Open(testFile1)
    assert err == nil, f"文件1重新打开失败: ${err}"
    
    reader3, err = file.Open(testFile2)
    assert err == nil, f"文件2打开失败: ${err}"
    
    reader4, err = file.Open(testFile3)
    assert err == nil, f"文件3打开失败: ${err}"
    
    multiReader = io.MultiReader(reader2, reader3, reader4)
    multiData, err = io.ReadAll(multiReader)
    assert err == nil, f"MultiReader读取失败: ${err}"
    
    expectedMulti = testData1 + testData2 + testData3
    actualMulti = string(multiData)
    assert actualMulti == expectedMulti, "MultiReader内容不匹配"
    
    println(f"MultiReader测试成功，合并读取了 ${len(multiData)} 字节")
    
    // 测试io.TeeReader
    // 关键词: io.TeeReader, 分流读取
    println("测试io.TeeReader...")
    
    teeFile = "/tmp/yaklang_tee.txt"
    
    reader5, err = file.Open(testFile1)
    assert err == nil, f"文件1再次打开失败: ${err}"
    
    teeWriter, err = file.Create(teeFile)
    assert err == nil, f"Tee文件创建失败: ${err}"
    
    teeReader = io.TeeReader(reader5, teeWriter)
    teeData, err = io.ReadAll(teeReader)
    assert err == nil, f"TeeReader读取失败: ${err}"
    
    // 验证TeeReader结果
    actualTee = string(teeData)
    assert actualTee == testData1, "TeeReader读取内容不匹配"
    
    // 验证写入的Tee文件
    teeContent, err = io.ReadFile(teeFile)
    assert err == nil, f"Tee文件读取失败: ${err}"
    
    teeStr = string(teeContent)
    assert teeStr == testData1, "TeeReader写入内容不匹配"
    
    println(f"TeeReader测试成功，同时读取和写入了 ${len(teeData)} 字节")
    
    // 清理测试文件
    file.Remove(testFile1)
    file.Remove(testFile2)
    file.Remove(testFile3)
    file.Remove(teeFile)
    
    println("Reader操作测试完成")
}

// 管道操作测试
// 关键词: io.Pipe, 管道通信
func testPipeOperations() {
    println("测试管道操作")
    
    // 创建管道
    // 关键词: io.Pipe, 管道创建
    println("创建IO管道...")
    
    reader, writer = io.Pipe()
    
    assert reader != nil, "管道Reader不应为空"
    assert writer != nil, "管道Writer不应为空"
    
    println("管道创建成功")
    
    // 准备测试数据
    pipeData = "Hello from pipe!\nThis is pipe communication test.\n管道通信测试"
    
    // 管道写入和读取（需要并发操作）
    // 关键词: 管道通信, 并发操作
    println("测试管道通信...")
    
    receivedData = ""
    writeComplete = false
    readComplete = false
    
    // 启动写入协程
    go func() {
        bytesWritten, err = io.WriteString(writer, pipeData)
        if err == nil {
            println(f"管道写入成功: ${bytesWritten} 字节")
        } else {
            println(f"管道写入失败: ${err}")
        }
        writer.Close()
        writeComplete = true
    }()
    
    // 启动读取协程
    go func() {
        readData, err = io.ReadAll(reader)
        if err == nil {
            receivedData = string(readData)
            println(f"管道读取成功: ${len(readData)} 字节")
        } else {
            println(f"管道读取失败: ${err}")
        }
        reader.Close()
        readComplete = true
    }()
    
    // 等待操作完成
    maxWait = 50  // 最多等待5秒
    waitCount = 0
    
    for waitCount < maxWait {
        if writeComplete && readComplete {
            break
        }
        sleep(0.1)
        waitCount = waitCount + 1
    }
    
    // 验证管道通信结果
    if writeComplete && readComplete {
        assert receivedData == pipeData, f"管道数据不匹配: 期望长度 ${len(pipeData)}, 实际长度 ${len(receivedData)}"
        println("管道通信验证成功")
    } else {
        println("管道通信超时，但这不影响功能演示")
    }
    
    println("管道操作测试完成")
}

// 稳定读取测试
// 关键词: io.ReadStable, 稳定读取
func testStableRead() {
    println("测试稳定读取功能")
    
    // 创建测试数据
    stableData = "Stable read test data.\nThis data should be read stably.\n"
    stableFile = "/tmp/yaklang_stable.txt"
    
    err = file.Save(stableFile, stableData)
    assert err == nil, f"稳定读取测试文件创建失败: ${err}"
    
    // 测试io.ReadStable
    // 关键词: io.ReadStable, 超时读取
    println("测试io.ReadStable...")
    
    stableReader, err = file.Open(stableFile)
    assert err == nil, f"稳定读取文件打开失败: ${err}"
    
    // 使用1秒超时进行稳定读取
    stableResult = io.ReadStable(stableReader, 1.0)
    
    stableStr = string(stableResult)
    assert stableStr == stableData, "稳定读取内容不匹配"
    
    println(f"稳定读取成功: ${len(stableResult)} 字节")
    
    // 清理测试文件
    file.Remove(stableFile)
    
    println("稳定读取测试完成")
}

// IO工具函数测试
// 关键词: WriteString, NopCloser, IO工具
func testIOUtilities() {
    println("测试IO工具函数")
    
    // 测试io.WriteString
    // 关键词: io.WriteString, 字符串写入
    println("测试io.WriteString...")
    
    stringFile = "/tmp/yaklang_string.txt"
    stringData = "WriteString test content.\n字符串写入测试内容。"
    
    stringWriter, err = file.Create(stringFile)
    assert err == nil, f"字符串文件创建失败: ${err}"
    
    writtenBytes, err = io.WriteString(stringWriter, stringData)
    assert err == nil, f"WriteString失败: ${err}"
    
    println(f"WriteString成功: ${writtenBytes} 字节")
    
    stringWriter.Close()
    
    // 验证写入结果
    stringContent, err = io.ReadFile(stringFile)
    assert err == nil, f"字符串文件读取失败: ${err}"
    
    stringStr = string(stringContent)
    assert stringStr == stringData, "WriteString内容不匹配"
    
    println("WriteString验证成功")
    
    // 测试io.NopCloser
    // 关键词: io.NopCloser, 无操作关闭器
    println("测试io.NopCloser...")
    
    nopReader, err = file.Open(stringFile)
    assert err == nil, f"NopCloser文件打开失败: ${err}"
    
    nopCloser = io.NopCloser(nopReader)
    
    nopData, err = io.ReadAll(nopCloser)
    assert err == nil, f"NopCloser读取失败: ${err}"
    
    nopStr = string(nopData)
    assert nopStr == stringData, "NopCloser内容不匹配"
    
    println(f"NopCloser测试成功: ${len(nopData)} 字节")
    
    // 清理测试文件
    file.Remove(stringFile)
    
    println("IO工具函数测试完成")
}

// IO最佳实践演示
// 关键词: IO最佳实践, 性能优化
func testIOBestPractices() {
    println("演示IO使用最佳实践")
    
    println("=== IO使用最佳实践 ===")
    
    println("1. 资源管理:")
    println("   - 及时关闭文件句柄")
    println("   - 使用defer确保资源释放")
    println("   - 避免资源泄露")
    
    println("2. 错误处理:")
    println("   - 检查所有IO操作的错误")
    println("   - 区分不同类型的错误")
    println("   - 提供有意义的错误信息")
    
    println("3. 性能优化:")
    println("   - 使用缓冲IO减少系统调用")
    println("   - 批量操作提高效率")
    println("   - 避免频繁的小IO操作")
    
    println("4. 数据处理:")
    println("   - 使用流式处理大文件")
    println("   - 合理使用LimitReader控制内存")
    println("   - 利用MultiReader合并数据源")
    
    println("5. 并发安全:")
    println("   - 注意Reader/Writer的并发安全性")
    println("   - 使用管道进行协程间通信")
    println("   - 避免竞态条件")
    
    println("=== 实际应用场景 ===")
    
    println("文件处理:")
    println("  - 大文件分块读取")
    println("  - 日志文件实时监控")
    println("  - 配置文件解析")
    
    println("网络通信:")
    println("  - HTTP请求体处理")
    println("  - 流式数据传输")
    println("  - 协议数据解析")
    
    println("数据转换:")
    println("  - 格式转换管道")
    println("  - 数据过滤和处理")
    println("  - 编码解码操作")
    
    println("系统集成:")
    println("  - 进程间通信")
    println("  - 外部命令交互")
    println("  - 系统资源监控")
    
    println("IO最佳实践演示完成")
}

// 执行所有IO测试
func main() {
    println("开始Yaklang IO库功能测试")
    println("")
    
    // 基础功能演示
    testBasicIOFeatures()
    println("")
    
    testFileReadWrite()
    println("")
    
    testDataCopy()
    println("")
    
    // 高级功能测试
    testReaderOperations()
    println("")
    
    testPipeOperations()
    println("")
    
    testStableRead()
    println("")
    
    testIOUtilities()
    println("")
    
    // 最佳实践演示
    testIOBestPractices()
    println("")
    
    println("IO库功能测试完成")
    println("所有IO操作和功能演示完成")
}

/*
IO库核心功能总结:

1. 基础IO操作:
   - io.ReadFile() - 读取文件内容
   - io.ReadAll() - 读取Reader全部内容
   - io.Copy() - 复制数据流
   - io.CopyN() - 复制指定长度数据

2. Reader操作:
   - io.LimitReader() - 限制读取长度
   - io.MultiReader() - 合并多个Reader
   - io.TeeReader() - 分流读取
   - io.NopCloser() - 无操作关闭器

3. Writer操作:
   - io.WriteString() - 写入字符串
   - io.Discard - 丢弃写入器

4. 管道操作:
   - io.Pipe() - 创建管道
   - 支持并发读写
   - 协程间通信

5. 高级功能:
   - io.ReadStable() - 稳定读取
   - io.ReadEvery1s() - 定时读取
   - 超时控制

6. 常量和错误:
   - io.EOF - 文件结束标识
   - io.Discard - 丢弃写入器

7. 应用场景:
   - 文件读写操作
   - 数据流处理
   - 网络数据传输
   - 协程间通信
   - 数据格式转换

8. 性能特性:
   - 流式处理
   - 内存效率
   - 并发安全
   - 资源管理

9. 最佳实践:
   - 及时关闭资源
   - 错误处理完善
   - 使用缓冲IO
   - 流式处理大数据
   - 并发安全考虑

IO库提供了Yaklang中所有输入输出操作的基础设施，
是文件处理、网络通信、数据流处理的核心组件。
*/

// 调用主函数
main()
