// =============================================================================
// Java反编译功能完整测试与交叉验证
// =============================================================================
// 本脚本测试 java.Decompile 反编译功能：
// 1. 生成真实的Java类文件
// 2. 编译为.class字节码
// 3. 反编译还原为.java源码
// 4. 对比验证反编译结果
// 5. 测试JAR包反编译
// =============================================================================

// 测试目录设置
// 关键词: 测试目录, /tmp/javatest, 反编译测试
testBaseDir = "/tmp/java_decompile_test"
sourceDir = file.Join(testBaseDir, "source")
classDir = file.Join(testBaseDir, "classes")
decompiledDir = file.Join(testBaseDir, "decompiled")
jarDir = file.Join(testBaseDir, "jars")

// 创建测试目录
file.MkdirAll(sourceDir)~
file.MkdirAll(classDir)~
file.MkdirAll(decompiledDir)~
file.MkdirAll(jarDir)~

yakit.Info("测试基础目录: " + testBaseDir)
yakit.Info("源码目录: " + sourceDir)
yakit.Info("字节码目录: " + classDir)
yakit.Info("反编译目录: " + decompiledDir)

// =============================================================================
// 第一部分: 生成测试用的Java源码
// Java源码生成 测试类编写 编译准备
// 关键词: Java源码, 测试类, javac编译, 源码生成
// =============================================================================
println("\n" + "=" * 80)
println("第一部分: 生成测试用的Java源码")
println("=" * 80)

// ===== 1.1 简单Java类 =====
// 关键词: 简单类, HelloWorld, 基础测试
println("\n1.1 生成简单Java类")

simpleJavaCode = `public class SimpleTest {
    private String message;
    private int count;
    
    public SimpleTest() {
        this.message = "Hello, World!";
        this.count = 0;
    }
    
    public SimpleTest(String msg, int cnt) {
        this.message = msg;
        this.count = cnt;
    }
    
    public String getMessage() {
        return message;
    }
    
    public void setMessage(String message) {
        this.message = message;
    }
    
    public int getCount() {
        return count;
    }
    
    public void increment() {
        count++;
    }
    
    public static void main(String[] args) {
        SimpleTest test = new SimpleTest();
        System.out.println(test.getMessage());
        test.increment();
        System.out.println("Count: " + test.getCount());
    }
}`

simpleJavaFile = file.Join(sourceDir, "SimpleTest.java")
file.Save(simpleJavaFile, simpleJavaCode)~
yakit.Success("SimpleTest.java 已生成")

// ===== 1.2 带接口的Java类 =====
// 关键词: 接口, 实现类, 多态测试
println("\n1.2 生成带接口的Java类")

interfaceCode = `public interface Calculator {
    int add(int a, int b);
    int subtract(int a, int b);
    int multiply(int a, int b);
    double divide(int a, int b);
}`

calculatorInterfaceFile = file.Join(sourceDir, "Calculator.java")
file.Save(calculatorInterfaceFile, interfaceCode)~

implCode = `public class SimpleCalculator implements Calculator {
    @Override
    public int add(int a, int b) {
        return a + b;
    }
    
    @Override
    public int subtract(int a, int b) {
        return a - b;
    }
    
    @Override
    public int multiply(int a, int b) {
        return a * b;
    }
    
    @Override
    public double divide(int a, int b) {
        if (b == 0) {
            throw new ArithmeticException("Division by zero");
        }
        return (double) a / b;
    }
    
    public static void main(String[] args) {
        Calculator calc = new SimpleCalculator();
        System.out.println("2 + 3 = " + calc.add(2, 3));
        System.out.println("5 - 2 = " + calc.subtract(5, 2));
    }
}`

implFile = file.Join(sourceDir, "SimpleCalculator.java")
file.Save(implFile, implCode)~
yakit.Success("Calculator接口和SimpleCalculator实现类已生成")

// ===== 1.3 内部类测试 =====
// 关键词: 内部类, 嵌套类, 匿名类
println("\n1.3 生成内部类测试")

innerClassCode = `public class OuterClass {
    private String outerField = "Outer";
    
    public class InnerClass {
        private String innerField = "Inner";
        
        public void display() {
            System.out.println("Outer: " + outerField);
            System.out.println("Inner: " + innerField);
        }
    }
    
    public static class StaticInnerClass {
        public void show() {
            System.out.println("Static Inner Class");
        }
    }
    
    public void createAnonymous() {
        Runnable r = new Runnable() {
            @Override
            public void run() {
                System.out.println("Anonymous Class");
            }
        };
        r.run();
    }
}`

innerClassFile = file.Join(sourceDir, "OuterClass.java")
file.Save(innerClassFile, innerClassCode)~
yakit.Success("OuterClass内部类测试已生成")

println("✓ Java源码生成完成")

// =============================================================================
// 第二部分: 编译Java源码为字节码
// javac编译 字节码生成 编译验证
// 关键词: javac, 编译, 字节码, class文件
// =============================================================================
println("\n" + "=" * 80)
println("第二部分: 编译Java源码为字节码")
println("=" * 80)

// ===== 2.1 检查javac是否可用 =====
// 关键词: javac检查, Java环境, JDK验证
println("\n2.1 检查Java编译环境")

javacCheckResult, _ = exec.System("sh -c 'javac -version 2>&1'")
yakit.Info("javac版本信息:\n" + string(javacCheckResult))

// ===== 2.2 编译所有Java源文件 =====
// 关键词: 批量编译, javac执行, 编译输出
println("\n2.2 编译Java源文件")

compileCmd = sprintf("sh -c 'javac -d %v %v/*.java 2>&1'", classDir, sourceDir)
yakit.Info("编译命令: " + compileCmd)

compileResult, _ = exec.System(compileCmd)
if string(compileResult) != "" {
    yakit.Warn("编译输出: " + string(compileResult))
}

// 验证编译结果 - 检查关键class文件
simpleTestClass = file.Join(classDir, "SimpleTest.class")
calculatorClass = file.Join(classDir, "Calculator.class")
simpleCalculatorClass = file.Join(classDir, "SimpleCalculator.class")

classCount = 0
if file.IsExisted(simpleTestClass) {
    classCount++
    yakit.Info("编译生成: SimpleTest.class")
}
if file.IsExisted(calculatorClass) {
    classCount++
    yakit.Info("编译生成: Calculator.class")
}
if file.IsExisted(simpleCalculatorClass) {
    classCount++
    yakit.Info("编译生成: SimpleCalculator.class")
}

assert classCount >= 3, "应该生成至少3个class文件"
yakit.Success(sprintf("成功编译 %v 个主要class文件", classCount))

println("✓ Java编译完成")

// =============================================================================
// 第三部分: 反编译测试与验证
// java.Decompile 反编译验证 源码对比
// 关键词: java.Decompile, 反编译, 源码还原, 交叉验证
// =============================================================================
println("\n" + "=" * 80)
println("第三部分: 反编译测试与验证")
println("=" * 80)

// ===== 3.1 反编译单个class文件 =====
// 关键词: 单文件反编译, class反编译, 源码还原
println("\n3.1 反编译单个class文件")

simpleClassFile = file.Join(classDir, "SimpleTest.class")
simpleDecompileDir = file.Join(decompiledDir, "simple")

yakit.Info("反编译: " + simpleClassFile)
java.Decompile(simpleClassFile, simpleDecompileDir)~

// 验证反编译结果
decompiledJavaFile = file.Join(simpleDecompileDir, "SimpleTest.java")
assert file.IsExisted(decompiledJavaFile), "反编译后应该生成.java文件"

decompiledContent = file.ReadFile(decompiledJavaFile)~
decompiledStr = string(decompiledContent)

yakit.Info(sprintf("反编译源码长度: %v bytes", len(decompiledStr)))

// 基础验证：检查关键内容
// 关键词: 反编译验证, 内容检查, 关键字验证
assert str.Contains(decompiledStr, "class SimpleTest"), "应包含类定义"
assert str.Contains(decompiledStr, "getMessage"), "应包含方法定义"
yakit.Success("SimpleTest.class 反编译验证通过")

println("✓ 单文件反编译完成")

// ===== 3.2 反编译接口和实现类 =====
// 关键词: 接口反编译, 实现类反编译, 多文件反编译
println("\n3.2 反编译接口和实现类")

calcClassFile = file.Join(classDir, "SimpleCalculator.class")
calcDecompileDir = file.Join(decompiledDir, "calculator")

java.Decompile(calcClassFile, calcDecompileDir)~

calcDecompiledFile = file.Join(calcDecompileDir, "SimpleCalculator.java")
assert file.IsExisted(calcDecompiledFile), "SimpleCalculator应该被反编译"

calcDecompiledContent = string(file.ReadFile(calcDecompiledFile)~)
assert str.Contains(calcDecompiledContent, "implements Calculator"), "应包含接口实现"
yakit.Success("SimpleCalculator反编译验证通过")

// 同时反编译接口
interfaceClassFile = file.Join(classDir, "Calculator.class")
interfaceDecompileDir = file.Join(decompiledDir, "interface")

java.Decompile(interfaceClassFile, interfaceDecompileDir)~

interfaceDecompiledFile = file.Join(interfaceDecompileDir, "Calculator.java")
assert file.IsExisted(interfaceDecompiledFile), "Calculator接口应该被反编译"

println("✓ 接口和实现类反编译完成")

// ===== 3.3 反编译内部类 =====
// 关键词: 内部类反编译, 嵌套类, $符号类
println("\n3.3 反编译内部类")

outerDecompileDir = file.Join(decompiledDir, "inner")

// OuterClass主类
outerClassFile = file.Join(classDir, "OuterClass.class")
java.Decompile(outerClassFile, outerDecompileDir)~

// 检查生成的文件
decompiled_count = 0
filesys.Recursive(outerDecompileDir,
    filesys.onFileStat((path, info) => {
        if file.GetExt(file.GetFileName(path)) == ".java" {
            decompiled_count++
            yakit.Info(sprintf("反编译: %v", file.GetFileName(path)))
        }
        return nil
    })
)

assert decompiled_count > 0, "内部类应该被反编译"
yakit.Success(sprintf("内部类反编译完成，生成 %v 个源文件", decompiled_count))

println("✓ 内部类反编译完成")

// =============================================================================
// 第四部分: JAR包反编译测试
// JAR创建 JAR反编译 批量反编译
// 关键词: JAR包, jar命令, JAR反编译, 批量处理
// =============================================================================
println("\n" + "=" * 80)
println("第四部分: JAR包反编译测试")
println("=" * 80)

// ===== 4.1 创建测试JAR包 =====
// 关键词: JAR创建, jar命令, 打包
println("\n4.1 创建测试JAR包")

jarFile = file.Join(jarDir, "test-calculator.jar")
createJarCmd = sprintf("sh -c 'jar cf %v -C %v . 2>&1'", jarFile, classDir)
yakit.Info("创建JAR命令: " + createJarCmd)

createJarResult, _ = exec.System(createJarCmd)
assert file.IsExisted(jarFile), "JAR文件应该被创建"

jarSize = len(file.ReadFile(jarFile)~)
yakit.Success(sprintf("JAR包创建成功: %v (%v bytes)", jarFile, jarSize))

// ===== 4.2 反编译JAR包 =====
// 关键词: JAR反编译, java.Decompile, 批量反编译
println("\n4.2 反编译JAR包")

jarDecompileDir = file.Join(decompiledDir, "from_jar")
yakit.Info("反编译JAR到: " + jarDecompileDir)

java.Decompile(jarFile, jarDecompileDir)~

// 统计反编译结果
jarDecompiledCount = 0
filesys.Recursive(jarDecompileDir,
    filesys.onFileStat((path, info) => {
        if file.GetExt(file.GetFileName(path)) == ".java" {
            jarDecompiledCount++
            yakit.Info(sprintf("从JAR反编译: %v", file.GetFileName(path)))
        }
        return nil
    })
)

assert jarDecompiledCount > 0, "JAR包应该被反编译出源文件"
yakit.Success(sprintf("JAR包反编译完成，生成 %v 个源文件", jarDecompiledCount))

println("✓ JAR包反编译完成")

// =============================================================================
// 第五部分: 使用YSO生成的类进行反编译验证
// YSO类生成 YSO类反编译 交叉验证
// 关键词: YSO类, 恶意类反编译, 交叉验证, 字节码验证
// =============================================================================
println("\n" + "=" * 80)
println("第五部分: YSO生成类的反编译验证")
println("=" * 80)

// ===== 5.1 生成YSO测试类 =====
// 关键词: yso.GenerateRuntimeExecEvilClassObject, YSO类生成
println("\n5.1 生成YSO测试类")

ysoClass = yso.GenerateRuntimeExecEvilClassObject(
    "echo YSO_TEST",
    yso.evilClassName("YSOTestClass"),
    yso.majorVersion(52),
)~

ysoClassBytes = yso.ToBytes(ysoClass)~
ysoClassFile = file.Join(classDir, "YSOTestClass.class")
file.Save(ysoClassFile, ysoClassBytes)~
yakit.Success(sprintf("YSO测试类已生成: %v (%v bytes)", ysoClassFile, len(ysoClassBytes)))

// ===== 5.2 反编译YSO类 =====
// 关键词: YSO类反编译, 恶意类还原, 反编译验证
println("\n5.2 反编译YSO生成的类")

ysoDecompileDir = file.Join(decompiledDir, "yso")
java.Decompile(ysoClassFile, ysoDecompileDir)~

ysoDecompiledFile = file.Join(ysoDecompileDir, "YSOTestClass.java")
assert file.IsExisted(ysoDecompiledFile), "YSO类应该能被反编译"

ysoDecompiledContent = string(file.ReadFile(ysoDecompiledFile)~)
yakit.Info(sprintf("YSO反编译源码长度: %v bytes", len(ysoDecompiledContent)))

// 显示部分反编译内容
if len(ysoDecompiledContent) > 0 {
    preview = ysoDecompiledContent[:min(500, len(ysoDecompiledContent))]
    yakit.Code("YSO反编译源码预览:\n" + preview + "\n...")
}

yakit.Success("YSO类反编译验证通过")

println("✓ YSO类反编译完成")

// =============================================================================
// 第六部分: 反编译质量评估
// 反编译质量 语法检查 完整性验证
// 关键词: 质量评估, 语法完整性, 反编译质量
// =============================================================================
println("\n" + "=" * 80)
println("第六部分: 反编译质量评估")
println("=" * 80)

// ===== 6.1 统计反编译结果 =====
// 关键词: 统计分析, 文件统计, 成功率
println("\n6.1 反编译结果统计")

totalDecompiledFiles = 0
totalDecompiledSize = 0

filesys.Recursive(decompiledDir,
    filesys.onFileStat((path, info) => {
        if file.GetExt(file.GetFileName(path)) == ".java" {
            totalDecompiledFiles++
            content = file.ReadFile(path)~
            totalDecompiledSize += len(content)
        }
        return nil
    })
)

yakit.Info(sprintf("反编译文件总数: %v", totalDecompiledFiles))
yakit.Info(sprintf("反编译代码总大小: %v bytes", totalDecompiledSize))
yakit.Success("反编译统计完成")

// ===== 6.2 关键特性验证 =====
// 关键词: 特性验证, 语法元素, 反编译完整性
println("\n6.2 关键特性验证")

// 读取SimpleTest反编译内容进行详细验证
simpleDecompiledContent = string(file.ReadFile(decompiledJavaFile)~)

verificationResults = {
    "类定义": str.Contains(simpleDecompiledContent, "class SimpleTest"),
    "构造方法": str.Contains(simpleDecompiledContent, "SimpleTest("),
    "字段定义": str.Contains(simpleDecompiledContent, "message") || str.Contains(simpleDecompiledContent, "String"),
    "方法定义": str.Contains(simpleDecompiledContent, "getMessage"),
    "返回语句": str.Contains(simpleDecompiledContent, "return"),
}

allPassed = true
for feature, passed in verificationResults {
    if passed {
        yakit.Info(sprintf("[✓] %v: 通过", feature))
    } else {
        yakit.Warn(sprintf("[✗] %v: 未通过", feature))
        allPassed = false
    }
}

if allPassed {
    yakit.Success("所有关键特性验证通过")
} else {
    yakit.Warn("部分特性验证未通过")
}

println("✓ 质量评估完成")

// =============================================================================
// 测试总结
// =============================================================================
println("\n" + "=" * 80)
println("测试总结")
println("=" * 80)

yakit.Success(sprintf(`
Java反编译功能测试完成！

测试目录: %v

生成统计:
  - 源码文件: 4个 (SimpleTest, Calculator, SimpleCalculator, OuterClass)
  - 编译class: %v个
  - JAR包: 1个
  - YSO测试类: 1个

反编译统计:
  - 反编译文件数: %v个
  - 反编译代码总大小: %v bytes

测试覆盖:
  ✓ 简单类反编译
  ✓ 接口和实现类反编译
  ✓ 内部类反编译
  ✓ JAR包反编译
  ✓ YSO生成类反编译
  ✓ 反编译质量评估

所有Java反编译测试通过!

查看反编译结果:
  ls -R %v
`, testBaseDir, len(classFiles), totalDecompiledFiles, totalDecompiledSize, decompiledDir))

println("=" * 80)

