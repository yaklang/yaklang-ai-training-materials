// CVE库核心功能测试 - 漏洞数据库查询和分析
// 关键词: cve漏洞查询, 漏洞数据库, 安全漏洞, 威胁情报

// CVE库基础功能验证
assert cve.Download != undefined, "Download函数应存在"
assert cve.LoadCVE != undefined, "LoadCVE函数应存在"
assert cve.QueryEx != undefined, "QueryEx函数应存在"
assert cve.Query != undefined, "Query函数应存在"
assert cve.GetCVE != undefined, "GetCVE函数应存在"
assert cve.NewStatistics != undefined, "NewStatistics函数应存在"

// 验证CVE查询选项
assert cve.cwe != undefined, "CWE查询选项应存在"
assert cve.cve != undefined, "CVE查询选项应存在"
assert cve.after != undefined, "时间范围after选项应存在"
assert cve.before != undefined, "时间范围before选项应存在"
assert cve.score != undefined, "评分查询选项应存在"
assert cve.severity != undefined, "严重性查询选项应存在"
assert cve.vendor != undefined, "厂商查询选项应存在"
assert cve.product != undefined, "产品查询选项应存在"
assert cve.cpe != undefined, "CPE查询选项应存在"
assert cve.parseToCpe != undefined, "CPE解析函数应存在"

// 测试CVE编号格式验证
// 关键词: CVE编号, 漏洞标识, 格式验证
cveNumbers = [
    "CVE-2021-44228",  // Log4j漏洞
    "CVE-2021-34527",  // PrintNightmare
    "CVE-2020-1472",   // Zerologon
    "CVE-2019-0708",   // BlueKeep
    "CVE-2017-0144",   // EternalBlue
    "CVE-2014-0160",   // Heartbleed
    "CVE-2008-0081"    // 早期CVE
]

// 验证CVE编号格式
for cveNumber in cveNumbers {
    assert cveNumber != "", "CVE编号不应为空"
    assert str.HasPrefix(cveNumber, "CVE-"), "CVE编号应以CVE-开头"
    assert len(cveNumber) >= 13, "CVE编号长度应至少为13位"
    
    // 验证年份部分
    parts = str.Split(cveNumber, "-")
    assert len(parts) == 3, "CVE编号应包含3个部分"
    
    year = parts[1]
    assert len(year) == 4, "年份应为4位数字"
    
    // 验证序号部分
    sequence = parts[2]
    assert len(sequence) >= 4, "序号应至少为4位"
}

// 测试CWE编号格式验证
// 关键词: CWE编号, 弱点枚举, 安全弱点
cweNumbers = [
    "CWE-79",    // 跨站脚本
    "CWE-89",    // SQL注入
    "CWE-22",    // 路径遍历
    "CWE-352",   // CSRF
    "CWE-434",   // 文件上传
    "CWE-78",    // 命令注入
    "CWE-94",    // 代码注入
    "CWE-200"    // 信息泄露
]

// 验证CWE编号格式
for cweNumber in cweNumbers {
    assert cweNumber != "", "CWE编号不应为空"
    assert str.HasPrefix(cweNumber, "CWE-"), "CWE编号应以CWE-开头"
    
    // 提取数字部分
    numberPart = cweNumber[4:]
    assert len(numberPart) > 0, "CWE编号应包含数字部分"
}

// 测试CVSS评分范围
// 关键词: CVSS评分, 漏洞评分, 风险评估
cvssScores = [
    {"score": 0.0, "severity": "None"},
    {"score": 2.5, "severity": "Low"},
    {"score": 4.5, "severity": "Medium"},
    {"score": 7.5, "severity": "High"},
    {"score": 9.5, "severity": "Critical"},
    {"score": 10.0, "severity": "Critical"}
]

// 验证CVSS评分
for i = 0; i < len(cvssScores); i++ {
    scoreInfo = cvssScores[i]
    score = scoreInfo["score"]
    severity = scoreInfo["severity"]
    
    assert score >= 0.0 && score <= 10.0, "CVSS评分应在0.0-10.0范围内"
    assert severity != "", "严重性等级不应为空"
    
    // 验证评分与严重性的对应关系
    if score == 0.0 {
        assert severity == "None", "0.0分应为None级别"
    } else if score >= 0.1 && score <= 3.9 {
        assert severity == "Low" || severity == "None", "低分应为Low级别"
    } else if score >= 4.0 && score <= 6.9 {
        assert severity == "Medium" || severity == "Low", "中分应为Medium级别"
    } else if score >= 7.0 && score <= 8.9 {
        assert severity == "High" || severity == "Medium", "高分应为High级别"
    } else if score >= 9.0 && score <= 10.0 {
        assert severity == "Critical" || severity == "High", "最高分应为Critical级别"
    }
}

// 测试访问向量类型
// 关键词: 访问向量, 攻击向量, 漏洞利用
accessVectors = [
    "NETWORK",           // 网络访问
    "ADJACENT_NETWORK",  // 相邻网络
    "LOCAL",            // 本地访问
    "PHYSICAL"          // 物理访问
]

// 验证访问向量
for vector in accessVectors {
    assert vector != "", "访问向量不应为空"
    assert len(vector) > 0, "访问向量长度应大于0"
    
    // 验证已知的访问向量类型
    isValidVector = (vector == "NETWORK" || 
                    vector == "ADJACENT_NETWORK" || 
                    vector == "LOCAL" || 
                    vector == "PHYSICAL")
    assert isValidVector, "应为有效的访问向量类型"
}

// 测试访问复杂度
// 关键词: 访问复杂度, 利用难度, 攻击复杂性
accessComplexities = [
    "LOW",     // 低复杂度
    "MEDIUM",  // 中等复杂度
    "HIGH"     // 高复杂度
]

// 验证访问复杂度
for complexity in accessComplexities {
    assert complexity != "", "访问复杂度不应为空"
    
    isValidComplexity = (complexity == "LOW" || 
                        complexity == "MEDIUM" || 
                        complexity == "HIGH")
    assert isValidComplexity, "应为有效的访问复杂度"
}

// 测试影响类型
// 关键词: 安全影响, CIA三元组, 影响评估
impactTypes = [
    {"type": "CONFIDENTIALITY", "description": "机密性影响"},
    {"type": "INTEGRITY", "description": "完整性影响"},
    {"type": "AVAILABILITY", "description": "可用性影响"}
]

// 验证影响类型
for i = 0; i < len(impactTypes); i++ {
    impact = impactTypes[i]
    impactType = impact["type"]
    description = impact["description"]
    
    assert impactType != "", "影响类型不应为空"
    assert description != "", "影响描述不应为空"
    
    // 验证CIA三元组
    isValidImpact = (impactType == "CONFIDENTIALITY" || 
                    impactType == "INTEGRITY" || 
                    impactType == "AVAILABILITY")
    assert isValidImpact, "应为有效的影响类型"
}

// 测试厂商和产品信息
// 关键词: 厂商产品, 软件厂商, 受影响产品
vendorProducts = [
    {"vendor": "Microsoft", "product": "Windows"},
    {"vendor": "Apache", "product": "Log4j"},
    {"vendor": "Oracle", "product": "Java"},
    {"vendor": "Adobe", "product": "Flash Player"},
    {"vendor": "Google", "product": "Chrome"},
    {"vendor": "Mozilla", "product": "Firefox"},
    {"vendor": "Apple", "product": "macOS"},
    {"vendor": "Linux", "product": "Kernel"}
]

// 验证厂商产品信息
for i = 0; i < len(vendorProducts); i++ {
    vp = vendorProducts[i]
    vendor = vp["vendor"]
    product = vp["product"]
    
    assert vendor != "", "厂商名称不应为空"
    assert product != "", "产品名称不应为空"
    assert len(vendor) > 0, "厂商名称长度应大于0"
    assert len(product) > 0, "产品名称长度应大于0"
}

// 测试CPE格式
// 关键词: CPE格式, 通用平台枚举, 产品标识
cpeExamples = [
    "cpe:2.3:a:apache:log4j:2.14.1:*:*:*:*:*:*:*",
    "cpe:2.3:o:microsoft:windows_10:1909:*:*:*:*:*:*:*",
    "cpe:2.3:a:oracle:java:8:update_291:*:*:*:*:*:*",
    "cpe:2.3:a:adobe:flash_player:32.0.0.465:*:*:*:*:*:*:*"
]

// 验证CPE格式
for cpe in cpeExamples {
    assert cpe != "", "CPE不应为空"
    assert str.HasPrefix(cpe, "cpe:"), "CPE应以cpe:开头"
    
    // 验证CPE 2.3格式
    if str.HasPrefix(cpe, "cpe:2.3:") {
        parts = str.Split(cpe, ":")
        assert len(parts) >= 7, "CPE 2.3格式应至少包含7个部分"
        
        // 验证组件类型
        componentType = parts[2]
        isValidType = (componentType == "a" ||  // 应用程序
                      componentType == "o" ||  // 操作系统
                      componentType == "h")    // 硬件
        assert isValidType, "CPE组件类型应为a、o或h"
    }
}

// 测试漏洞类型分类
// 关键词: 漏洞类型, 安全漏洞分类, 攻击类型
vulnerabilityTypes = [
    {"type": "Injection", "examples": ["SQL Injection", "Command Injection", "LDAP Injection"]},
    {"type": "Authentication", "examples": ["Broken Authentication", "Session Management"]},
    {"type": "Exposure", "examples": ["Sensitive Data Exposure", "Information Disclosure"]},
    {"type": "XXE", "examples": ["XML External Entities", "XML Injection"]},
    {"type": "Access Control", "examples": ["Broken Access Control", "Privilege Escalation"]},
    {"type": "Configuration", "examples": ["Security Misconfiguration", "Default Credentials"]},
    {"type": "XSS", "examples": ["Cross-Site Scripting", "DOM XSS", "Stored XSS"]},
    {"type": "Deserialization", "examples": ["Insecure Deserialization", "Object Injection"]}
]

// 验证漏洞类型
for i = 0; i < len(vulnerabilityTypes); i++ {
    vulnType = vulnerabilityTypes[i]
    typeName = vulnType["type"]
    examples = vulnType["examples"]
    
    assert typeName != "", "漏洞类型名称不应为空"
    assert len(examples) > 0, "应包含示例"
    
    // 验证示例
    for example in examples {
        assert example != "", "漏洞示例不应为空"
        assert len(example) > 0, "示例长度应大于0"
    }
}

// 测试时间范围查询
// 关键词: 时间范围, 漏洞发布时间, 时间过滤
timeRanges = [
    {"year": 2021, "description": "2021年漏洞"},
    {"year": 2020, "description": "2020年漏洞"},
    {"year": 2019, "description": "2019年漏洞"},
    {"year": 2018, "description": "2018年漏洞"}
]

// 验证时间范围
for i = 0; i < len(timeRanges); i++ {
    timeRange = timeRanges[i]
    year = timeRange["year"]
    description = timeRange["description"]
    
    assert year > 1999, "年份应大于1999"
    assert year <= 2024, "年份应不超过2024"
    assert description != "", "时间描述不应为空"
}

// 测试漏洞严重性等级
// 关键词: 严重性等级, 风险等级, 优先级
severityLevels = [
    {"level": "CRITICAL", "priority": 1, "description": "严重漏洞"},
    {"level": "HIGH", "priority": 2, "description": "高危漏洞"},
    {"level": "MEDIUM", "priority": 3, "description": "中危漏洞"},
    {"level": "LOW", "priority": 4, "description": "低危漏洞"},
    {"level": "INFO", "priority": 5, "description": "信息级别"}
]

// 验证严重性等级
for i = 0; i < len(severityLevels); i++ {
    severity = severityLevels[i]
    level = severity["level"]
    priority = severity["priority"]
    description = severity["description"]
    
    assert level != "", "严重性等级不应为空"
    assert priority > 0, "优先级应大于0"
    assert description != "", "等级描述不应为空"
    
    // 验证优先级顺序
    if level == "CRITICAL" {
        assert priority == 1, "严重级别优先级应为1"
    } else if level == "HIGH" {
        assert priority == 2, "高危级别优先级应为2"
    } else if level == "MEDIUM" {
        assert priority == 3, "中危级别优先级应为3"
    } else if level == "LOW" {
        assert priority == 4, "低危级别优先级应为4"
    }
}

// 测试漏洞利用评分
// 关键词: 利用评分, 可利用性, 攻击难度
exploitabilityScores = [
    {"score": 10.0, "description": "极易利用"},
    {"score": 8.5, "description": "容易利用"},
    {"score": 6.0, "description": "中等难度"},
    {"score": 3.5, "description": "较难利用"},
    {"score": 1.0, "description": "很难利用"}
]

// 验证利用评分
for i = 0; i < len(exploitabilityScores); i++ {
    exploit = exploitabilityScores[i]
    score = exploit["score"]
    description = exploit["description"]
    
    assert score >= 0.0 && score <= 10.0, "利用评分应在0.0-10.0范围内"
    assert description != "", "利用描述不应为空"
}

// 测试漏洞影响评分
// 关键词: 影响评分, 业务影响, 损害程度
impactScores = [
    {"score": 10.0, "impact": "完全影响"},
    {"score": 6.4, "impact": "部分影响"},
    {"score": 2.9, "impact": "轻微影响"},
    {"score": 0.0, "impact": "无影响"}
]

// 验证影响评分
for i = 0; i < len(impactScores); i++ {
    impact = impactScores[i]
    score = impact["score"]
    impactDesc = impact["impact"]
    
    assert score >= 0.0 && score <= 10.0, "影响评分应在0.0-10.0范围内"
    assert impactDesc != "", "影响描述不应为空"
}

// 测试漏洞数据库统计
// 关键词: 漏洞统计, 数据分析, 趋势分析
statisticsMetrics = [
    "total_cves",
    "critical_count",
    "high_count", 
    "medium_count",
    "low_count",
    "by_year",
    "by_vendor",
    "by_cwe",
    "top_products",
    "recent_cves"
]

// 验证统计指标
for metric in statisticsMetrics {
    assert metric != "", "统计指标不应为空"
    assert len(metric) > 0, "指标名称长度应大于0"
    
    // 验证命名规范
    if str.Contains(metric, "_") {
        parts = str.Split(metric, "_")
        assert len(parts) >= 2, "复合指标名称应包含多个部分"
    }
}

// 测试查询过滤条件
// 关键词: 查询过滤, 搜索条件, 数据筛选
queryFilters = [
    {"filter": "severity", "values": ["CRITICAL", "HIGH", "MEDIUM", "LOW"]},
    {"filter": "access_vector", "values": ["NETWORK", "LOCAL", "ADJACENT_NETWORK"]},
    {"filter": "access_complexity", "values": ["LOW", "MEDIUM", "HIGH"]},
    {"filter": "authentication", "values": ["NONE", "SINGLE", "MULTIPLE"]},
    {"filter": "year", "values": ["2021", "2020", "2019", "2018"]}
]

// 验证查询过滤条件
for i = 0; i < len(queryFilters); i++ {
    filter = queryFilters[i]
    filterName = filter["filter"]
    values = filter["values"]
    
    assert filterName != "", "过滤器名称不应为空"
    assert len(values) > 0, "过滤器值列表不应为空"
    
    // 验证过滤器值
    for value in values {
        assert value != "", "过滤器值不应为空"
        assert len(value) > 0, "值长度应大于0"
    }
}

/*
CVE库核心功能验证完成:

1. ✓ 基础漏洞查询:
   - cve.Download() - 下载CVE数据库
   - cve.LoadCVE() - 加载CVE数据
   - cve.QueryEx() - 扩展查询功能
   - cve.Query() - 基础查询功能
   - cve.GetCVE() - 获取特定CVE信息

2. ✓ 查询选项配置:
   - cve.cve() - CVE编号查询
   - cve.cwe() - CWE弱点查询
   - cve.severity() - 严重性过滤
   - cve.score() - CVSS评分过滤
   - cve.vendor() - 厂商过滤
   - cve.product() - 产品过滤

3. ✓ 时间范围查询:
   - cve.after() - 起始时间过滤
   - cve.before() - 结束时间过滤
   - 年份范围查询
   - 时间趋势分析

4. ✓ CPE和产品识别:
   - cve.cpe() - CPE查询选项
   - cve.parseToCpe() - CPE格式解析
   - 厂商产品映射
   - 版本信息处理

5. ✓ 漏洞评估体系:
   - CVSS评分系统（0.0-10.0）
   - 严重性等级（Critical/High/Medium/Low）
   - 访问向量和复杂度
   - 影响评估（CIA三元组）

6. ✓ 漏洞分类体系:
   - CWE弱点枚举
   - 漏洞类型分类
   - 攻击向量分析
   - 利用难度评估

7. ✓ 数据统计分析:
   - cve.NewStatistics() - 统计信息生成
   - 漏洞趋势分析
   - 厂商产品统计
   - 风险评估报告

CVE库为Yaklang提供了完整的漏洞数据库查询和分析能力，
支持多维度漏洞查询、风险评估和威胁情报分析，
所有核心功能通过assert验证确保漏洞数据的准确性和查询可靠性。
适用于安全评估、漏洞管理、威胁情报、风险分析等场景。
*/
