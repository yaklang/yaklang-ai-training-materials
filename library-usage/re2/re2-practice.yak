// =============================================================================
// yaklang re2 库使用练习和实战案例
// re2库高级正则 regexp2库 复杂模式 高级匹配 国际化支持
// 关键词: re2.Find, re2.FindAll, re2.Compile, regexp2, 高级正则, 复杂模式
// =============================================================================

println("yaklang re2 库功能测试开始...")

// =============================================================================
// 1. 基础查找功能测试
// 基础查找 高级搜索 模式匹配 内容定位
// 关键词: Find, 基础查找, 高级搜索, 模式匹配
// =============================================================================
println("\n1. 基础查找功能测试")

// 简单查找测试
text = "Hello World 123"
try {
    result = re2.Find(text, "\\d+")
    assert result == "123", "Should find digits"
    
    result = re2.Find(text, "World")
    assert result == "World", "Should find exact word"
    
    result = re2.Find(text, "notfound")
    if result == nil {
        result = ""
    }
    assert result == "", "Should return empty when not found"
} catch err {
    println("re2.Find 测试错误:", err)
}

// 中文文本查找测试
chinese_text = "你好世界 Hello World"
try {
    result = re2.Find(chinese_text, "[\\u4e00-\\u9fff]+")
    if result != nil && result != "" {
        println("找到中文字符:", result)
    } else {
        println("中文字符匹配: 可能不支持Unicode范围")
    }
} catch err {
    println("中文字符查找:", err)
}

println("基础查找功能测试: 通过")

// =============================================================================
// 2. 查找所有匹配项测试
// 全局搜索 批量匹配 多重查找 数据收集
// 关键词: FindAll, 全局搜索, 批量匹配, 多重查找
// =============================================================================
println("\n2. 查找所有匹配项测试")

// 查找所有匹配
text = "yakit is GUI client for yaklang and yak"
results = re2.FindAll(text, "yak[a-z]*")
assert len(results) >= 3, "Should find multiple yak-related words"

// 查找所有数字
number_text = "Version 1.2.3, Build 456, Release 7.8.9"
numbers = re2.FindAll(number_text, "\\d+")
assert len(numbers) >= 6, "Should find multiple numbers"

// 查找所有邮箱地址
email_text = "Contact admin@example.com or support@test.org"
emails = re2.FindAll(email_text, "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}")
assert len(emails) >= 2, "Should find multiple emails"

println("查找所有匹配项测试: 通过")

// =============================================================================
// 3. 子匹配功能测试
// 子匹配 捕获组 分组匹配 高级分组
// 关键词: FindSubmatch, 子匹配, 捕获组, 分组匹配
// =============================================================================
println("\n3. 子匹配功能测试")

// 捕获组测试
text = "Version 1.2.3"
matches = re2.FindSubmatch(text, "(\\d+)\\.(\\d+)\\.(\\d+)")
assert len(matches) == 4, "Should have full match and 3 groups"
assert matches[0] == "1.2.3", "Full match should be version"
assert matches[1] == "1", "First group should be major"
assert matches[2] == "2", "Second group should be minor"
assert matches[3] == "3", "Third group should be patch"

// 命名捕获组测试
text = "User: admin, Role: administrator"
try {
    matches = re2.FindSubmatch(text, "User: (?P<user>\\w+), Role: (?P<role>\\w+)")
    assert len(matches) >= 3, "Should have matches with named groups"
    println("命名捕获组: 支持")
} catch err {
    println("命名捕获组:", err)
    // 使用普通捕获组作为替代
    matches = re2.FindSubmatch(text, "User: (\\w+), Role: (\\w+)")
    assert len(matches) >= 3, "Should have matches with regular groups"
    println("使用普通捕获组替代")
}

println("子匹配功能测试: 通过")

// =============================================================================
// 4. 所有子匹配测试
// 批量子匹配 多重捕获 全部分组 批量处理
// 关键词: FindSubmatchAll, 批量子匹配, 多重捕获, 全部分组
// =============================================================================
println("\n4. 所有子匹配测试")

text = "User1: admin, Role1: admin; User2: guest, Role2: user"
all_matches = re2.FindSubmatchAll(text, "User\\d+: (\\w+), Role\\d+: (\\w+)")
assert len(all_matches) == 2, "Should find 2 user-role pairs"

for matches in all_matches {
    assert len(matches) == 3, "Each match should have full match and 2 groups"
    assert matches[1] != "", "Username should not be empty"
    assert matches[2] != "", "Role should not be empty"
}

println("所有子匹配测试: 通过")

// =============================================================================
// 5. 替换功能测试
// 高级替换 模式替换 字符串替换 内容变换
// 关键词: ReplaceAll, 高级替换, 模式替换, 字符串替换
// =============================================================================
println("\n5. 替换功能测试")

// 简单替换
text = "yakit is a great tool"
result = re2.ReplaceAll(text, "yakit", "yaklang")
assert result.Contains("yaklang"), "Should replace yakit with yaklang"

// 使用捕获组替换
text = "Date: 2023-12-25"
result = re2.ReplaceAll(text, "(\\d{4})-(\\d{2})-(\\d{2})", "$3/$2/$1")
assert result.Contains("25/12/2023"), "Should reformat date"

// 多个替换
text = "Phone: 123-456-7890 and 987-654-3210"
result = re2.ReplaceAll(text, "\\d{3}-\\d{3}-\\d{4}", "XXX-XXX-XXXX")
assert result.Contains("XXX-XXX-XXXX"), "Should mask phone numbers"

println("替换功能测试: 通过")

// =============================================================================
// 6. 函数式替换测试
// 函数替换 回调替换 动态替换 自定义处理
// 关键词: ReplaceAllWithFunc, 函数替换, 回调替换, 动态替换
// =============================================================================
println("\n6. 函数式替换测试")

// 使用函数进行替换
text = "Convert: 10, 20, 30"
result = re2.ReplaceAllWithFunc(text, "\\d+", func(match) {
    return sprintf("(%s*2)", match)
})
assert result.Contains("(10*2)"), "Should modify first number"
assert result.Contains("(20*2)"), "Should modify second number"
assert result.Contains("(30*2)"), "Should modify third number"

// 大小写转换
text = "hello world yaklang"
result = re2.ReplaceAllWithFunc(text, "\\b\\w+\\b", func(word) {
    return str.ToUpper(word)
})
assert result.Contains("HELLO"), "Should convert to uppercase"
assert result.Contains("WORLD"), "Should convert to uppercase"
assert result.Contains("YAKLANG"), "Should convert to uppercase"

println("函数式替换测试: 通过")

// =============================================================================
// 7. 命名组功能测试
// 命名组 高级分组 模式分组 命名捕获
// 关键词: FindGroup, 命名组, 高级分组, 模式分组
// =============================================================================
println("\n7. 命名组功能测试")

// 命名捕获组测试
text = "Server: nginx/1.18.0, Port: 80"
try {
    groups = re2.FindGroup(text, "Server: (?P<server>\\w+)/(?P<version>[\\d.]+), Port: (?P<port>\\d+)")
    assert len(groups) >= 4, "Should have multiple groups"
    println("re2命名捕获组: 支持")
} catch err {
    println("re2命名捕获组:", err)
    // 使用普通捕获组
    groups = re2.FindGroup(text, "Server: (\\w+)/([\\d.]+), Port: (\\d+)")
    assert len(groups) >= 4, "Should have multiple groups"
    assert groups["1"] == "nginx", "Should extract server name"
    assert groups["2"] == "1.18.0", "Should extract version"
    assert groups["3"] == "80", "Should extract port"
    println("使用普通捕获组替代")
}

// 数字索引组
text = "IP: 192.168.1.100"
groups = re2.FindGroup(text, "IP: (\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)")
assert groups["1"] == "192", "First octet should be 192"
assert groups["2"] == "168", "Second octet should be 168"
assert groups["3"] == "1", "Third octet should be 1"
assert groups["4"] == "100", "Fourth octet should be 100"

println("命名组功能测试: 通过")

// =============================================================================
// 8. 所有命名组测试
// 批量命名组 多重命名捕获 全部命名组 批量分组
// 关键词: FindGroupAll, 批量命名组, 多重命名捕获, 全部命名组
// =============================================================================
println("\n8. 所有命名组测试")

text = "Server1: apache/2.4.41, Server2: nginx/1.18.0"
try {
    all_groups = re2.FindGroupAll(text, "Server\\d+: (?P<name>\\w+)/(?P<version>[\\d.]+)")
    assert len(all_groups) == 2, "Should find 2 server entries"
    println("re2批量命名组: 支持")
} catch err {
    println("re2批量命名组:", err)
    // 使用普通捕获组
    all_groups = re2.FindGroupAll(text, "Server\\d+: (\\w+)/([\\d.]+)")
    assert len(all_groups) == 2, "Should find 2 server entries"
    
    for groups in all_groups {
        assert groups["1"] != "", "Server name should not be empty"
        assert groups["2"] != "", "Version should not be empty"
    }
    println("使用普通捕获组替代")
}

println("所有命名组测试: 通过")

// =============================================================================
// 9. 编译选项测试
// 编译选项 高级编译 正则选项 模式配置
// 关键词: Compile, CompileWithOption, 编译选项, 高级编译
// =============================================================================
println("\n9. 编译选项测试")

// 基础编译测试
regex, err = re2.Compile("hello")~
assert err == nil, "Should compile basic regex"

// 忽略大小写选项
regex, err = re2.CompileWithOption("HELLO", re2.OPT_IgnoreCase)~
assert err == nil, "Should compile with ignore case option"

// 多行模式测试
multiline_text = `Line 1
Line 2
Line 3`
regex, err = re2.CompileWithOption("^Line", re2.OPT_Multiline)~
assert err == nil, "Should compile with multiline option"

println("编译选项测试: 通过")

// =============================================================================
// 10. 高级模式测试
// 高级模式 前瞻断言 后瞻断言 非贪婪匹配 复杂正则
// 关键词: 高级模式, 前瞻断言, 后瞻断言, 非贪婪匹配
// =============================================================================
println("\n10. 高级模式测试")

// 前瞻断言测试（如果支持）
text = "password123"
result = re2.Find(text, "\\w+(?=\\d+)")
if result != "" {
    assert result == "password", "Should match word before digits"
    println("前瞻断言支持: 正常")
} else {
    println("前瞻断言: 不支持或语法不同")
}

// 后瞻断言测试（如果支持）
text = "123password"
result = re2.Find(text, "(?<=\\d+)\\w+")
if result != "" {
    assert result == "password", "Should match word after digits"
    println("后瞻断言支持: 正常")
} else {
    println("后瞻断言: 不支持或语法不同")
}

// 非贪婪匹配测试
text = "<tag>content</tag><tag>more</tag>"
result = re2.Find(text, "<tag>.*?</tag>")
if result == "<tag>content</tag>" {
    println("非贪婪匹配: 正常")
} else {
    println("非贪婪匹配结果:", result)
}

println("高级模式测试: 完成")

// =============================================================================
// 11. Unicode和国际化测试
// Unicode 国际化 多语言 中文匹配 字符编码
// 关键词: Unicode, 国际化, 多语言, 中文匹配
// =============================================================================
println("\n11. Unicode和国际化测试")

// 中文字符测试
chinese_text = "中文测试 123 English"
chinese_chars = re2.FindAll(chinese_text, "[\\u4e00-\\u9fff]+")
assert len(chinese_chars) >= 1, "Should find Chinese characters"

// 日文字符测试
japanese_text = "こんにちは世界"
japanese_chars = re2.FindAll(japanese_text, "[\\u3040-\\u309f\\u30a0-\\u30ff]+")
if len(japanese_chars) > 0 {
    println("找到日文字符:", len(japanese_chars), "个")
}

// 表情符号测试
emoji_text = "Hello 😀 World 🌍"
emojis = re2.FindAll(emoji_text, "[\\U0001F600-\\U0001F64F\\U0001F300-\\U0001F5FF\\U0001F680-\\U0001F6FF\\U0001F1E0-\\U0001F1FF]")
if len(emojis) > 0 {
    println("找到表情符号:", len(emojis), "个")
}

println("Unicode和国际化测试: 完成")

// =============================================================================
// 12. 大数据性能测试
// 性能测试 大数据处理 基准测试 处理效率
// 关键词: 性能测试, 大数据处理, 基准测试, 处理效率
// =============================================================================
println("\n12. 大数据性能测试")

// 生成大文本
big_text = ""
for i in 200 {
    big_text += sprintf("Line %d: test content with number %d and email test%d@example.com\n", i, i * 10, i)
}

// 查找所有邮箱
start_time = time.Now()
emails = re2.FindAll(big_text, "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}")
end_time = time.Now()
duration = end_time.Sub(start_time)

assert len(emails) >= 200, "Should find many emails in big text"
println("找到", len(emails), "个邮箱, 耗时:", duration)

// 查找所有数字
numbers = re2.FindAll(big_text, "\\d+")
assert len(numbers) >= 400, "Should find many numbers in big text"

println("大数据性能测试: 通过")

// =============================================================================
// 13. 错误处理和边界测试
// 错误处理 边界测试 无效模式 异常处理
// 关键词: 错误处理, 边界测试, 无效模式, 异常处理
// =============================================================================
println("\n13. 错误处理和边界测试")

// 无效正则表达式测试
regex, err = re2.Compile("[invalid")~
if err != nil {
    println("无效正则错误处理正常:", err)
} else {
    println("无效正则被接受（可能在re2中有效）")
}

// 空字符串测试
result = re2.Find("", ".*")
assert result == "", "Should handle empty string"

result = re2.Find("test", "")
println("空模式结果:", result)

// 特殊字符测试
special_text = "Price: $123.45 (10% off) [limited time]"
price = re2.Find(special_text, "\\$\\d+\\.\\d+")
assert price == "$123.45", "Should find price with special characters"

percent = re2.Find(special_text, "\\d+%")
assert percent == "10%", "Should find percentage"

brackets = re2.Find(special_text, "\\[.*?\\]")
assert brackets == "[limited time]", "Should find bracketed text"

println("错误处理和边界测试: 通过")

// =============================================================================
// 14. 与re库的兼容性测试
// 兼容性测试 库对比 功能对比 差异分析
// 关键词: 兼容性测试, 库对比, 功能对比, 差异分析
// =============================================================================
println("\n14. 与re库的兼容性测试")

test_text = "yaklang version 1.2.3"
test_pattern = "yak([a-z]+)"

// 使用re库
re_result = re.Find(test_text, test_pattern)

// 使用re2库
re2_result = re2.Find(test_text, test_pattern)

println("re结果:", re_result, ", re2结果:", re2_result)

// 两个库的结果应该相似（但可能不完全相同）
assert re_result != "", "re should find match"
assert re2_result != "", "re2 should find match"

println("兼容性测试: 完成")

// =============================================================================
// 15. 稳定性测试
// 稳定性测试 重复操作 一致性测试 可靠性验证
// 关键词: 稳定性测试, 重复操作, 一致性测试, 可靠性验证
// =============================================================================
println("\n15. 稳定性测试")

// 重复操作测试
for i in 30 {
    pattern := sprintf("test%d", i)
    text := sprintf("This is test%d with value %d", i, i * 100)
    
    result := re2.Find(text, pattern)
    assert result == pattern, "Should find pattern consistently"
    
    numbers := re2.FindAll(text, "\\d+")
    assert len(numbers) >= 2, "Should find numbers consistently"
}

println("稳定性测试: 通过")

// =============================================================================
// 16. 安全相关模式测试
// 安全模式 恶意软件检测 威胁分析 安全正则
// 关键词: 安全模式, 恶意软件检测, 威胁分析, 安全正则
// =============================================================================
println("\n16. 安全相关模式测试")

// 恶意URL检测
malicious_urls = [
    "http://malicious.com/payload.exe",
    "https://phishing-site.net/login",
    "ftp://suspicious.org/backdoor"
]

url_pattern = "(?i)(http|https|ftp)://[a-zA-Z0-9.-]+/[^\\s]*\\.(exe|bat|cmd|scr|pif)"
detected_count = 0
for url in malicious_urls {
    if re2.Find(url, url_pattern) != "" {
        detected_count++
    }
}
println("检测到可疑URL:", detected_count, "个")

// 敏感文件路径检测
sensitive_paths = [
    "/etc/passwd",
    "C:\\Windows\\System32\\config\\SAM",
    "/var/log/auth.log"
]

sensitive_pattern = "(?i)(etc/passwd|system32/config|var/log/auth)"
detected_count = 0
for path in sensitive_paths {
    if re2.Find(path, sensitive_pattern) != "" {
        detected_count++
    }
}
println("检测到敏感路径:", detected_count, "个")

println("安全相关模式测试: 通过")

println("\n所有 re2 库功能测试完成!")
println("re2-practice.yak: 测试通过!")