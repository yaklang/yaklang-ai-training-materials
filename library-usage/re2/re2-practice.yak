// =============================================================================
// yaklang re2 åº“ä½¿ç”¨ç»ƒä¹ å’Œå®æˆ˜æ¡ˆä¾‹
// re2åº“é«˜çº§æ­£åˆ™ regexp2åº“ å¤æ‚æ¨¡å¼ é«˜çº§åŒ¹é… å›½é™…åŒ–æ”¯æŒ
// å…³é”®è¯: re2.Find, re2.FindAll, re2.Compile, regexp2, é«˜çº§æ­£åˆ™, å¤æ‚æ¨¡å¼
// =============================================================================

println("yaklang re2 åº“åŠŸèƒ½æµ‹è¯•å¼€å§‹...")

// =============================================================================
// 1. åŸºç¡€æŸ¥æ‰¾åŠŸèƒ½æµ‹è¯•
// åŸºç¡€æŸ¥æ‰¾ é«˜çº§æœç´¢ æ¨¡å¼åŒ¹é… å†…å®¹å®šä½
// å…³é”®è¯: Find, åŸºç¡€æŸ¥æ‰¾, é«˜çº§æœç´¢, æ¨¡å¼åŒ¹é…
// =============================================================================
println("\n1. åŸºç¡€æŸ¥æ‰¾åŠŸèƒ½æµ‹è¯•")

// ç®€å•æŸ¥æ‰¾æµ‹è¯•
text = "Hello World 123"
try {
    result = re2.Find(text, "\\d+")
    assert result == "123", "Should find digits"
    
    result = re2.Find(text, "World")
    assert result == "World", "Should find exact word"
    
    result = re2.Find(text, "notfound")
    if result == nil {
        result = ""
    }
    assert result == "", "Should return empty when not found"
} catch err {
    println("re2.Find æµ‹è¯•é”™è¯¯:", err)
}

// ä¸­æ–‡æ–‡æœ¬æŸ¥æ‰¾æµ‹è¯•
chinese_text = "ä½ å¥½ä¸–ç•Œ Hello World"
try {
    result = re2.Find(chinese_text, "[\\u4e00-\\u9fff]+")
    if result != nil && result != "" {
        println("æ‰¾åˆ°ä¸­æ–‡å­—ç¬¦:", result)
    } else {
        println("ä¸­æ–‡å­—ç¬¦åŒ¹é…: å¯èƒ½ä¸æ”¯æŒUnicodeèŒƒå›´")
    }
} catch err {
    println("ä¸­æ–‡å­—ç¬¦æŸ¥æ‰¾:", err)
}

println("åŸºç¡€æŸ¥æ‰¾åŠŸèƒ½æµ‹è¯•: é€šè¿‡")

// =============================================================================
// 2. æŸ¥æ‰¾æ‰€æœ‰åŒ¹é…é¡¹æµ‹è¯•
// å…¨å±€æœç´¢ æ‰¹é‡åŒ¹é… å¤šé‡æŸ¥æ‰¾ æ•°æ®æ”¶é›†
// å…³é”®è¯: FindAll, å…¨å±€æœç´¢, æ‰¹é‡åŒ¹é…, å¤šé‡æŸ¥æ‰¾
// =============================================================================
println("\n2. æŸ¥æ‰¾æ‰€æœ‰åŒ¹é…é¡¹æµ‹è¯•")

// æŸ¥æ‰¾æ‰€æœ‰åŒ¹é…
text = "yakit is GUI client for yaklang and yak"
results = re2.FindAll(text, "yak[a-z]*")
assert len(results) >= 3, "Should find multiple yak-related words"

// æŸ¥æ‰¾æ‰€æœ‰æ•°å­—
number_text = "Version 1.2.3, Build 456, Release 7.8.9"
numbers = re2.FindAll(number_text, "\\d+")
assert len(numbers) >= 6, "Should find multiple numbers"

// æŸ¥æ‰¾æ‰€æœ‰é‚®ç®±åœ°å€
email_text = "Contact admin@example.com or support@test.org"
emails = re2.FindAll(email_text, "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}")
assert len(emails) >= 2, "Should find multiple emails"

println("æŸ¥æ‰¾æ‰€æœ‰åŒ¹é…é¡¹æµ‹è¯•: é€šè¿‡")

// =============================================================================
// 3. å­åŒ¹é…åŠŸèƒ½æµ‹è¯•
// å­åŒ¹é… æ•è·ç»„ åˆ†ç»„åŒ¹é… é«˜çº§åˆ†ç»„
// å…³é”®è¯: FindSubmatch, å­åŒ¹é…, æ•è·ç»„, åˆ†ç»„åŒ¹é…
// =============================================================================
println("\n3. å­åŒ¹é…åŠŸèƒ½æµ‹è¯•")

// æ•è·ç»„æµ‹è¯•
text = "Version 1.2.3"
matches = re2.FindSubmatch(text, "(\\d+)\\.(\\d+)\\.(\\d+)")
assert len(matches) == 4, "Should have full match and 3 groups"
assert matches[0] == "1.2.3", "Full match should be version"
assert matches[1] == "1", "First group should be major"
assert matches[2] == "2", "Second group should be minor"
assert matches[3] == "3", "Third group should be patch"

// å‘½åæ•è·ç»„æµ‹è¯•
text = "User: admin, Role: administrator"
try {
    matches = re2.FindSubmatch(text, "User: (?P<user>\\w+), Role: (?P<role>\\w+)")
    assert len(matches) >= 3, "Should have matches with named groups"
    println("å‘½åæ•è·ç»„: æ”¯æŒ")
} catch err {
    println("å‘½åæ•è·ç»„:", err)
    // ä½¿ç”¨æ™®é€šæ•è·ç»„ä½œä¸ºæ›¿ä»£
    matches = re2.FindSubmatch(text, "User: (\\w+), Role: (\\w+)")
    assert len(matches) >= 3, "Should have matches with regular groups"
    println("ä½¿ç”¨æ™®é€šæ•è·ç»„æ›¿ä»£")
}

println("å­åŒ¹é…åŠŸèƒ½æµ‹è¯•: é€šè¿‡")

// =============================================================================
// 4. æ‰€æœ‰å­åŒ¹é…æµ‹è¯•
// æ‰¹é‡å­åŒ¹é… å¤šé‡æ•è· å…¨éƒ¨åˆ†ç»„ æ‰¹é‡å¤„ç†
// å…³é”®è¯: FindSubmatchAll, æ‰¹é‡å­åŒ¹é…, å¤šé‡æ•è·, å…¨éƒ¨åˆ†ç»„
// =============================================================================
println("\n4. æ‰€æœ‰å­åŒ¹é…æµ‹è¯•")

text = "User1: admin, Role1: admin; User2: guest, Role2: user"
all_matches = re2.FindSubmatchAll(text, "User\\d+: (\\w+), Role\\d+: (\\w+)")
assert len(all_matches) == 2, "Should find 2 user-role pairs"

for matches in all_matches {
    assert len(matches) == 3, "Each match should have full match and 2 groups"
    assert matches[1] != "", "Username should not be empty"
    assert matches[2] != "", "Role should not be empty"
}

println("æ‰€æœ‰å­åŒ¹é…æµ‹è¯•: é€šè¿‡")

// =============================================================================
// 5. æ›¿æ¢åŠŸèƒ½æµ‹è¯•
// é«˜çº§æ›¿æ¢ æ¨¡å¼æ›¿æ¢ å­—ç¬¦ä¸²æ›¿æ¢ å†…å®¹å˜æ¢
// å…³é”®è¯: ReplaceAll, é«˜çº§æ›¿æ¢, æ¨¡å¼æ›¿æ¢, å­—ç¬¦ä¸²æ›¿æ¢
// =============================================================================
println("\n5. æ›¿æ¢åŠŸèƒ½æµ‹è¯•")

// ç®€å•æ›¿æ¢
text = "yakit is a great tool"
result = re2.ReplaceAll(text, "yakit", "yaklang")
assert result.Contains("yaklang"), "Should replace yakit with yaklang"

// ä½¿ç”¨æ•è·ç»„æ›¿æ¢
text = "Date: 2023-12-25"
result = re2.ReplaceAll(text, "(\\d{4})-(\\d{2})-(\\d{2})", "$3/$2/$1")
assert result.Contains("25/12/2023"), "Should reformat date"

// å¤šä¸ªæ›¿æ¢
text = "Phone: 123-456-7890 and 987-654-3210"
result = re2.ReplaceAll(text, "\\d{3}-\\d{3}-\\d{4}", "XXX-XXX-XXXX")
assert result.Contains("XXX-XXX-XXXX"), "Should mask phone numbers"

println("æ›¿æ¢åŠŸèƒ½æµ‹è¯•: é€šè¿‡")

// =============================================================================
// 6. å‡½æ•°å¼æ›¿æ¢æµ‹è¯•
// å‡½æ•°æ›¿æ¢ å›è°ƒæ›¿æ¢ åŠ¨æ€æ›¿æ¢ è‡ªå®šä¹‰å¤„ç†
// å…³é”®è¯: ReplaceAllWithFunc, å‡½æ•°æ›¿æ¢, å›è°ƒæ›¿æ¢, åŠ¨æ€æ›¿æ¢
// =============================================================================
println("\n6. å‡½æ•°å¼æ›¿æ¢æµ‹è¯•")

// ä½¿ç”¨å‡½æ•°è¿›è¡Œæ›¿æ¢
text = "Convert: 10, 20, 30"
result = re2.ReplaceAllWithFunc(text, "\\d+", func(match) {
    return sprintf("(%s*2)", match)
})
assert result.Contains("(10*2)"), "Should modify first number"
assert result.Contains("(20*2)"), "Should modify second number"
assert result.Contains("(30*2)"), "Should modify third number"

// å¤§å°å†™è½¬æ¢
text = "hello world yaklang"
result = re2.ReplaceAllWithFunc(text, "\\b\\w+\\b", func(word) {
    return str.ToUpper(word)
})
assert result.Contains("HELLO"), "Should convert to uppercase"
assert result.Contains("WORLD"), "Should convert to uppercase"
assert result.Contains("YAKLANG"), "Should convert to uppercase"

println("å‡½æ•°å¼æ›¿æ¢æµ‹è¯•: é€šè¿‡")

// =============================================================================
// 7. å‘½åç»„åŠŸèƒ½æµ‹è¯•
// å‘½åç»„ é«˜çº§åˆ†ç»„ æ¨¡å¼åˆ†ç»„ å‘½åæ•è·
// å…³é”®è¯: FindGroup, å‘½åç»„, é«˜çº§åˆ†ç»„, æ¨¡å¼åˆ†ç»„
// =============================================================================
println("\n7. å‘½åç»„åŠŸèƒ½æµ‹è¯•")

// å‘½åæ•è·ç»„æµ‹è¯•
text = "Server: nginx/1.18.0, Port: 80"
try {
    groups = re2.FindGroup(text, "Server: (?P<server>\\w+)/(?P<version>[\\d.]+), Port: (?P<port>\\d+)")
    assert len(groups) >= 4, "Should have multiple groups"
    println("re2å‘½åæ•è·ç»„: æ”¯æŒ")
} catch err {
    println("re2å‘½åæ•è·ç»„:", err)
    // ä½¿ç”¨æ™®é€šæ•è·ç»„
    groups = re2.FindGroup(text, "Server: (\\w+)/([\\d.]+), Port: (\\d+)")
    assert len(groups) >= 4, "Should have multiple groups"
    assert groups["1"] == "nginx", "Should extract server name"
    assert groups["2"] == "1.18.0", "Should extract version"
    assert groups["3"] == "80", "Should extract port"
    println("ä½¿ç”¨æ™®é€šæ•è·ç»„æ›¿ä»£")
}

// æ•°å­—ç´¢å¼•ç»„
text = "IP: 192.168.1.100"
groups = re2.FindGroup(text, "IP: (\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)")
assert groups["1"] == "192", "First octet should be 192"
assert groups["2"] == "168", "Second octet should be 168"
assert groups["3"] == "1", "Third octet should be 1"
assert groups["4"] == "100", "Fourth octet should be 100"

println("å‘½åç»„åŠŸèƒ½æµ‹è¯•: é€šè¿‡")

// =============================================================================
// 8. æ‰€æœ‰å‘½åç»„æµ‹è¯•
// æ‰¹é‡å‘½åç»„ å¤šé‡å‘½åæ•è· å…¨éƒ¨å‘½åç»„ æ‰¹é‡åˆ†ç»„
// å…³é”®è¯: FindGroupAll, æ‰¹é‡å‘½åç»„, å¤šé‡å‘½åæ•è·, å…¨éƒ¨å‘½åç»„
// =============================================================================
println("\n8. æ‰€æœ‰å‘½åç»„æµ‹è¯•")

text = "Server1: apache/2.4.41, Server2: nginx/1.18.0"
try {
    all_groups = re2.FindGroupAll(text, "Server\\d+: (?P<name>\\w+)/(?P<version>[\\d.]+)")
    assert len(all_groups) == 2, "Should find 2 server entries"
    println("re2æ‰¹é‡å‘½åç»„: æ”¯æŒ")
} catch err {
    println("re2æ‰¹é‡å‘½åç»„:", err)
    // ä½¿ç”¨æ™®é€šæ•è·ç»„
    all_groups = re2.FindGroupAll(text, "Server\\d+: (\\w+)/([\\d.]+)")
    assert len(all_groups) == 2, "Should find 2 server entries"
    
    for groups in all_groups {
        assert groups["1"] != "", "Server name should not be empty"
        assert groups["2"] != "", "Version should not be empty"
    }
    println("ä½¿ç”¨æ™®é€šæ•è·ç»„æ›¿ä»£")
}

println("æ‰€æœ‰å‘½åç»„æµ‹è¯•: é€šè¿‡")

// =============================================================================
// 9. ç¼–è¯‘é€‰é¡¹æµ‹è¯•
// ç¼–è¯‘é€‰é¡¹ é«˜çº§ç¼–è¯‘ æ­£åˆ™é€‰é¡¹ æ¨¡å¼é…ç½®
// å…³é”®è¯: Compile, CompileWithOption, ç¼–è¯‘é€‰é¡¹, é«˜çº§ç¼–è¯‘
// =============================================================================
println("\n9. ç¼–è¯‘é€‰é¡¹æµ‹è¯•")

// åŸºç¡€ç¼–è¯‘æµ‹è¯•
regex, err = re2.Compile("hello")~
assert err == nil, "Should compile basic regex"

// å¿½ç•¥å¤§å°å†™é€‰é¡¹
regex, err = re2.CompileWithOption("HELLO", re2.OPT_IgnoreCase)~
assert err == nil, "Should compile with ignore case option"

// å¤šè¡Œæ¨¡å¼æµ‹è¯•
multiline_text = `Line 1
Line 2
Line 3`
regex, err = re2.CompileWithOption("^Line", re2.OPT_Multiline)~
assert err == nil, "Should compile with multiline option"

println("ç¼–è¯‘é€‰é¡¹æµ‹è¯•: é€šè¿‡")

// =============================================================================
// 10. é«˜çº§æ¨¡å¼æµ‹è¯•
// é«˜çº§æ¨¡å¼ å‰ç»æ–­è¨€ åç»æ–­è¨€ éè´ªå©ªåŒ¹é… å¤æ‚æ­£åˆ™
// å…³é”®è¯: é«˜çº§æ¨¡å¼, å‰ç»æ–­è¨€, åç»æ–­è¨€, éè´ªå©ªåŒ¹é…
// =============================================================================
println("\n10. é«˜çº§æ¨¡å¼æµ‹è¯•")

// å‰ç»æ–­è¨€æµ‹è¯•ï¼ˆå¦‚æœæ”¯æŒï¼‰
text = "password123"
result = re2.Find(text, "\\w+(?=\\d+)")
if result != "" {
    assert result == "password", "Should match word before digits"
    println("å‰ç»æ–­è¨€æ”¯æŒ: æ­£å¸¸")
} else {
    println("å‰ç»æ–­è¨€: ä¸æ”¯æŒæˆ–è¯­æ³•ä¸åŒ")
}

// åç»æ–­è¨€æµ‹è¯•ï¼ˆå¦‚æœæ”¯æŒï¼‰
text = "123password"
result = re2.Find(text, "(?<=\\d+)\\w+")
if result != "" {
    assert result == "password", "Should match word after digits"
    println("åç»æ–­è¨€æ”¯æŒ: æ­£å¸¸")
} else {
    println("åç»æ–­è¨€: ä¸æ”¯æŒæˆ–è¯­æ³•ä¸åŒ")
}

// éè´ªå©ªåŒ¹é…æµ‹è¯•
text = "<tag>content</tag><tag>more</tag>"
result = re2.Find(text, "<tag>.*?</tag>")
if result == "<tag>content</tag>" {
    println("éè´ªå©ªåŒ¹é…: æ­£å¸¸")
} else {
    println("éè´ªå©ªåŒ¹é…ç»“æœ:", result)
}

println("é«˜çº§æ¨¡å¼æµ‹è¯•: å®Œæˆ")

// =============================================================================
// 11. Unicodeå’Œå›½é™…åŒ–æµ‹è¯•
// Unicode å›½é™…åŒ– å¤šè¯­è¨€ ä¸­æ–‡åŒ¹é… å­—ç¬¦ç¼–ç 
// å…³é”®è¯: Unicode, å›½é™…åŒ–, å¤šè¯­è¨€, ä¸­æ–‡åŒ¹é…
// =============================================================================
println("\n11. Unicodeå’Œå›½é™…åŒ–æµ‹è¯•")

// ä¸­æ–‡å­—ç¬¦æµ‹è¯•
chinese_text = "ä¸­æ–‡æµ‹è¯• 123 English"
chinese_chars = re2.FindAll(chinese_text, "[\\u4e00-\\u9fff]+")
assert len(chinese_chars) >= 1, "Should find Chinese characters"

// æ—¥æ–‡å­—ç¬¦æµ‹è¯•
japanese_text = "ã“ã‚“ã«ã¡ã¯ä¸–ç•Œ"
japanese_chars = re2.FindAll(japanese_text, "[\\u3040-\\u309f\\u30a0-\\u30ff]+")
if len(japanese_chars) > 0 {
    println("æ‰¾åˆ°æ—¥æ–‡å­—ç¬¦:", len(japanese_chars), "ä¸ª")
}

// è¡¨æƒ…ç¬¦å·æµ‹è¯•
emoji_text = "Hello ğŸ˜€ World ğŸŒ"
emojis = re2.FindAll(emoji_text, "[\\U0001F600-\\U0001F64F\\U0001F300-\\U0001F5FF\\U0001F680-\\U0001F6FF\\U0001F1E0-\\U0001F1FF]")
if len(emojis) > 0 {
    println("æ‰¾åˆ°è¡¨æƒ…ç¬¦å·:", len(emojis), "ä¸ª")
}

println("Unicodeå’Œå›½é™…åŒ–æµ‹è¯•: å®Œæˆ")

// =============================================================================
// 12. å¤§æ•°æ®æ€§èƒ½æµ‹è¯•
// æ€§èƒ½æµ‹è¯• å¤§æ•°æ®å¤„ç† åŸºå‡†æµ‹è¯• å¤„ç†æ•ˆç‡
// å…³é”®è¯: æ€§èƒ½æµ‹è¯•, å¤§æ•°æ®å¤„ç†, åŸºå‡†æµ‹è¯•, å¤„ç†æ•ˆç‡
// =============================================================================
println("\n12. å¤§æ•°æ®æ€§èƒ½æµ‹è¯•")

// ç”Ÿæˆå¤§æ–‡æœ¬
big_text = ""
for i in 200 {
    big_text += sprintf("Line %d: test content with number %d and email test%d@example.com\n", i, i * 10, i)
}

// æŸ¥æ‰¾æ‰€æœ‰é‚®ç®±
start_time = time.Now()
emails = re2.FindAll(big_text, "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}")
end_time = time.Now()
duration = end_time.Sub(start_time)

assert len(emails) >= 200, "Should find many emails in big text"
println("æ‰¾åˆ°", len(emails), "ä¸ªé‚®ç®±, è€—æ—¶:", duration)

// æŸ¥æ‰¾æ‰€æœ‰æ•°å­—
numbers = re2.FindAll(big_text, "\\d+")
assert len(numbers) >= 400, "Should find many numbers in big text"

println("å¤§æ•°æ®æ€§èƒ½æµ‹è¯•: é€šè¿‡")

// =============================================================================
// 13. é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæµ‹è¯•
// é”™è¯¯å¤„ç† è¾¹ç•Œæµ‹è¯• æ— æ•ˆæ¨¡å¼ å¼‚å¸¸å¤„ç†
// å…³é”®è¯: é”™è¯¯å¤„ç†, è¾¹ç•Œæµ‹è¯•, æ— æ•ˆæ¨¡å¼, å¼‚å¸¸å¤„ç†
// =============================================================================
println("\n13. é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæµ‹è¯•")

// æ— æ•ˆæ­£åˆ™è¡¨è¾¾å¼æµ‹è¯•
regex, err = re2.Compile("[invalid")~
if err != nil {
    println("æ— æ•ˆæ­£åˆ™é”™è¯¯å¤„ç†æ­£å¸¸:", err)
} else {
    println("æ— æ•ˆæ­£åˆ™è¢«æ¥å—ï¼ˆå¯èƒ½åœ¨re2ä¸­æœ‰æ•ˆï¼‰")
}

// ç©ºå­—ç¬¦ä¸²æµ‹è¯•
result = re2.Find("", ".*")
assert result == "", "Should handle empty string"

result = re2.Find("test", "")
println("ç©ºæ¨¡å¼ç»“æœ:", result)

// ç‰¹æ®Šå­—ç¬¦æµ‹è¯•
special_text = "Price: $123.45 (10% off) [limited time]"
price = re2.Find(special_text, "\\$\\d+\\.\\d+")
assert price == "$123.45", "Should find price with special characters"

percent = re2.Find(special_text, "\\d+%")
assert percent == "10%", "Should find percentage"

brackets = re2.Find(special_text, "\\[.*?\\]")
assert brackets == "[limited time]", "Should find bracketed text"

println("é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæµ‹è¯•: é€šè¿‡")

// =============================================================================
// 14. ä¸reåº“çš„å…¼å®¹æ€§æµ‹è¯•
// å…¼å®¹æ€§æµ‹è¯• åº“å¯¹æ¯” åŠŸèƒ½å¯¹æ¯” å·®å¼‚åˆ†æ
// å…³é”®è¯: å…¼å®¹æ€§æµ‹è¯•, åº“å¯¹æ¯”, åŠŸèƒ½å¯¹æ¯”, å·®å¼‚åˆ†æ
// =============================================================================
println("\n14. ä¸reåº“çš„å…¼å®¹æ€§æµ‹è¯•")

test_text = "yaklang version 1.2.3"
test_pattern = "yak([a-z]+)"

// ä½¿ç”¨reåº“
re_result = re.Find(test_text, test_pattern)

// ä½¿ç”¨re2åº“
re2_result = re2.Find(test_text, test_pattern)

println("reç»“æœ:", re_result, ", re2ç»“æœ:", re2_result)

// ä¸¤ä¸ªåº“çš„ç»“æœåº”è¯¥ç›¸ä¼¼ï¼ˆä½†å¯èƒ½ä¸å®Œå…¨ç›¸åŒï¼‰
assert re_result != "", "re should find match"
assert re2_result != "", "re2 should find match"

println("å…¼å®¹æ€§æµ‹è¯•: å®Œæˆ")

// =============================================================================
// 15. ç¨³å®šæ€§æµ‹è¯•
// ç¨³å®šæ€§æµ‹è¯• é‡å¤æ“ä½œ ä¸€è‡´æ€§æµ‹è¯• å¯é æ€§éªŒè¯
// å…³é”®è¯: ç¨³å®šæ€§æµ‹è¯•, é‡å¤æ“ä½œ, ä¸€è‡´æ€§æµ‹è¯•, å¯é æ€§éªŒè¯
// =============================================================================
println("\n15. ç¨³å®šæ€§æµ‹è¯•")

// é‡å¤æ“ä½œæµ‹è¯•
for i in 30 {
    pattern := sprintf("test%d", i)
    text := sprintf("This is test%d with value %d", i, i * 100)
    
    result := re2.Find(text, pattern)
    assert result == pattern, "Should find pattern consistently"
    
    numbers := re2.FindAll(text, "\\d+")
    assert len(numbers) >= 2, "Should find numbers consistently"
}

println("ç¨³å®šæ€§æµ‹è¯•: é€šè¿‡")

// =============================================================================
// 16. å®‰å…¨ç›¸å…³æ¨¡å¼æµ‹è¯•
// å®‰å…¨æ¨¡å¼ æ¶æ„è½¯ä»¶æ£€æµ‹ å¨èƒåˆ†æ å®‰å…¨æ­£åˆ™
// å…³é”®è¯: å®‰å…¨æ¨¡å¼, æ¶æ„è½¯ä»¶æ£€æµ‹, å¨èƒåˆ†æ, å®‰å…¨æ­£åˆ™
// =============================================================================
println("\n16. å®‰å…¨ç›¸å…³æ¨¡å¼æµ‹è¯•")

// æ¶æ„URLæ£€æµ‹
malicious_urls = [
    "http://malicious.com/payload.exe",
    "https://phishing-site.net/login",
    "ftp://suspicious.org/backdoor"
]

url_pattern = "(?i)(http|https|ftp)://[a-zA-Z0-9.-]+/[^\\s]*\\.(exe|bat|cmd|scr|pif)"
detected_count = 0
for url in malicious_urls {
    if re2.Find(url, url_pattern) != "" {
        detected_count++
    }
}
println("æ£€æµ‹åˆ°å¯ç–‘URL:", detected_count, "ä¸ª")

// æ•æ„Ÿæ–‡ä»¶è·¯å¾„æ£€æµ‹
sensitive_paths = [
    "/etc/passwd",
    "C:\\Windows\\System32\\config\\SAM",
    "/var/log/auth.log"
]

sensitive_pattern = "(?i)(etc/passwd|system32/config|var/log/auth)"
detected_count = 0
for path in sensitive_paths {
    if re2.Find(path, sensitive_pattern) != "" {
        detected_count++
    }
}
println("æ£€æµ‹åˆ°æ•æ„Ÿè·¯å¾„:", detected_count, "ä¸ª")

println("å®‰å…¨ç›¸å…³æ¨¡å¼æµ‹è¯•: é€šè¿‡")

println("\næ‰€æœ‰ re2 åº“åŠŸèƒ½æµ‹è¯•å®Œæˆ!")
println("re2-practice.yak: æµ‹è¯•é€šè¿‡!")