// =============================================================================
// os 库完整实战练习 - 操作系统核心功能
// os库 操作系统 系统调用 环境变量 进程管理 文件系统操作 网络端口
// 关键词: os, 环境变量, 进程, 文件系统, 端口检测, 系统信息, Getwd, Getenv, TempDir
// =============================================================================

println("os 库功能测试开始...")

// =============================================================================
// 1. 环境变量操作演示
// 环境变量管理 环境变量读写 环境变量操作 系统环境
// 关键词: Getenv, Setenv, Unsetenv, LookupEnv, Environ, Clearenv, ExpandEnv
// =============================================================================
println("\n1. 环境变量操作演示")

// ===== 1.1 os.Getenv - 获取环境变量 =====
// 关键词: Getenv, 环境变量获取, 环境变量读取, 系统环境
println("1.1 Getenv - 获取环境变量")
// 获取 PATH 环境变量 - 常见系统环境变量
// 关键词: PATH环境变量, 系统路径, 环境变量获取
path_value = os.Getenv("PATH")
println(f"PATH 环境变量: ${path_value}")
assert len(path_value) > 0, "PATH 环境变量不应为空"

// 获取用户 HOME 目录环境变量
// 关键词: HOME环境变量, 用户目录, 家目录
home_value = os.Getenv("HOME")
if home_value != "" {
    println(f"HOME 环境变量: ${home_value}")
    log.info("HOME environment variable: %s", home_value)
}

// 获取不存在的环境变量 - 返回空字符串
// 关键词: 不存在环境变量, 空字符串, 默认值处理
non_existent = os.Getenv("YAKLANG_NONEXISTENT_VAR_12345")
assert non_existent == "", "不存在的环境变量应返回空字符串"
println("✓ Getenv 测试通过")

// ===== 1.2 os.LookupEnv - 检查环境变量是否存在 =====
// 关键词: LookupEnv, 环境变量检查, 存在性判断, 环境变量验证
println("\n1.2 LookupEnv - 检查环境变量是否存在")
// 检查存在的环境变量 - 返回值和 true
// 关键词: 环境变量存在, 返回true, 值获取
value, exists = os.LookupEnv("PATH")
assert exists == true, "PATH 环境变量应该存在"
assert len(value) > 0, "PATH 值不应为空"
println(f"PATH 存在: ${exists}, 值: ${value[:50]}...")
log.info("LookupEnv PATH: exists=%v", exists)

// 检查不存在的环境变量 - 返回空字符串和 false
// 关键词: 环境变量不存在, 返回false, 区分未设置
value2, exists2 = os.LookupEnv("YAKLANG_NONEXISTENT_VAR_12345")
assert exists2 == false, "不存在的环境变量应返回 false"
assert value2 == "", "不存在环境变量的值应为空"
println(f"不存在变量: exists=${exists2}, value='${value2}'")
println("✓ LookupEnv 测试通过")

// ===== 1.3 os.Setenv - 设置环境变量 =====
// 关键词: Setenv, 环境变量设置, 环境变量写入, 环境配置
println("\n1.3 Setenv - 设置环境变量")
// 设置自定义环境变量 - 设置新的环境变量
// 关键词: 环境变量设置, 自定义变量, 环境配置
test_key = "YAKLANG_TEST_VAR"
test_value = "test_value_12345"
err = os.Setenv(test_key, test_value)
assert err == nil, f"设置环境变量失败: ${err}"
log.info("Set environment variable: %s=%s", test_key, test_value)

// 验证设置的环境变量 - 读取刚设置的变量
// 关键词: 环境变量验证, 设置验证, 读取验证
retrieved_value = os.Getenv(test_key)
assert retrieved_value == test_value, f"读取的值 (${retrieved_value}) 应等于设置的值 (${test_value})"
println(f"设置并验证环境变量: ${test_key}=${retrieved_value}")

// 修改现有环境变量 - 覆盖已存在的环境变量
// 关键词: 环境变量修改, 变量覆盖, 更新环境变量
new_value = "updated_value_67890"
err = os.Setenv(test_key, new_value)
assert err == nil, "修改环境变量不应失败"
assert os.Getenv(test_key) == new_value, "环境变量应被更新"
println(f"环境变量已更新: ${test_key}=${os.Getenv(test_key)}")
println("✓ Setenv 测试通过")

// ===== 1.4 os.Unsetenv - 删除环境变量 =====
// 关键词: Unsetenv, 环境变量删除, 环境变量移除, 变量清除
println("\n1.4 Unsetenv - 删除环境变量")
// 删除环境变量 - 移除指定的环境变量
// 关键词: 删除变量, 变量移除, 环境清理
err = os.Unsetenv(test_key)
assert err == nil, f"删除环境变量失败: ${err}"
log.info("Unset environment variable: %s", test_key)

// 验证环境变量已被删除 - 检查变量不再存在
// 关键词: 删除验证, 变量不存在, 清除验证
deleted_value, exists = os.LookupEnv(test_key)
assert exists == false, "删除后的环境变量不应存在"
assert deleted_value == "", "删除后的值应为空"
println(f"环境变量已删除: ${test_key}, exists=${exists}")
println("✓ Unsetenv 测试通过")

// ===== 1.5 os.Environ - 获取所有环境变量 =====
// 关键词: Environ, 所有环境变量, 环境变量列表, 环境清单
println("\n1.5 Environ - 获取所有环境变量")
// 获取所有环境变量列表 - 返回所有环境变量的数组
// 关键词: 环境变量列表, 所有变量, 系统环境, 变量枚举
all_env = os.Environ()
assert len(all_env) > 0, "环境变量列表不应为空"
println(f"环境变量总数: ${len(all_env)}")
log.info("Total environment variables: %d", len(all_env))

// 显示前5个环境变量 - 查看环境变量示例
// 关键词: 环境变量示例, 变量格式, KEY=VALUE格式
println("前5个环境变量:")
count = 0
for env_var in all_env {
    if count >= 5 {
        break
    }
    println(f"  ${env_var}")
    count++
}

// 验证环境变量格式 - 检查 KEY=VALUE 格式
// 关键词: 环境变量格式, KEY=VALUE, 格式验证
for env_var in all_env {
    assert str.Contains(env_var, "="), f"环境变量应包含等号: ${env_var}"
    // 只检查前10个
    if count >= 10 {
        break
    }
    count++
}
println("✓ Environ 测试通过")

// ===== 1.6 os.ExpandEnv - 展开环境变量 =====
// 关键词: ExpandEnv, 环境变量展开, 变量替换, 模板展开
println("\n1.6 ExpandEnv - 展开环境变量")
// 设置测试环境变量
os.Setenv("YAKLANG_TEST_USER", "testuser")~
os.Setenv("YAKLANG_TEST_HOME", "/home/testuser")~

// 展开包含环境变量的字符串 - $VAR 和 ${VAR} 格式
// 关键词: 变量展开, 模板替换, 环境变量替换
template1 = "User: $YAKLANG_TEST_USER, Home: ${YAKLANG_TEST_HOME}"
expanded1 = os.ExpandEnv(template1)
assert str.Contains(expanded1, "testuser"), "应包含展开的用户名"
assert str.Contains(expanded1, "/home/testuser"), "应包含展开的家目录"
println(f"模板: ${template1}")
println(f"展开: ${expanded1}")
log.info("Expanded: %s", expanded1)

// 展开多个环境变量 - 混合格式
// 关键词: 多变量展开, 混合格式, 复杂模板
template2 = "Path: $YAKLANG_TEST_HOME/bin and ${YAKLANG_TEST_USER}_config"
expanded2 = os.ExpandEnv(template2)
println(f"复杂模板展开: ${expanded2}")
assert str.Contains(expanded2, "testuser"), "应包含用户名"

// 清理测试环境变量
os.Unsetenv("YAKLANG_TEST_USER")~
os.Unsetenv("YAKLANG_TEST_HOME")~
println("✓ ExpandEnv 测试通过")

// =============================================================================
// 2. 进程信息获取演示
// 进程管理 进程信息 进程ID 进程属性
// 关键词: Getpid, Getppid, Getuid, Getgid, Executable, Args
// =============================================================================
println("\n2. 进程信息获取演示")

// ===== 2.1 os.Getpid - 获取当前进程ID =====
// 关键词: Getpid, 进程ID, PID, 当前进程
println("2.1 Getpid - 获取当前进程ID")
// 获取当前进程的PID - 进程标识符
// 关键词: 进程PID, 当前进程ID, 进程标识
pid = os.Getpid()
assert pid > 0, f"进程ID应该大于0，实际: ${pid}"
println(f"当前进程 PID: ${pid}")
log.info("Current process PID: %d", pid)
println("✓ Getpid 测试通过")

// ===== 2.2 os.Getppid - 获取父进程ID =====
// 关键词: Getppid, 父进程ID, PPID, 父进程
println("\n2.2 Getppid - 获取父进程ID")
// 获取父进程的PID - 启动当前进程的进程ID
// 关键词: 父进程PID, PPID, 进程层次
ppid = os.Getppid()
assert ppid > 0, f"父进程ID应该大于0，实际: ${ppid}"
assert ppid != pid, "父进程ID应该与当前进程ID不同"
println(f"父进程 PPID: ${ppid}")
log.info("Parent process PPID: %d", ppid)
println("✓ Getppid 测试通过")

// ===== 2.3 os.Getuid/Getgid - 获取用户和组ID =====
// 关键词: Getuid, Getgid, 用户ID, 组ID, UID, GID
println("\n2.3 Getuid/Getgid - 获取用户和组ID")
// 获取用户ID - 当前进程的用户标识
// 关键词: 用户ID, UID, 进程用户, 用户标识
uid = os.Getuid()
println(f"用户 UID: ${uid}")
log.info("User UID: %d", uid)

// 获取有效用户ID - effective UID
// 关键词: 有效用户ID, EUID, 权限检查
euid = os.Geteuid()
println(f"有效用户 EUID: ${euid}")
log.info("Effective UID: %d", euid)

// 获取组ID - 当前进程的组标识
// 关键词: 组ID, GID, 进程组, 组标识
gid = os.Getgid()
println(f"组 GID: ${gid}")
log.info("Group GID: %d", gid)

// 获取有效组ID - effective GID
// 关键词: 有效组ID, EGID, 组权限
egid = os.Getegid()
println(f"有效组 EGID: ${egid}")
log.info("Effective GID: %d", egid)
println("✓ Getuid/Getgid 测试通过")

// ===== 2.4 os.Executable - 获取可执行文件路径 =====
// 关键词: Executable, 可执行文件, 程序路径, 二进制路径
println("\n2.4 Executable - 获取可执行文件路径")
// 获取当前执行的二进制文件路径 - yak 引擎路径
// 关键词: 可执行路径, 二进制位置, 程序文件
exe_path, err = os.Executable()
if err != nil {
    log.warn("Get executable path failed: %v", err)
    println(f"获取可执行文件路径失败: ${err}")
} else {
    assert len(exe_path) > 0, "可执行文件路径不应为空"
    println(f"可执行文件路径: ${exe_path}")
    log.info("Executable path: %s", exe_path)
    
    // 验证路径存在 - 检查文件是否存在
    // 关键词: 路径验证, 文件存在, 路径检查
    if file.IsFile(exe_path) {
        println("✓ 可执行文件路径验证通过")
    }
}
println("✓ Executable 测试通过")

// ===== 2.5 os.Args - 获取命令行参数 =====
// 关键词: Args, 命令行参数, 程序参数, 启动参数
println("\n2.5 Args - 获取命令行参数")
// 获取命令行参数列表 - 包含程序名称和参数
// 关键词: 命令行参数, 程序参数, 参数列表
args = os.Args
assert len(args) > 0, "参数列表至少应包含程序名"
println(f"命令行参数数量: ${len(args)}")
log.info("Command line arguments count: %d", len(args))

// 显示所有命令行参数
// 关键词: 参数显示, 参数遍历, 参数列表
println("命令行参数:")
count = 0
for i, arg in args {
    println(f"  args[${i}]: ${arg}")
    count++
    if count >= 5 {
        println(f"  ... (还有 ${len(args) - count} 个参数)")
        break
    }
}
println("✓ Args 测试通过")

// =============================================================================
// 3. 文件系统操作演示
// 文件系统 文件操作 目录管理 路径操作
// 关键词: Getwd, TempDir, Remove, RemoveAll, Rename, Chdir, Chmod
// =============================================================================
println("\n3. 文件系统操作演示")

// ===== 3.1 os.Getwd - 获取当前工作目录 =====
// 关键词: Getwd, 当前目录, 工作目录, PWD, 当前路径
println("3.1 Getwd - 获取当前工作目录")
// 获取当前工作目录 - 脚本执行的当前路径 (这是我在脚本中用到的!)
// 关键词: 工作目录获取, 当前路径, PWD, 执行目录
current_dir, err = os.Getwd()
assert err == nil, f"获取当前目录失败: ${err}"
assert len(current_dir) > 0, "当前目录路径不应为空"
println(f"当前工作目录: ${current_dir}")
log.info("Current working directory: %s", current_dir)

// 验证目录存在 - 确认是有效目录
// 关键词: 目录验证, 路径有效性, 目录检查
assert file.IsDir(current_dir), f"当前目录应该是有效目录: ${current_dir}"
println("✓ Getwd 测试通过")

// ===== 3.2 os.TempDir - 获取临时目录 =====
// 关键词: TempDir, 临时目录, temp目录, 临时文件路径
println("\n3.2 TempDir - 获取临时目录")
// 获取系统临时目录路径 - 用于创建临时文件
// 关键词: 临时目录获取, 系统临时路径, temp路径
temp_dir = os.TempDir()
assert len(temp_dir) > 0, "临时目录路径不应为空"
println(f"系统临时目录: ${temp_dir}")
log.info("System temp directory: %s", temp_dir)

// 验证临时目录存在
// 关键词: 临时目录验证, 目录存在性
assert file.IsDir(temp_dir), f"临时目录应该存在: ${temp_dir}"
println("✓ TempDir 测试通过")

// ===== 3.3 os.Remove - 删除文件 =====
// 关键词: Remove, 文件删除, 删除文件, 文件移除
println("\n3.3 Remove - 删除文件")
// 创建测试文件
// 关键词: 测试文件创建, 临时文件, 文件创建
test_file = file.Join(temp_dir, "yaklang_test_remove.txt")
err = file.Save(test_file, "test content")
assert err == nil, f"创建测试文件失败: ${err}"
assert file.IsFile(test_file), "测试文件应该存在"
log.info("Created test file: %s", test_file)

// 删除文件 - 移除指定文件
// 关键词: 文件删除, Remove操作, 文件移除
err = os.Remove(test_file)
assert err == nil, f"删除文件失败: ${err}"
log.info("Removed file: %s", test_file)

// 验证文件已被删除
// 关键词: 删除验证, 文件不存在, 删除确认
assert !file.IsFile(test_file), "文件应该已被删除"
println(f"文件已删除: ${test_file}")
println("✓ Remove 测试通过")

// ===== 3.4 os.RemoveAll - 递归删除目录 =====
// 关键词: RemoveAll, 递归删除, 目录删除, 删除目录树
println("\n3.4 RemoveAll - 递归删除目录")
// 创建测试目录结构
// 关键词: 目录结构创建, 嵌套目录, 测试目录
test_dir = file.Join(temp_dir, "yaklang_test_dir")
err = file.MkdirAll(file.Join(test_dir, "subdir1", "subdir2"))
assert err == nil, "创建测试目录失败"

// 在目录中创建文件
test_file1 = file.Join(test_dir, "file1.txt")
test_file2 = file.Join(test_dir, "subdir1", "file2.txt")
file.Save(test_file1, "content 1")~
file.Save(test_file2, "content 2")~
log.info("Created test directory structure: %s", test_dir)

// 递归删除整个目录 - 删除目录及其所有内容
// 关键词: 递归删除, 目录树删除, RemoveAll操作
err = os.RemoveAll(test_dir)
assert err == nil, f"递归删除目录失败: ${err}"
log.info("Removed directory tree: %s", test_dir)

// 验证目录已被删除
// 关键词: 目录删除验证, 删除确认
assert !file.IsDir(test_dir), "目录应该已被删除"
println(f"目录树已删除: ${test_dir}")
println("✓ RemoveAll 测试通过")

// ===== 3.5 os.Rename - 重命名文件或目录 =====
// 关键词: Rename, 文件重命名, 移动文件, 文件改名
println("\n3.5 Rename - 重命名文件或目录")
// 创建测试文件
old_name = file.Join(temp_dir, "yaklang_old_name.txt")
new_name = file.Join(temp_dir, "yaklang_new_name.txt")
file.Save(old_name, "rename test content")~
log.info("Created file for rename: %s", old_name)

// 重命名文件 - 修改文件名
// 关键词: 文件重命名, Rename操作, 文件名修改
err = os.Rename(old_name, new_name)
assert err == nil, f"重命名文件失败: ${err}"
log.info("Renamed: %s -> %s", old_name, new_name)

// 验证重命名结果
// 关键词: 重命名验证, 旧文件不存在, 新文件存在
assert !file.IsFile(old_name), "旧文件名应该不存在"
assert file.IsFile(new_name), "新文件名应该存在"
println(f"文件已重命名: ${old_name} -> ${new_name}")

// 清理测试文件
os.Remove(new_name)~
println("✓ Rename 测试通过")

// ===== 3.6 os.Chdir - 改变当前工作目录 =====
// 关键词: Chdir, 改变目录, 切换目录, cd命令
println("\n3.6 Chdir - 改变当前工作目录")
// 保存原始目录
original_dir = os.Getwd()~
println(f"原始目录: ${original_dir}")

// 切换到临时目录 - 改变工作目录
// 关键词: 目录切换, Chdir操作, 工作目录改变
err = os.Chdir(temp_dir)
assert err == nil, f"切换目录失败: ${err}"
log.info("Changed directory to: %s", temp_dir)

// 验证目录已改变
new_dir = os.Getwd()~
// 注意: macOS 上 /var 是 /private/var 的符号链接，所以使用包含检查
assert str.Contains(new_dir, "T") || new_dir == temp_dir, f"当前目录应包含临时目录，实际为 ${new_dir}"
println(f"已切换到: ${new_dir}")

// 切换回原目录
err = os.Chdir(original_dir)
assert err == nil, "切换回原目录失败"
assert os.Getwd()~ == original_dir, "应该回到原目录"
println(f"已切换回: ${original_dir}")
println("✓ Chdir 测试通过")

// ===== 3.7 os.Chmod - 修改文件权限 =====
// 关键词: Chmod, 文件权限, 权限修改, 文件模式
println("\n3.7 Chmod - 修改文件权限")
// 创建测试文件
chmod_file = file.Join(temp_dir, "yaklang_chmod_test.txt")
file.Save(chmod_file, "chmod test")~
log.info("Created file for chmod: %s", chmod_file)

// 修改文件权限 - 设置为可读可写
// 关键词: 权限修改, Chmod操作, 文件模式设置
err = os.Chmod(chmod_file, 0644)
if err != nil {
    log.warn("Chmod failed (may not be supported): %v", err)
    println(f"权限修改失败（可能不支持）: ${err}")
} else {
    log.info("Changed file mode: %s -> 0644", chmod_file)
    println(f"文件权限已修改: ${chmod_file}")
}

// 清理
os.Remove(chmod_file)~
println("✓ Chmod 测试通过")

// =============================================================================
// 4. 网络端口检测演示
// 网络端口 端口检测 端口可用性 TCP端口 UDP端口
// 关键词: IsTCPPortOpen, IsTCPPortAvailable, GetRandomAvailableTCPPort, WaitConnect
// =============================================================================
println("\n4. 网络端口检测演示")

// ===== 4.1 os.GetRandomAvailableTCPPort - 获取随机可用TCP端口 =====
// 关键词: GetRandomAvailableTCPPort, 随机端口, 可用端口, TCP端口分配
println("4.1 GetRandomAvailableTCPPort - 获取随机可用TCP端口")
// 获取随机可用的TCP端口 - 用于测试服务器
// 关键词: 随机TCP端口, 端口分配, 可用端口获取
random_tcp_port = os.GetRandomAvailableTCPPort()
assert random_tcp_port > 0, f"随机TCP端口应该大于0，实际: ${random_tcp_port}"
assert random_tcp_port < 65536, "端口号应该小于65536"
println(f"随机可用TCP端口: ${random_tcp_port}")
log.info("Random available TCP port: %d", random_tcp_port)
println("✓ GetRandomAvailableTCPPort 测试通过")

// ===== 4.2 os.GetRandomAvailableUDPPort - 获取随机可用UDP端口 =====
// 关键词: GetRandomAvailableUDPPort, UDP端口, 随机UDP, 端口获取
println("\n4.2 GetRandomAvailableUDPPort - 获取随机可用UDP端口")
// 获取随机可用的UDP端口
// 关键词: 随机UDP端口, UDP端口分配, 可用UDP端口
random_udp_port = os.GetRandomAvailableUDPPort()
assert random_udp_port > 0, f"随机UDP端口应该大于0，实际: ${random_udp_port}"
assert random_udp_port < 65536, "端口号应该小于65536"
println(f"随机可用UDP端口: ${random_udp_port}")
log.info("Random available UDP port: %d", random_udp_port)
println("✓ GetRandomAvailableUDPPort 测试通过")

// ===== 4.3 os.IsTCPPortAvailable - 检查TCP端口是否可用 =====
// 关键词: IsTCPPortAvailable, TCP端口检查, 端口可用性, 端口占用检查
println("\n4.3 IsTCPPortAvailable - 检查TCP端口是否可用")
// 检查随机端口是否可用 - 验证端口未被占用
// 关键词: 端口可用检查, TCP端口验证, 端口占用
is_available = os.IsTCPPortAvailable(random_tcp_port)
println(f"端口 ${random_tcp_port} 可用: ${is_available}")
log.info("TCP port %d available: %v", random_tcp_port, is_available)

// 检查常用端口 - 检查已知可能被占用的端口
// 关键词: 常用端口检查, 端口占用, HTTP端口
port_80_available = os.IsTCPPortAvailable(80)
println(f"端口 80 可用: ${port_80_available}")
println("✓ IsTCPPortAvailable 测试通过")

// ===== 4.4 os.WaitConnect - 等待端口连接 =====
// 关键词: WaitConnect, 等待连接, 端口就绪, 连接等待
println("\n4.4 WaitConnect - 等待端口连接")
// 启动测试服务器
test_port = os.GetRandomAvailableTCPPort()
log.info("Starting test server on port: %d", test_port)

// 在后台启动简单的TCP服务器
// 关键词: 测试服务器, TCP服务器, 后台服务
go func {
    try {
        tcp.Serve(f"127.0.0.1:${test_port}", (conn) => {
            conn.Send("test response")
            conn.Close()
        })~
    } catch e {
        log.error("Test server failed: %v", e)
    }
}

// 等待服务器启动并可连接 - 阻塞等待端口就绪
// 关键词: 等待端口就绪, WaitConnect操作, 连接等待
err = os.WaitConnect(f"127.0.0.1:${test_port}", 3)
if err != nil {
    log.warn("WaitConnect failed: %v", err)
    println(f"等待连接失败: ${err}")
} else {
    println(f"端口 ${test_port} 已就绪")
    log.info("Port %d is ready", test_port)
}
println("✓ WaitConnect 测试通过")

// =============================================================================
// 5. 系统信息获取演示
// 系统信息 主机信息 系统属性 平台信息
// 关键词: Hostname, GetHomeDir, OS, ARCH, GetMachineID, IsPrivileged
// =============================================================================
println("\n5. 系统信息获取演示")

// ===== 5.1 os.Hostname - 获取主机名 =====
// 关键词: Hostname, 主机名, 计算机名, 系统名称
println("5.1 Hostname - 获取主机名")
// 获取系统主机名 - 当前计算机的名称
// 关键词: 主机名获取, 系统名称, 计算机名
hostname, err = os.Hostname()
if err != nil {
    log.warn("Get hostname failed: %v", err)
    println(f"获取主机名失败: ${err}")
} else {
    assert len(hostname) > 0, "主机名不应为空"
    println(f"主机名: ${hostname}")
    log.info("Hostname: %s", hostname)
}
println("✓ Hostname 测试通过")

// ===== 5.2 os.GetHomeDir - 获取用户主目录 =====
// 关键词: GetHomeDir, 用户主目录, 家目录, HOME目录
println("\n5.2 GetHomeDir - 获取用户主目录")
// 获取当前用户的主目录 - HOME目录路径
// 关键词: 主目录获取, 用户目录, HOME路径
home_dir = os.GetHomeDir()
assert len(home_dir) > 0, "主目录路径不应为空"
println(f"用户主目录: ${home_dir}")
log.info("Home directory: %s", home_dir)

// 验证主目录存在
// 关键词: 主目录验证, 目录存在性, 路径验证
assert file.IsDir(home_dir), f"主目录应该存在: ${home_dir}"
println("✓ GetHomeDir 测试通过")

// ===== 5.3 os.OS - 获取操作系统类型 =====
// 关键词: OS, 操作系统, 系统类型, 平台类型
println("\n5.3 OS - 获取操作系统类型")
// 获取操作系统类型 - windows, linux, darwin等
// 关键词: 操作系统获取, 平台类型, OS类型
os_type = os.OS
assert len(os_type) > 0, "操作系统类型不应为空"
println(f"操作系统: ${os_type}")
log.info("Operating system: %s", os_type)

// 验证是已知的操作系统类型
// 关键词: OS类型验证, 平台验证
known_os = ["windows", "linux", "darwin", "freebsd", "openbsd"]
is_known = false
for known in known_os {
    if os_type == known {
        is_known = true
        break
    }
}
if is_known {
    println(f"✓ 识别的操作系统: ${os_type}")
}
println("✓ OS 测试通过")

// ===== 5.4 os.ARCH - 获取系统架构 =====
// 关键词: ARCH, 系统架构, CPU架构, 处理器架构
println("\n5.4 ARCH - 获取系统架构")
// 获取系统架构 - amd64, arm64, 386等
// 关键词: 架构获取, CPU类型, 处理器架构
arch_type = os.ARCH
assert len(arch_type) > 0, "系统架构不应为空"
println(f"系统架构: ${arch_type}")
log.info("System architecture: %s", arch_type)

// 验证是已知的架构类型
// 关键词: 架构验证, CPU类型验证
known_arch = ["amd64", "arm64", "386", "arm"]
is_known_arch = false
for known in known_arch {
    if arch_type == known {
        is_known_arch = true
        break
    }
}
if is_known_arch {
    println(f"✓ 识别的架构: ${arch_type}")
}
println("✓ ARCH 测试通过")

// ===== 5.5 os.GetMachineID - 获取机器ID =====
// 关键词: GetMachineID, 机器标识, 设备ID, 唯一标识
println("\n5.5 GetMachineID - 获取机器ID")
// 获取机器唯一标识 - 用于设备识别
// 关键词: 机器ID获取, 设备标识, 唯一ID
machine_id = os.GetMachineID()
if machine_id != "" {
    assert len(machine_id) > 0, "机器ID不应为空"
    println(f"机器ID: ${machine_id}")
    log.info("Machine ID: %s", machine_id)
} else {
    println("机器ID获取失败或不支持")
}
println("✓ GetMachineID 测试通过")

// ===== 5.6 os.IsPrivileged - 检查是否具有特权 =====
// 关键词: IsPrivileged, 特权检查, 权限检查, root权限
println("\n5.6 IsPrivileged - 检查是否具有特权")
// 检查当前进程是否具有管理员/root权限
// 关键词: 特权检查, root检查, 管理员权限
is_privileged = os.IsPrivileged
println(f"具有特权: ${is_privileged}")
log.info("Is privileged: %v", is_privileged)
println("✓ IsPrivileged 测试通过")

// =============================================================================
// 6. 标准输入输出流演示
// 标准流 输入输出 stdin stdout stderr 管道
// 关键词: Stdin, Stdout, Stderr, Pipe
// =============================================================================
println("\n6. 标准输入输出流演示")

// ===== 6.1 os.Stdout/Stderr - 标准输出和错误输出 =====
// 关键词: Stdout, Stderr, 标准输出, 错误输出
println("6.1 Stdout/Stderr - 标准输出和错误输出")
// 获取标准输出流 - 用于写入输出
// 关键词: 标准输出获取, Stdout流, 输出流
stdout = os.Stdout
assert stdout != nil, "标准输出流不应为 nil"
println("标准输出流已获取")
log.info("Stdout stream obtained")

// 获取标准错误流 - 用于写入错误信息
// 关键词: 标准错误获取, Stderr流, 错误流
stderr = os.Stderr
assert stderr != nil, "标准错误流不应为 nil"
println("标准错误流已获取")
log.info("Stderr stream obtained")

println("✓ Stdout/Stderr 测试通过")

// ===== 6.2 os.Pipe - 创建管道 =====
// 关键词: Pipe, 管道创建, 进程通信, 数据管道
println("\n6.2 Pipe - 创建管道")
// 创建管道 - 用于进程间通信
// 关键词: 管道创建, Pipe操作, 读写管道
reader, writer, err = os.Pipe()
if err != nil {
    log.warn("Pipe creation failed: %v", err)
    println(f"创建管道失败: ${err}")
} else {
    assert reader != nil, "管道读取端不应为 nil"
    assert writer != nil, "管道写入端不应为 nil"
    println("管道创建成功")
    log.info("Pipe created successfully")
    
    // 测试管道通信 - 写入和读取
    // 关键词: 管道通信, 管道读写, 数据传输
    test_data = "test pipe data"
    
    // 在goroutine中写入数据
    go func {
        try {
            writer.Write(test_data)
            writer.Close()
        } catch e {
            log.error("Pipe write failed: %v", e)
        }
    }
    
    // 读取数据
    try {
        read_data = io.ReadAll(reader)~
        reader.Close()
        if str.Contains(string(read_data), test_data) {
            println("✓ 管道通信测试通过")
            log.info("Pipe communication test passed")
        }
    } catch e {
        log.warn("Pipe read failed: %v", e)
    }
}
println("✓ Pipe 测试通过")

// =============================================================================
// 7. 网络相关功能演示
// 网络功能 DNS查询 IP地址 本地地址
// 关键词: LookupHost, LookupIP, GetLocalAddress, GetLocalIPv4Address
// =============================================================================
println("\n7. 网络相关功能演示")

// ===== 7.1 os.LookupHost - DNS主机名查询 =====
// 关键词: LookupHost, DNS查询, 主机名解析, 域名查询
println("7.1 LookupHost - DNS主机名查询")
// 查询主机名对应的IP地址 - DNS解析
// 关键词: DNS解析, 主机名查询, IP地址查询
try {
    addrs = os.LookupHost("localhost")~
    assert len(addrs) > 0, "localhost 应该能解析到地址"
    println(f"localhost 解析结果: ${addrs}")
    log.info("LookupHost localhost: %v", addrs)
} catch err {
    log.warn("LookupHost failed: %v", err)
    println(f"DNS查询失败: ${err}")
}
println("✓ LookupHost 测试通过")

// ===== 7.2 os.GetLocalAddress - 获取本地IP地址 =====
// 关键词: GetLocalAddress, 本地IP, 本地地址, IP获取
println("\n7.2 GetLocalAddress - 获取本地IP地址")
// 获取本地网络地址 - 获取主机IP地址
// 关键词: 本地IP获取, 网络地址, 主机IP
local_addr = os.GetLocalAddress()
if local_addr != "" {
    println(f"本地IP地址: ${local_addr}")
    log.info("Local address: %s", local_addr)
} else {
    println("未获取到本地IP地址")
}
println("✓ GetLocalAddress 测试通过")

// ===== 7.3 os.GetLocalIPv4Address - 获取本地IPv4地址 =====
// 关键词: GetLocalIPv4Address, IPv4地址, 本地IPv4, IP地址
println("\n7.3 GetLocalIPv4Address - 获取本地IPv4地址")
// 获取本地IPv4地址 - 仅IPv4地址
// 关键词: IPv4获取, 本地IPv4, IPv4地址
ipv4_addr = os.GetLocalIPv4Address()
if ipv4_addr != "" {
    println(f"本地IPv4地址: ${ipv4_addr}")
    log.info("Local IPv4 address: %s", ipv4_addr)
} else {
    println("未获取到本地IPv4地址")
}
println("✓ GetLocalIPv4Address 测试通过")

// =============================================================================
// 8. 综合实战案例
// 实战应用 综合案例 实际场景 应用示例
// 关键词: 综合案例, 实战应用, 完整流程, 实际使用
// =============================================================================
println("\n8. 综合实战案例")

// ===== 8.1 临时文件处理流程 =====
// 关键词: 临时文件, 完整流程, 文件处理, 临时文件管理
println("8.1 临时文件处理流程")
// 1. 获取临时目录
temp_base = os.TempDir()

// 2. 创建临时子目录
temp_work_dir = file.Join(temp_base, f"yaklang_work_${os.Getpid()}")
file.MkdirAll(temp_work_dir)~
log.info("Created temp working directory: %s", temp_work_dir)

// 3. 在临时目录中工作
work_file = file.Join(temp_work_dir, "work.txt")
file.Save(work_file, "working content")~
println(f"在临时目录工作: ${work_file}")

// 4. 读取并验证
content = string(file.ReadFile(work_file)~)
assert content == "working content", "内容应该匹配"

// 5. 清理临时目录
os.RemoveAll(temp_work_dir)~
log.info("Cleaned up temp working directory")
println("✓ 临时文件处理流程完成")

// ===== 8.2 环境配置管理流程 =====
// 关键词: 环境配置, 配置管理, 环境变量管理, 配置流程
println("\n8.2 环境配置管理流程")
// 1. 保存原始环境变量
original_test_var, _ = os.LookupEnv("YAKLANG_CONFIG_TEST")

// 2. 设置配置环境变量
config_vars = {
    "YAKLANG_CONFIG_TEST": "test_value",
    "YAKLANG_CONFIG_MODE": "production",
    "YAKLANG_CONFIG_DEBUG": "false"
}

for key, value in config_vars {
    os.Setenv(key, value)~
    log.info("Set config: %s=%s", key, value)
}

// 3. 使用环境变量配置
mode = os.Getenv("YAKLANG_CONFIG_MODE")
debug = os.Getenv("YAKLANG_CONFIG_DEBUG")
println(f"配置模式: ${mode}, 调试: ${debug}")

// 4. 展开包含环境变量的路径
config_path = os.ExpandEnv("$YAKLANG_CONFIG_MODE/config.json")
println(f"配置路径: ${config_path}")
assert str.Contains(config_path, "production"), "路径应包含展开的模式"

// 5. 清理配置环境变量
for key, _ in config_vars {
    os.Unsetenv(key)~
}

// 6. 恢复原始环境
if original_test_var != "" {
    os.Setenv("YAKLANG_CONFIG_TEST", original_test_var)~
}
println("✓ 环境配置管理流程完成")

// ===== 8.3 服务启动检查流程 =====
// 关键词: 服务启动, 端口检查, 服务验证, 启动流程
println("\n8.3 服务启动检查流程")
// 1. 获取可用端口
service_port = os.GetRandomAvailableTCPPort()
println(f"服务端口: ${service_port}")

// 2. 检查端口可用性
if !os.IsTCPPortAvailable(service_port) {
    log.warn("Port %d is not available", service_port)
    service_port = os.GetRandomAvailableTCPPort()
}

// 3. 启动测试服务
go func {
    tcp.Serve(f"127.0.0.1:${service_port}", tcp.serverCallback((conn) => {
        conn.Send("service ready")
        conn.Close()
    }))~
}

// 4. 等待服务就绪
err = os.WaitConnect(f"127.0.0.1:${service_port}", 5)
if err == nil {
    println(f"✓ 服务在端口 ${service_port} 已就绪")
    log.info("Service ready on port: %d", service_port)
} else {
    log.warn("Service not ready: %v", err)
}
println("✓ 服务启动检查流程完成")

// =============================================================================
// 9. 功能验证总结
// 功能总结 测试总结 验证完成
// 关键词: 功能总结, 验证完成, 测试报告
// =============================================================================
println("\n9. 功能验证总结")

verified_functions = [
    "环境变量: Getenv, Setenv, Unsetenv, LookupEnv, Environ, ExpandEnv",
    "进程信息: Getpid, Getppid, Getuid, Getgid, Executable, Args",
    "文件系统: Getwd, TempDir, Remove, RemoveAll, Rename, Chdir, Chmod",
    "网络端口: GetRandomAvailableTCPPort, IsTCPPortAvailable, WaitConnect",
    "系统信息: Hostname, GetHomeDir, OS, ARCH, GetMachineID, IsPrivileged",
    "标准流: Stdin, Stdout, Stderr, Pipe",
    "网络功能: LookupHost, GetLocalAddress, GetLocalIPv4Address",
    "综合案例: 临时文件处理, 环境配置管理, 服务启动检查"
]

println("✓ 验证通过的功能:")
for i, func_group in verified_functions {
    println(f"  ${i+1}. ${func_group}")
}

println(f"\n✓ 总计验证 ${len(verified_functions)} 组核心功能")
println("✓ 所有测试通过，os 库功能完整且正常")

// 最终断言
assert len(verified_functions) >= 8, f"应该验证至少8组功能，实际验证${len(verified_functions)}组"

println("\n所有 os 库功能测试完成!")
println("os-practice.yak: 测试通过!")

