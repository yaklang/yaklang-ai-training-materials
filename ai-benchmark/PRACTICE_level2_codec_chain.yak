// Medium: 多层编解码处理
// 对数据进行多层编码，然后按相反顺序解码

// 原始数据
original = "admin' OR '1'='1' -- "
println("=== Encoding Process ===")
println("Original:", original)

// ========================================
// 编码过程
// ========================================

// 第一层：Base64 编码
step1 = codec.EncodeBase64(original)
println("After Base64:", step1)

// 第二层：URL 编码
step2 = codec.EncodeUrl(step1)
println("After URL Encode:", step2)

// 第三层：Hex 编码
step3 = codec.EncodeToHex(step2)
// 显示前 60 个字符（如果太长）
if len(step3) > 60 {
    println("After Hex Encode:", step3[:60] + "...")
} else {
    println("After Hex Encode:", step3)
}

// ========================================
// 解码过程
// ========================================

println("\n=== Decoding Process ===")

// 第一层解码：Hex 解码
decoded1 = codec.DecodeHex(step3)~
println("After Hex Decode:", string(decoded1))

// 第二层解码：URL 解码
decoded2 = codec.DecodeUrl(string(decoded1))~
println("After URL Decode:", string(decoded2))

// 第三层解码：Base64 解码
decoded3 = codec.DecodeBase64(string(decoded2))~
finalResult = string(decoded3)
println("After Base64 Decode:", finalResult)

// ========================================
// 验证结果
// ========================================

println("\n=== Verification ===")
if finalResult == original {
    println("✓ Decoded matches original!")
    println(f"  Original: [${original}]")
    println(f"  Decoded:  [${finalResult}]")
} else {
    println("✗ Decoded does NOT match original!")
    println(f"  Original: [${original}]")
    println(f"  Decoded:  [${finalResult}]")
    die("Verification failed!")
}

// ========================================
// 验证测试
// ========================================

// 验证最终结果与原始数据一致
assert finalResult == original, "Final result should match original data"

// 验证中间步骤不为空
assert len(step1) > 0, "Base64 encoding should produce output"
assert len(step2) > 0, "URL encoding should produce output"
assert len(step3) > 0, "Hex encoding should produce output"

// 验证解码步骤不为空
assert len(decoded1) > 0, "Hex decoding should produce output"
assert len(decoded2) > 0, "URL decoding should produce output"
assert len(decoded3) > 0, "Base64 decoding should produce output"

println("\n✓ All tests passed!")

/*
验证方法：
在命令行执行：
  yak PRACTICE_medium_codec_chain.yak

预期输出：
  === Encoding Process ===
  Original: admin' OR '1'='1' -- 
  After Base64: YWRtaW4nIE9SICcxJz0nMScgLS0g
  After URL Encode: YWRtaW4lMjclMjBPUiUyMCUyNzElMjclM0QlMjcxJTI3JTIwLS0lMjA%3D
  After Hex Encode: 59574674615735684a544a764a5449774d7a4a766369...
  
  === Decoding Process ===
  After Hex Decode: YWRtaW4lMjclMjBPUiUyMCUyNzElMjclM0QlMjcxJTI3JTIwLS0lMjA=
  After URL Decode: YWRtaW4nIE9SICcxJz0nMScgLS0g
  After Base64 Decode: admin' OR '1'='1' -- 
  
  === Verification ===
  ✓ Decoded matches original!
    Original: [admin' OR '1'='1' -- ]
    Decoded:  [admin' OR '1'='1' -- ]
  
  ✓ All tests passed!

测试要点：
1. 能正确进行 Base64 编码/解码
2. 能正确进行 URL 编码/解码
3. 能正确进行 Hex 编码/解码
4. 多层编解码后数据完整不丢失
5. 最终解码结果与原始数据完全一致

这个题目模拟了实际安全测试中常见的场景：
- Web 应用可能对用户输入进行多层编码
- 渗透测试需要理解和处理这些编码
- SQL 注入等攻击载荷可能经过多层编码
*/

