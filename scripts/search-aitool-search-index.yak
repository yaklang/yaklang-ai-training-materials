#!/usr/bin/env yak

// =============================================================================
// AI å·¥å…·æœç´¢è„šæœ¬ - Search AI Tool Index
// åŠŸèƒ½: ä½¿ç”¨æ„å»ºå¥½çš„ AI å·¥å…· RAG ç´¢å¼•è¿›è¡Œæœç´¢
// ç”¨é€”: æœç´¢å’Œå‘ç° AI å·¥å…·ï¼ŒåŸºäºå‘é‡ç›¸ä¼¼åº¦åŒ¹é…
//
// æ ¸å¿ƒæŠ€æœ¯æ ˆ:
// - rag.Import/Export: RAG å¯¼å…¥å¯¼å‡º
// - rag.Get: è·å– RAG é›†åˆ
// - rag.Search: å‘é‡æœç´¢
//
// æ–°ç‰¹æ€§:
// - æ™ºèƒ½æœç´¢: åŸºäºå‘é‡ç›¸ä¼¼åº¦çš„ AI å·¥å…·æœç´¢
// - ç»“æœæ’åº: æŒ‰ç›¸å…³åº¦æ’åºæœç´¢ç»“æœ
// - å¤šæ ·åŒ–è¾“å‡º: æ”¯æŒ JSON å’Œè¡¨æ ¼æ ¼å¼è¾“å‡º
//
// ä½¿ç”¨ç¤ºä¾‹:
// go run common/yak/cmd/yak.go scripts/search-aitool-search-index.yak --rag-file aitool-search-index-v1.0.0.rag --query "æ£€æŸ¥è¯­æ³•" --limit 5
// yak scripts/search-aitool-search-index.yak --rag-file aitool-search-index-v1.0.0.rag --query "æ£€æŸ¥è¯­æ³•" --limit 5
//
// åº”ç”¨åœºæ™¯: AI å·¥å…·å‘ç°ã€æ™ºèƒ½æœç´¢ã€å·¥å…·æ¨è
// å…³é”®è¯: ai-tools search rag-search tool-discovery vector-search
// æœç´¢æ ‡ç­¾: #ai-tools #search #rag #tool-discovery #vector-search
// =============================================================================

__DESC__ = "Search AI tool index using RAG"

yakit.AutoInitYakit()

// =============================================================================
// æ‰§è¡Œè¯´æ˜
// ä½¿ç”¨ go run æ‰§è¡Œæ­¤è„šæœ¬ï¼ˆç¡®ä¿ä»£ç æœ€æ–°ï¼‰ï¼š
// go run common/yak/cmd/yak.go scripts/search-aitool-search-index.yak --rag-file aitool-search-index-v1.0.0.rag --query "æ£€æŸ¥è¯­æ³•" --limit 5
//
// æˆ–è€…ä½¿ç”¨å·²å®‰è£…çš„ yak å‘½ä»¤ï¼š
// yak scripts/search-aitool-search-index.yak --rag-file aitool-search-index-v1.0.0.rag --query "æ£€æŸ¥è¯­æ³•" --limit 5
// =============================================================================

// =============================================================================
// CLI å‚æ•°é…ç½®æ¨¡å— - å‘½ä»¤è¡Œæ¥å£å®šä¹‰
// =============================================================================

// RAG æ–‡ä»¶è·¯å¾„
ragFilePath = cli.String(
    "rag-file",
    cli.setVerboseName("RAGæ–‡ä»¶"),
    cli.setRequired(true),
    cli.setHelp("Path to the AI tools RAG index file (.rag)")
)

// æœç´¢æŸ¥è¯¢
searchQuery = cli.String(
    "query",
    cli.setVerboseName("æŸ¥è¯¢"),
    cli.setRequired(true),
    cli.setHelp("Search query for AI tools")
)

// æœç´¢ç»“æœé™åˆ¶
limit = cli.Int(
    "limit",
    cli.setVerboseName("é™åˆ¶"),
    cli.setDefault(10),
    cli.setHelp("Maximum number of search results to return")
)

// è¾“å‡ºæ ¼å¼
outputFormat = cli.String(
    "format",
    cli.setVerboseName("æ ¼å¼"),
    cli.setDefault("table"),
    cli.setHelp("Output format: table, json (default: table)")
)

ragCollectionName = "yaklang-ai-tools"

// Embedding æœåŠ¡å™¨åœ°å€ï¼ˆå†…ç½®æœåŠ¡ï¼Œæ— éœ€é…ç½®ï¼‰
embeddingHost = cli.String(
    "embedding-host",
    cli.setDefault(""),
    cli.setHelp("Embedding server address (leave empty to use built-in service)")
)

// Embedding æœåŠ¡å™¨ç«¯å£ï¼ˆå†…ç½®æœåŠ¡ï¼Œæ— éœ€é…ç½®ï¼‰
embeddingPort = cli.Int(
    "embedding-port",
    cli.setDefault(0),
    cli.setHelp("Embedding server port (leave empty to use built-in service)")
)

// TOTP å¯†é’¥ï¼ˆå¯é€‰ï¼Œå¦‚æœ embedding æœåŠ¡éœ€è¦éªŒè¯ï¼‰
totpSecret = cli.String(
    "totp-secret",
    cli.setDefault(""),
    cli.setHelp("TOTP secret for embedding service authentication (optional)")
)

// è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
timeout = cli.Int(
    "timeout",
    cli.setDefault(30),
    cli.setHelp("HTTP request timeout in seconds")
)

cli.check()

// =============================================================================
// å‚æ•°éªŒè¯æ¨¡å—
// =============================================================================

if ragFilePath == "" || searchQuery == "" {
    die("Required parameters: --rag-file, --query")
}

if !file.IsExisted(ragFilePath) {
    die(sprintf("RAG file does not exist: %s", ragFilePath))
}

log.info("=== AI Tools Search Configuration ===")
log.info("RAG File: %s", ragFilePath)
log.info("Query: %s", searchQuery)
log.info("Limit: %d", limit)
log.info("Format: %s", outputFormat)
log.info("Collection: %s", ragCollectionName)
if embeddingHost == "" || embeddingPort == 0 {
    log.info("Embedding Service: Built-in (aibalance free)")
} else {
    log.info("Embedding Server: %s:%d", embeddingHost, embeddingPort)
}
if totpSecret != "" {
    log.info("TOTP Auth: Enabled")
} else {
    log.info("TOTP Auth: Disabled")
}

// =============================================================================
// å·¥å…·å‡½æ•°å®šä¹‰
// åŠŸèƒ½: ä¿®å¤å†…ç½®å‡½æ•°çš„å·²çŸ¥é—®é¢˜
// =============================================================================

// ç§»é™¤è‡ªå®šä¹‰lenå‡½æ•°ï¼Œä½¿ç”¨å†…ç½®çš„

// =============================================================================
// Embedding å¤„ç†å‡½æ•°å®šä¹‰
// åŠŸèƒ½: å°è£… embedding è¯·æ±‚é€»è¾‘ï¼Œæ”¯æŒ TOTP éªŒè¯
// =============================================================================

prod_env_embeddingHandle = func(text) {
    if text == "" {
        log.error("Empty text for embedding")
        return nil
    }

    // ä¼˜åŒ–æ—¥å¿—è¾“å‡ºï¼šæ˜¾ç¤ºæ–‡æœ¬é¢„è§ˆ
    if len(text) <= 100 {
        log.info("Generating embedding for text (length: %d): %s", len(text), text)
    } else {
        preview = str.TrimSpace(text[:100])
        log.info("Generating embedding for text (length: %d), preview: %s...", len(text), preview)
    }

    // å¦‚æœé…ç½®äº† TOTPï¼Œç”ŸæˆéªŒè¯ç 
    totpCode = ""
    if totpSecret != "" {
        totpCode = twofa.GetUTCCode(totpSecret)
        currentTime = time.Now().Unix()
        log.info("Generated TOTP code: %s (timestamp: %d)", totpCode, currentTime)
    }

    // æ„å»ºè¯·æ±‚ä½“
    requestBody = json.dumps({
        "input": text,
        "model": "embedding",
    })

    // æ„å»º HTTP è¯·æ±‚
    httpRequest = sprintf(`POST /embeddings HTTP/1.1
Host: %s
Content-Type: application/json`, embeddingHost)

    // å¦‚æœæœ‰ TOTPï¼Œæ·»åŠ éªŒè¯å¤´
    if totpCode != "" {
        httpRequest = sprintf(`%s
X-TOTP-Code: %s`, httpRequest, totpCode)
    }

    httpRequest = sprintf(`%s
Content-Length: %d

%s`, httpRequest, len(requestBody), requestBody)

    // å‘é€è¯·æ±‚
    try {
        rsp, _, err = poc.HTTP(
            httpRequest,
            poc.host(embeddingHost),
            poc.port(embeddingPort),
            poc.https(true),
            poc.timeout(timeout),
        )

        if err != nil {
            log.error("Failed to send embedding request: %v", err)
            return nil
        }

        // è·å–çŠ¶æ€ç 
        statusCode = poc.GetStatusCodeFromResponse(rsp)

        if statusCode != 200 {
            log.error("Embedding request failed with status code: %d", statusCode)
            _, body = poc.Split(rsp)
            log.error("Response body: %s", string(body))
            return nil
        }

        // è§£æå“åº”
        _, body = poc.Split(rsp)
        responseData = json.loads(body)

        if responseData["data"] == nil || len(responseData["data"]) == 0 {
            log.error("No embedding data in response")
            return nil
        }

        embeddingData = responseData["data"][0]
        embedding = embeddingData["embedding"]

        log.info("Embedding generated successfully (dimension: %d)", len(embedding))
        return embedding

    } catch embeddingErr {
        log.error("Failed to generate embedding: %v", embeddingErr)
        return nil
    }
}

// å¸¦é‡è¯•çš„ embedding å¤„ç†å‡½æ•°
prod_env_embeddingHandle_with_retry = func(text) {
    maxRetries = 5
    for i = 0; i < maxRetries; i++ {
        if i > 0 {
            log.warn("ğŸ”„ [RETRY %d/%d] Retrying embedding request...", i, maxRetries-1)
        }

        result = prod_env_embeddingHandle(text)
        if result != nil {
            if i > 0 {
                log.info("âœ“ Embedding succeeded after %d retries", i)
            }
            return result
        }

        if i < maxRetries - 1 {
            // ç­‰å¾…æ—¶é—´é€’å¢ï¼šç¬¬1æ¬¡é‡è¯•ç­‰1ç§’ï¼Œç¬¬2æ¬¡ç­‰2ç§’ï¼Œç¬¬3æ¬¡ç­‰3ç§’ï¼Œç¬¬4æ¬¡ç­‰4ç§’
            // è¿™æ ·å¯ä»¥è®© TOTP æœ‰æ›´å¤§æœºä¼šåˆ‡æ¢åˆ°æ–°çš„æ—¶é—´çª—å£
            waitSeconds = i + 1
            log.warn("â³ Embedding failed, waiting %d seconds before retry...", waitSeconds)
            time.Sleep(waitSeconds)
        }
    }

    log.error("âŒ Embedding failed after %d attempts, giving up", maxRetries)
    return nil
}

embeddingHandle = prod_env_embeddingHandle_with_retry

// =============================================================================
// å¯¼å…¥ RAG æ–‡ä»¶
// åŠŸèƒ½: å¯¼å…¥ AI å·¥å…· RAG ç´¢å¼•æ–‡ä»¶
// =============================================================================

log.info("")
log.info("=== å¯¼å…¥RAGæ–‡ä»¶ ===")

// ç§»é™¤ç°æœ‰é›†åˆ
rag.DeleteCollection(ragCollectionName)

try {
    err = rag.Import(ragFilePath, rag.importName(ragCollectionName))
    if err != nil {
        log.error("âŒ å¯¼å…¥RAGæ–‡ä»¶å¤±è´¥: %v", err)
        die(sprintf("Failed to import RAG file: %v", err))
    }
    log.info("âœ“ RAGæ–‡ä»¶å¯¼å…¥æˆåŠŸ: %s", ragCollectionName)
} catch importErr {
    log.error("âŒ å¯¼å…¥RAGæ–‡ä»¶å¤±è´¥: %v", importErr)
    die(sprintf("Failed to import RAG file: %v", importErr))
}

// =============================================================================
// åŠ è½½ RAG Collection
// åŠŸèƒ½: ä½¿ç”¨å†…ç½® embedding æœåŠ¡åŠ è½½ RAG é›†åˆ
// =============================================================================

// å…¨å±€RAGç³»ç»Ÿå˜é‡å£°æ˜
ragSystem = nil

log.info("")
log.info("=== åŠ è½½RAGé›†åˆ ===")

// å¦‚æœæ²¡æœ‰æŒ‡å®šå¤–éƒ¨embeddingæœåŠ¡å™¨ï¼Œä½¿ç”¨å†…ç½®æœåŠ¡
if embeddingHost == "" || embeddingPort == 0 {
    log.info("ğŸ¤– ä½¿ç”¨å†…ç½®embeddingæœåŠ¡")
    ragSystem, err = rag.Get(ragCollectionName)
    if err != nil {
        log.error("âŒ åŠ è½½RAGé›†åˆå¤±è´¥ (å†…ç½®æœåŠ¡): %v", err)
        die(sprintf("Failed to load RAG collection with built-in service: %v", err))
    }
} else {
    log.info("ğŸŒ ä½¿ç”¨å¤–éƒ¨embeddingæœåŠ¡: %s:%d", embeddingHost, embeddingPort)
    ragSystem, err = rag.Get(ragCollectionName, rag.embeddingHandle(embeddingHandle))
    if err != nil {
        log.error("âŒ åŠ è½½RAGé›†åˆå¤±è´¥ (å¤–éƒ¨æœåŠ¡): %v", err)
        die(sprintf("Failed to load RAG collection with external service: %v", err))
    }
}

    log.info("âœ“ RAG é›†åˆåŠ è½½æˆåŠŸ: %s", ragCollectionName)

// è·å–æ–‡æ¡£æ•°é‡
docCount = 0
docCount, err = ragSystem.CountDocuments()
if err != nil {
    log.warn("âš ï¸ æ— æ³•è·å–æ–‡æ¡£æ•°é‡: %v", err)
} else {
    log.info("ğŸ“Š ç´¢å¼•æ–‡æ¡£æ€»æ•°: %d", docCount)
}

// =============================================================================
// æ‰§è¡Œæœç´¢
// åŠŸèƒ½: ä½¿ç”¨æŸ¥è¯¢å­—ç¬¦ä¸²æœç´¢ AI å·¥å…·
// =============================================================================

log.info("")
log.info("=== å¼€å§‹æœç´¢ ===")
log.info("ğŸ” æœç´¢å…³é”®è¯: %s", searchQuery)
log.info("ğŸ“ æœ€å¤§ç»“æœæ•°: %d", limit)

searchResults = []
allResults = []

// å®šä¹‰ç»“æœå¤„ç†å‡½æ•°
processSearchResult = func(result, searchType) {
    // ä¼˜å…ˆä» KnowledgeBaseEntry è·å–çŸ¥è¯†æ¡ç›®ä¿¡æ¯
    kbEntry = result.KnowledgeBaseEntry
    
    // ä» Document.Metadata ä¸­è·å–å·¥å…·ç›¸å…³ä¿¡æ¯
    metadata = result.Document.Metadata
    toolName = metadata["tool_name"] || ""
    toolVerboseName = metadata["verbose_name"] || ""
    toolDescription = metadata["description"] || ""
    indexType = metadata["index_type"] || "question"
    questionText = metadata["question_text"] || ""
    
    // å¦‚æœæœ‰å…³è”çš„çŸ¥è¯†æ¡ç›®ï¼Œä» KnowledgeDetails ä¸­è§£æå·¥å…·ä¿¡æ¯
    knowledgeTitle = ""
    knowledgeDetails = ""
    if kbEntry != nil {
        knowledgeTitle = kbEntry.KnowledgeTitle
        knowledgeDetails = kbEntry.KnowledgeDetails
        
        // ä» KnowledgeDetails è§£æå·¥å…·ä¿¡æ¯
        if knowledgeDetails != "" {
            lines = str.Split(knowledgeDetails, "\n")
            for _, line := range lines {
                line = str.TrimSpace(line)
                if str.HasPrefix(line, "å·¥å…·åç§°:") && toolName == "" {
                    toolName = str.TrimSpace(str.TrimPrefix(line, "å·¥å…·åç§°:"))
                } else if str.HasPrefix(line, "æ˜¾ç¤ºåç§°:") && toolVerboseName == "" {
                    toolVerboseName = str.TrimSpace(str.TrimPrefix(line, "æ˜¾ç¤ºåç§°:"))
                } else if str.HasPrefix(line, "åŠŸèƒ½æè¿°:") && toolDescription == "" {
                    toolDescription = str.TrimSpace(str.TrimPrefix(line, "åŠŸèƒ½æè¿°:"))
                }
            }
        }
    }
    
    // è®¾ç½®é»˜è®¤å€¼
    if toolName == "" { toolName = "æœªçŸ¥å·¥å…·" }
    if toolVerboseName == "" { toolVerboseName = toolName }
    if toolDescription == "" { toolDescription = "æš‚æ— æè¿°" }
    
    // ä½¿ç”¨åŒ¹é…çš„é—®é¢˜ä½œä¸º questionText
    if questionText == "" && knowledgeTitle != "" {
        questionText = knowledgeTitle
    }

    return {
        "score": result.Score,
        "tool_name": toolName,
        "verbose_name": toolVerboseName,
        "description": toolDescription,
        "index_type": indexType,
        "question_text": questionText,
        "knowledge_entry": kbEntry,
        "knowledge_title": knowledgeTitle,
        "knowledge_details": knowledgeDetails,
        "search_type": searchType,
    }
}

try {
    // ============================================
    // 1. è¯­ä¹‰æœç´¢ (Vector Search)
    // ============================================
    log.info("âš¡ [1/2] æ‰§è¡Œè¯­ä¹‰æœç´¢ (QueryTopN)...")
    semanticResults, err = ragSystem.QueryTopN(searchQuery, limit)
    if err != nil {
        log.warn("âš ï¸ è¯­ä¹‰æœç´¢å¤±è´¥: %v", err)
    } else {
        log.info("âœ“ è¯­ä¹‰æœç´¢å®Œæˆï¼Œæ‰¾åˆ° %d ä¸ªç»“æœ", len(semanticResults))
        for _, result := range semanticResults {
            allResults = append(allResults, processSearchResult(result, "è¯­ä¹‰"))
        }
    }

    // ============================================
    // 2. å…³é”®è¯æœç´¢ (Fuzzy Search)
    // ============================================
    log.info("âš¡ [2/2] æ‰§è¡Œå…³é”®è¯æœç´¢ (FuzzRawSearch)...")
    ctx = context.Background()
    fuzzResultsChan, err = ragSystem.FuzzRawSearch(ctx, searchQuery, limit)
    if err != nil {
        log.warn("âš ï¸ å…³é”®è¯æœç´¢å¤±è´¥: %v", err)
    } else {
        fuzzCount = 0
        for result := range fuzzResultsChan {
            fuzzCount++
            allResults = append(allResults, processSearchResult(result, "å…³é”®è¯"))
        }
        log.info("âœ“ å…³é”®è¯æœç´¢å®Œæˆï¼Œæ‰¾åˆ° %d ä¸ªç»“æœ", fuzzCount)
    }

    // ============================================
    // 3. ç»“æœå»é‡ä¸æ’åº
    // ============================================
    log.info("ğŸ“Š åˆå¹¶ç»“æœå¹¶å»é‡...")
    
    // æŒ‰ tool_name å»é‡ï¼Œä¿ç•™åˆ†æ•°æœ€é«˜çš„
    toolResultMap = {}
    for _, r := range allResults {
        key = r["tool_name"]
        existing = toolResultMap[key]
        if existing == nil || r["score"] > existing["score"] {
            toolResultMap[key] = r
        }
    }
    
    // è½¬æ¢ä¸ºæ•°ç»„
    dedupedResults = []
    for _, v := range toolResultMap {
        dedupedResults = append(dedupedResults, v)
    }
    
    // ç®€å•å†’æ³¡æ’åºï¼ˆæŒ‰åˆ†æ•°é™åºï¼‰
    for i := 0; i < len(dedupedResults); i++ {
        for j := i + 1; j < len(dedupedResults); j++ {
            if dedupedResults[j]["score"] > dedupedResults[i]["score"] {
                temp = dedupedResults[i]
                dedupedResults[i] = dedupedResults[j]
                dedupedResults[j] = temp
            }
        }
    }
    
    // å–å‰ limit ä¸ªç»“æœ
    if len(dedupedResults) > limit {
        dedupedResults = dedupedResults[:limit]
    }
    
    // æ·»åŠ æ’åå¹¶è¾“å‡ºæ—¥å¿—
    for i, r := range dedupedResults {
        r["rank"] = i + 1
        log.info("  ğŸ“š [%d] å·¥å…·: %s (%s) | %sæœç´¢ | åˆ†æ•°: %.4f", 
            i+1, r["verbose_name"], r["tool_name"], r["search_type"], r["score"])
        log.info("      ğŸ“‹ æè¿°: %s", r["description"])
        if r["question_text"] != "" {
            log.info("      ğŸ” åŒ¹é…: %s", r["question_text"])
        }
        searchResults = append(searchResults, r)
    }

    log.info("âœ“ æœç´¢å®Œæˆï¼Œå…±æ‰¾åˆ° %d ä¸ªä¸é‡å¤ç»“æœ", len(searchResults))

} catch searchErr {
    log.error("âŒ æœç´¢å¤±è´¥: %v", searchErr)
    die(sprintf("Failed to search RAG: %v", searchErr))
}

// =============================================================================
// è¾“å‡ºç»“æœ
// åŠŸèƒ½: æ ¹æ®æŒ‡å®šæ ¼å¼è¾“å‡ºæœç´¢ç»“æœ
// =============================================================================

if len(searchResults) == 0 {
    log.info("âŒ æœªæ‰¾åˆ°ä¸ '%s' ç›¸å…³çš„å·¥å…·", searchQuery)
    os.Exit(0)
}

// è¡¨æ ¼æ ¼å¼è¾“å‡ºï¼ˆäººç±»å¯è¯»ä¼˜åŒ–ï¼‰
if outputFormat == "table" {
    println("")
    println("================================================================================")
    println("ğŸ” AI å·¥å…·æœç´¢ç»“æœ")
    println(sprintf("   æŸ¥è¯¢: %s", searchQuery))
    println("================================================================================")
    println("")

    for _, result := range searchResults {
        toolName = sprintf("%v", result["tool_name"])
        verboseName = sprintf("%v", result["verbose_name"])
        description = sprintf("%v", result["description"])
        questionText = sprintf("%v", result["question_text"])
        score = result["score"]

        // æˆªæ–­è¿‡é•¿çš„æè¿°
        if len(description) > 80 {
            description = description[:80] + "..."
        }

        // æˆªæ–­è¿‡é•¿çš„é—®é¢˜
        if len(questionText) > 60 {
            questionText = questionText[:60] + "..."
        }

        println(sprintf("ğŸ“ ç¬¬ %d å | ç›¸å…³åº¦: %.2f%%", result["rank"], score * 100))
        println(sprintf("   ğŸ› ï¸  å·¥å…·: %s", verboseName))
        println(sprintf("   ğŸ†” ID: %s", toolName))
        println(sprintf("   ğŸ“‹ åŠŸèƒ½: %s", description))
        if questionText != "" {
            println(sprintf("   ğŸ” åŒ¹é…é—®é¢˜: %s", questionText))
        }
        println("--------------------------------------------------------------------------------")
    }
    println("")

// JSON æ ¼å¼è¾“å‡º
} else if outputFormat == "json" {
    jsonOutput = {
        "query": searchQuery,
        "total_results": len(searchResults),
        "results": searchResults,
        "timestamp": time.Now().Format("2006-01-02 15:04:05"),
    }
    println(json.dumps(jsonOutput))
} else {
    log.error("Unknown output format: %s", outputFormat)
    die("Supported formats: table, json")
}

log.info("")
log.info("=== æœç´¢å®Œæˆ ===")
log.info("âœ“ å…±æ‰¾åˆ° %d ä¸ªç›¸å…³å·¥å…·", len(searchResults))
log.info("ğŸ“„ RAG æ–‡ä»¶: %s", ragFilePath)

os.Exit(0)
