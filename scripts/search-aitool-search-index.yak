#!/usr/bin/env yak

// =============================================================================
// AI å·¥å…·æœç´¢è„šæœ¬ - Search AI Tool Index
// åŠŸèƒ½: ä½¿ç”¨æ„å»ºå¥½çš„ AI å·¥å…· RAG ç´¢å¼•è¿›è¡Œæœç´¢
// ç”¨é€”: æœç´¢å’Œå‘ç° AI å·¥å…·ï¼ŒåŸºäºå‘é‡ç›¸ä¼¼åº¦åŒ¹é…
//
// æ ¸å¿ƒæŠ€æœ¯æ ˆ:
// - rag.Import/Export: RAG å¯¼å…¥å¯¼å‡º
// - rag.Get: è·å– RAG é›†åˆ
// - rag.Search: å‘é‡æœç´¢
//
// æ–°ç‰¹æ€§:
// - æ™ºèƒ½æœç´¢: åŸºäºå‘é‡ç›¸ä¼¼åº¦çš„ AI å·¥å…·æœç´¢
// - ç»“æœæ’åº: æŒ‰ç›¸å…³åº¦æ’åºæœç´¢ç»“æœ
// - å¤šæ ·åŒ–è¾“å‡º: æ”¯æŒ JSON å’Œè¡¨æ ¼æ ¼å¼è¾“å‡º
//
// ä½¿ç”¨ç¤ºä¾‹:
// go run common/yak/cmd/yak.go scripts/search-aitool-search-index.yak --rag-file aitool-search-index-v1.0.0.rag --query "æ£€æŸ¥è¯­æ³•" --limit 5
// yak scripts/search-aitool-search-index.yak --rag-file aitool-search-index-v1.0.0.rag --query "æ£€æŸ¥è¯­æ³•" --limit 5
//
// åº”ç”¨åœºæ™¯: AI å·¥å…·å‘ç°ã€æ™ºèƒ½æœç´¢ã€å·¥å…·æ¨è
// å…³é”®è¯: ai-tools search rag-search tool-discovery vector-search
// æœç´¢æ ‡ç­¾: #ai-tools #search #rag #tool-discovery #vector-search
// =============================================================================

__DESC__ = "Search AI tool index using RAG"

yakit.AutoInitYakit()

// =============================================================================
// æ‰§è¡Œè¯´æ˜
// ä½¿ç”¨ go run æ‰§è¡Œæ­¤è„šæœ¬ï¼ˆç¡®ä¿ä»£ç æœ€æ–°ï¼‰ï¼š
// go run common/yak/cmd/yak.go scripts/search-aitool-search-index.yak --rag-file aitool-search-index-v1.0.0.rag --query "æ£€æŸ¥è¯­æ³•" --limit 5
//
// æˆ–è€…ä½¿ç”¨å·²å®‰è£…çš„ yak å‘½ä»¤ï¼š
// yak scripts/search-aitool-search-index.yak --rag-file aitool-search-index-v1.0.0.rag --query "æ£€æŸ¥è¯­æ³•" --limit 5
// =============================================================================

// =============================================================================
// CLI å‚æ•°é…ç½®æ¨¡å— - å‘½ä»¤è¡Œæ¥å£å®šä¹‰
// =============================================================================

// RAG æ–‡ä»¶è·¯å¾„
ragFilePath = cli.String(
    "rag-file",
    cli.setVerboseName("RAGæ–‡ä»¶"),
    cli.setRequired(true),
    cli.setHelp("Path to the AI tools RAG index file (.rag)")
)

// æœç´¢æŸ¥è¯¢
searchQuery = cli.String(
    "query",
    cli.setVerboseName("æŸ¥è¯¢"),
    cli.setRequired(true),
    cli.setHelp("Search query for AI tools")
)

// æœç´¢ç»“æœé™åˆ¶
limit = cli.Int(
    "limit",
    cli.setVerboseName("é™åˆ¶"),
    cli.setDefault(10),
    cli.setHelp("Maximum number of search results to return")
)

// è¾“å‡ºæ ¼å¼
outputFormat = cli.String(
    "format",
    cli.setVerboseName("æ ¼å¼"),
    cli.setDefault("table"),
    cli.setHelp("Output format: table, json (default: table)")
)

ragCollectionName = "yaklang-ai-tools"

// Embedding æœåŠ¡å™¨åœ°å€ï¼ˆå†…ç½®æœåŠ¡ï¼Œæ— éœ€é…ç½®ï¼‰
embeddingHost = cli.String(
    "embedding-host",
    cli.setDefault(""),
    cli.setHelp("Embedding server address (leave empty to use built-in service)")
)

// Embedding æœåŠ¡å™¨ç«¯å£ï¼ˆå†…ç½®æœåŠ¡ï¼Œæ— éœ€é…ç½®ï¼‰
embeddingPort = cli.Int(
    "embedding-port",
    cli.setDefault(0),
    cli.setHelp("Embedding server port (leave empty to use built-in service)")
)

// TOTP å¯†é’¥ï¼ˆå¯é€‰ï¼Œå¦‚æœ embedding æœåŠ¡éœ€è¦éªŒè¯ï¼‰
totpSecret = cli.String(
    "totp-secret",
    cli.setDefault(""),
    cli.setHelp("TOTP secret for embedding service authentication (optional)")
)

// è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
timeout = cli.Int(
    "timeout",
    cli.setDefault(30),
    cli.setHelp("HTTP request timeout in seconds")
)

cli.check()

// =============================================================================
// å‚æ•°éªŒè¯æ¨¡å—
// =============================================================================

if ragFilePath == "" || searchQuery == "" {
    die("Required parameters: --rag-file, --query")
}

if !file.IsExisted(ragFilePath) {
    die(sprintf("RAG file does not exist: %s", ragFilePath))
}

log.info("=== AI Tools Search Configuration ===")
log.info("RAG File: %s", ragFilePath)
log.info("Query: %s", searchQuery)
log.info("Limit: %d", limit)
log.info("Format: %s", outputFormat)
log.info("Collection: %s", ragCollectionName)
if embeddingHost == "" || embeddingPort == 0 {
    log.info("Embedding Service: Built-in (aibalance free)")
} else {
    log.info("Embedding Server: %s:%d", embeddingHost, embeddingPort)
}
if totpSecret != "" {
    log.info("TOTP Auth: Enabled")
} else {
    log.info("TOTP Auth: Disabled")
}

// =============================================================================
// å·¥å…·å‡½æ•°å®šä¹‰
// åŠŸèƒ½: ä¿®å¤å†…ç½®å‡½æ•°çš„å·²çŸ¥é—®é¢˜
// =============================================================================

// ç§»é™¤è‡ªå®šä¹‰lenå‡½æ•°ï¼Œä½¿ç”¨å†…ç½®çš„

// =============================================================================
// Embedding å¤„ç†å‡½æ•°å®šä¹‰
// åŠŸèƒ½: å°è£… embedding è¯·æ±‚é€»è¾‘ï¼Œæ”¯æŒ TOTP éªŒè¯
// =============================================================================

prod_env_embeddingHandle = func(text) {
    if text == "" {
        log.error("Empty text for embedding")
        return nil
    }

    // ä¼˜åŒ–æ—¥å¿—è¾“å‡ºï¼šæ˜¾ç¤ºæ–‡æœ¬é¢„è§ˆ
    if len(text) <= 100 {
        log.info("Generating embedding for text (length: %d): %s", len(text), text)
    } else {
        preview = str.TrimSpace(text[:100])
        log.info("Generating embedding for text (length: %d), preview: %s...", len(text), preview)
    }

    // å¦‚æœé…ç½®äº† TOTPï¼Œç”ŸæˆéªŒè¯ç 
    totpCode = ""
    if totpSecret != "" {
        totpCode = twofa.GetUTCCode(totpSecret)
        currentTime = time.Now().Unix()
        log.info("Generated TOTP code: %s (timestamp: %d)", totpCode, currentTime)
    }

    // æ„å»ºè¯·æ±‚ä½“
    requestBody = json.dumps({
        "input": text,
        "model": "embedding",
    })

    // æ„å»º HTTP è¯·æ±‚
    httpRequest = sprintf(`POST /embeddings HTTP/1.1
Host: %s
Content-Type: application/json`, embeddingHost)

    // å¦‚æœæœ‰ TOTPï¼Œæ·»åŠ éªŒè¯å¤´
    if totpCode != "" {
        httpRequest = sprintf(`%s
X-TOTP-Code: %s`, httpRequest, totpCode)
    }

    httpRequest = sprintf(`%s
Content-Length: %d

%s`, httpRequest, len(requestBody), requestBody)

    // å‘é€è¯·æ±‚
    try {
        rsp, _, err = poc.HTTP(
            httpRequest,
            poc.host(embeddingHost),
            poc.port(embeddingPort),
            poc.https(true),
            poc.timeout(timeout),
        )

        if err != nil {
            log.error("Failed to send embedding request: %v", err)
            return nil
        }

        // è·å–çŠ¶æ€ç 
        statusCode = poc.GetStatusCodeFromResponse(rsp)

        if statusCode != 200 {
            log.error("Embedding request failed with status code: %d", statusCode)
            _, body = poc.Split(rsp)
            log.error("Response body: %s", string(body))
            return nil
        }

        // è§£æå“åº”
        _, body = poc.Split(rsp)
        responseData = json.loads(body)

        if responseData["data"] == nil || len(responseData["data"]) == 0 {
            log.error("No embedding data in response")
            return nil
        }

        embeddingData = responseData["data"][0]
        embedding = embeddingData["embedding"]

        log.info("Embedding generated successfully (dimension: %d)", len(embedding))
        return embedding

    } catch embeddingErr {
        log.error("Failed to generate embedding: %v", embeddingErr)
        return nil
    }
}

// å¸¦é‡è¯•çš„ embedding å¤„ç†å‡½æ•°
prod_env_embeddingHandle_with_retry = func(text) {
    maxRetries = 5
    for i = 0; i < maxRetries; i++ {
        if i > 0 {
            log.warn("ğŸ”„ [RETRY %d/%d] Retrying embedding request...", i, maxRetries-1)
        }

        result = prod_env_embeddingHandle(text)
        if result != nil {
            if i > 0 {
                log.info("âœ“ Embedding succeeded after %d retries", i)
            }
            return result
        }

        if i < maxRetries - 1 {
            // ç­‰å¾…æ—¶é—´é€’å¢ï¼šç¬¬1æ¬¡é‡è¯•ç­‰1ç§’ï¼Œç¬¬2æ¬¡ç­‰2ç§’ï¼Œç¬¬3æ¬¡ç­‰3ç§’ï¼Œç¬¬4æ¬¡ç­‰4ç§’
            // è¿™æ ·å¯ä»¥è®© TOTP æœ‰æ›´å¤§æœºä¼šåˆ‡æ¢åˆ°æ–°çš„æ—¶é—´çª—å£
            waitSeconds = i + 1
            log.warn("â³ Embedding failed, waiting %d seconds before retry...", waitSeconds)
            time.Sleep(waitSeconds)
        }
    }

    log.error("âŒ Embedding failed after %d attempts, giving up", maxRetries)
    return nil
}

embeddingHandle = prod_env_embeddingHandle_with_retry

// =============================================================================
// å¯¼å…¥ RAG æ–‡ä»¶
// åŠŸèƒ½: å¯¼å…¥ AI å·¥å…· RAG ç´¢å¼•æ–‡ä»¶
// =============================================================================

log.info("")
log.info("=== å¯¼å…¥RAGæ–‡ä»¶ ===")

// ç§»é™¤ç°æœ‰é›†åˆ
rag.DeleteCollection(ragCollectionName)

try {
    err = rag.Import(ragFilePath, rag.importName(ragCollectionName))
    if err != nil {
        log.error("âŒ å¯¼å…¥RAGæ–‡ä»¶å¤±è´¥: %v", err)
        die(sprintf("Failed to import RAG file: %v", err))
    }
    log.info("âœ“ RAGæ–‡ä»¶å¯¼å…¥æˆåŠŸ: %s", ragCollectionName)
} catch importErr {
    log.error("âŒ å¯¼å…¥RAGæ–‡ä»¶å¤±è´¥: %v", importErr)
    die(sprintf("Failed to import RAG file: %v", importErr))
}

// =============================================================================
// åŠ è½½ RAG Collection
// åŠŸèƒ½: ä½¿ç”¨å†…ç½® embedding æœåŠ¡åŠ è½½ RAG é›†åˆ
// =============================================================================

// å…¨å±€RAGç³»ç»Ÿå˜é‡å£°æ˜
ragSystem = nil

log.info("")
log.info("=== åŠ è½½RAGé›†åˆ ===")

// å¦‚æœæ²¡æœ‰æŒ‡å®šå¤–éƒ¨embeddingæœåŠ¡å™¨ï¼Œä½¿ç”¨å†…ç½®æœåŠ¡
if embeddingHost == "" || embeddingPort == 0 {
    log.info("ğŸ¤– ä½¿ç”¨å†…ç½®embeddingæœåŠ¡")
    ragSystem, err = rag.Get(ragCollectionName)
    if err != nil {
        log.error("âŒ åŠ è½½RAGé›†åˆå¤±è´¥ (å†…ç½®æœåŠ¡): %v", err)
        die(sprintf("Failed to load RAG collection with built-in service: %v", err))
    }
} else {
    log.info("ğŸŒ ä½¿ç”¨å¤–éƒ¨embeddingæœåŠ¡: %s:%d", embeddingHost, embeddingPort)
    ragSystem, err = rag.Get(ragCollectionName, rag.embeddingHandle(embeddingHandle))
    if err != nil {
        log.error("âŒ åŠ è½½RAGé›†åˆå¤±è´¥ (å¤–éƒ¨æœåŠ¡): %v", err)
        die(sprintf("Failed to load RAG collection with external service: %v", err))
    }
}

    log.info("âœ“ RAG é›†åˆåŠ è½½æˆåŠŸ: %s", ragCollectionName)

// è·å–æ–‡æ¡£æ•°é‡
docCount = 0
docCount, err = ragSystem.CountDocuments()
if err != nil {
    log.warn("âš ï¸ æ— æ³•è·å–æ–‡æ¡£æ•°é‡: %v", err)
} else {
    log.info("ğŸ“Š ç´¢å¼•æ–‡æ¡£æ€»æ•°: %d", docCount)
}

// =============================================================================
// æ‰§è¡Œæœç´¢
// åŠŸèƒ½: ä½¿ç”¨æŸ¥è¯¢å­—ç¬¦ä¸²æœç´¢ AI å·¥å…·
// =============================================================================

log.info("")
log.info("=== å¼€å§‹æœç´¢ ===")
log.info("ğŸ” æœç´¢å…³é”®è¯: %s", searchQuery)
log.info("ğŸ“ æœ€å¤§ç»“æœæ•°: %d", limit)

searchResults = []
try {
    log.info("âš¡ æ‰§è¡Œå‘é‡æœç´¢...")
    results, err = ragSystem.FuzzRawSearch(context.Background(), searchQuery, limit)
    if err != nil {
        log.error("Failed to search RAG: %v", err)
        log.error("Error type: %T", err)
        die(sprintf("Failed to search RAG: %v", err))
    }

    log.info("âœ“ æœç´¢å®Œæˆï¼Œæ­£åœ¨å¤„ç†ç»“æœ...")

    // å¤„ç†æœç´¢ç»“æœ (results æ˜¯ä¸€ä¸ª channel)
    resultCount = 0
    for result := range results {
        resultCount++
        if resultCount > limit {
            break
        }

        // ä» Document.Metadata ä¸­ç›´æ¥è·å–å·¥å…·ä¿¡æ¯
        metadata = result.Document.Metadata
        toolName = metadata["tool_name"] || "æœªçŸ¥å·¥å…·"
        toolVerboseName = metadata["verbose_name"] || toolName
        toolDescription = metadata["description"] || "æš‚æ— æè¿°"
        indexType = metadata["index_type"] || "unknown"
        questionText = metadata["question_text"] || ""

        resultData = {
            "rank": resultCount,
            "id": result.Document,
            "content": result.KnowledgeBaseEntry,
            "entity": result.Entity,
            "score": result.Score,
            "tool_name": toolName,
            "verbose_name": toolVerboseName,
            "description": toolDescription,
            "index_type": indexType,
            "question_text": questionText,
        }
        searchResults = append(searchResults, resultData)
        log.info("âœ“ æ‰¾åˆ°å·¥å…·: %s (åˆ†æ•°: %.4f)", toolVerboseName, result.Score)
    }

    log.info("âœ“ æœç´¢å®Œæˆï¼Œå…±æ‰¾åˆ° %d ä¸ªç»“æœ", len(searchResults))

} catch searchErr {
    log.error("âŒ æœç´¢å¤±è´¥: %v", searchErr)
    die(sprintf("Failed to search RAG: %v", searchErr))
}

// =============================================================================
// è¾“å‡ºç»“æœ
// åŠŸèƒ½: æ ¹æ®æŒ‡å®šæ ¼å¼è¾“å‡ºæœç´¢ç»“æœ
// =============================================================================

if len(searchResults) == 0 {
    log.info("âŒ æœªæ‰¾åˆ°ä¸ '%s' ç›¸å…³çš„å·¥å…·", searchQuery)
    os.Exit(0)
}

// è¡¨æ ¼æ ¼å¼è¾“å‡ºï¼ˆäººç±»å¯è¯»ä¼˜åŒ–ï¼‰
if outputFormat == "table" {
    println("")
    println("ğŸ” AI å·¥å…·æœç´¢ç»“æœ")
    println("==================")
    printf("%-3s %-30s %-8s %s\n", "æ’å", "å·¥å…·åç§°", "åˆ†æ•°", "ç›¸å…³ä¿¡æ¯")
    println("-----------------------------------------------------------------------------")

    for _, result := range searchResults {
        toolName = sprintf("%v", result["tool_name"])
        verboseName = sprintf("%v", result["verbose_name"])
        description = sprintf("%v", result["description"])
        questionText = sprintf("%v", result["question_text"])
        indexType = sprintf("%v", result["index_type"])

        // æ˜¾ç¤ºåç§°ï¼šä¼˜å…ˆä½¿ç”¨verbose nameï¼Œå¦åˆ™ä½¿ç”¨tool name
        displayName = verboseName
        if displayName == "" {
            displayName = toolName
        }

        // é™åˆ¶æ˜¾ç¤ºåç§°é•¿åº¦
        if len(displayName) > 28 {
            displayName = displayName[:28] + "..."
        }

        // æ„å»ºæ˜¾ç¤ºä¿¡æ¯ï¼ˆä¼˜å…ˆæ˜¾ç¤ºé—®é¢˜ï¼Œå…¶æ¬¡æ˜¾ç¤ºæè¿°ï¼‰
        displayInfo = ""
        if questionText != "" && indexType == "question" {
            // æ˜¾ç¤ºæœç´¢é—®é¢˜ï¼ˆé—®é¢˜å¼•å¯¼çš„æ ¸å¿ƒå†…å®¹ï¼‰
            if len(questionText) > 50 {
                questionText = questionText[:50] + "..."
            }
            displayInfo = sprintf("ğŸ”¸ %s", questionText)
        } else if description != "" {
            // æ˜¾ç¤ºå·¥å…·æè¿°
            if len(description) > 50 {
                description = description[:50] + "..."
            }
            displayInfo = sprintf("ğŸ“ %s", description)
        } else {
            displayInfo = "â„¹ï¸ å·¥å…·ä¿¡æ¯"
        }

        printf("%-3d %-30s %-8.4f %s\n",
            result["rank"],
            displayName,
            result["score"],
            displayInfo)
    }
    println("")

// JSON æ ¼å¼è¾“å‡º
} else if outputFormat == "json" {
    jsonOutput = {
        "query": searchQuery,
        "total_results": len(searchResults),
        "results": searchResults,
        "timestamp": time.Now().Format("2006-01-02 15:04:05"),
    }
    println(json.dumps(jsonOutput))
} else {
    log.error("Unknown output format: %s", outputFormat)
    die("Supported formats: table, json")
}

log.info("")
log.info("=== æœç´¢å®Œæˆ ===")
log.info("âœ“ å…±æ‰¾åˆ° %d ä¸ªç›¸å…³å·¥å…·", len(searchResults))
log.info("ğŸ“„ RAG æ–‡ä»¶: %s", ragFilePath)

os.Exit(0)
