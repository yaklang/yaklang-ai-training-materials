#!/usr/bin/env yak

// =============================================================================
// AI å·¥å…·æœç´¢ç´¢å¼•æ„å»ºå·¥å…· - Build AI Tool Search Index
// åŠŸèƒ½: ä»æ•°æ®åº“ä¸­è·å–æ‰€æœ‰ AI å·¥å…·ï¼Œä½¿ç”¨ liteforge ç”Ÿæˆé—®é¢˜ç´¢å¼•ï¼Œæ„å»º RAG æœç´¢åŠŸèƒ½
// ç”¨é€”: ä¸º AI å·¥å…·æ„å»ºå¯æœç´¢çš„ç´¢å¼•ï¼Œæé«˜å·¥å…·å‘ç°å’Œä½¿ç”¨æ•ˆç‡
//
// æ ¸å¿ƒæŠ€æœ¯æ ˆ:
// - db.YieldAllAITools(): è·å–æ‰€æœ‰ AI å·¥å…·
// - liteforge.Invoke(): è°ƒç”¨å·¥å…·ç”Ÿæˆç´¢å¼•
// - rag.Insert(): æ’å…¥ RAG ç´¢å¼•
// - embedding: å‘é‡åµŒå…¥æœåŠ¡
//
// æ–°ç‰¹æ€§:
// - è‡ªåŠ¨éå†æ‰€æœ‰ AI å·¥å…·
// - liteforge åŠ¨æ€ç´¢å¼•ç”Ÿæˆ
// - RAG ç³»ç»Ÿé›†æˆæœç´¢
// - è¿›åº¦è·Ÿè¸ªå’Œé”™è¯¯å¤„ç†
//
// ä½¿ç”¨ç¤ºä¾‹:
// go run common/yak/cmd/yak.go scripts/build-aitool-search-index.yak --embedding-host 127.0.0.1 --embedding-port 9099 --totp-secret my-secret --ai-api-key YOUR_KEY --ai-api-model MODEL_NAME --ai-api-domain api.example.com
// (è¾“å‡ºæ–‡ä»¶å°†è‡ªåŠ¨å‘½åä¸º aitool-search-index-{version}.rag)
//
// åº”ç”¨åœºæ™¯: AI å·¥å…·ç´¢å¼•æ„å»ºã€å·¥å…·æœç´¢ç³»ç»Ÿã€è‡ªåŠ¨åŒ–ç´¢å¼•æ›´æ–°
// å…³é”®è¯: ai-tools indexing liteforge rag-search tool-discovery
// æœç´¢æ ‡ç­¾: #ai-tools #indexing #liteforge #rag #tool-search
// =============================================================================

__DESC__ = "Build search index for AI tools using liteforge and RAG"

yakit.AutoInitYakit()

// =============================================================================
// æ‰§è¡Œè¯´æ˜
// ä½¿ç”¨ go run æ‰§è¡Œæ­¤è„šæœ¬ï¼ˆç¡®ä¿ä»£ç æœ€æ–°ï¼‰ï¼š
// go run common/yak/cmd/yak.go scripts/build-aitool-search-index.yak --embedding-host 127.0.0.1 --embedding-port 9099 --totp-secret my-secret --ai-api-key YOUR_KEY --ai-api-model MODEL_NAME --ai-api-domain api.example.com
//
// æˆ–è€…ä½¿ç”¨å·²å®‰è£…çš„ yak å‘½ä»¤ï¼š
// yak scripts/build-aitool-search-index.yak --embedding-host 127.0.0.1 --embedding-port 9099 --totp-secret my-secret --ai-api-key YOUR_KEY --ai-api-model MODEL_NAME --ai-api-domain api.example.com
//
// è¾“å‡ºæ–‡ä»¶å°†è‡ªåŠ¨å‘½åä¸ºï¼šaitool-search-index-{version}.ragï¼ˆå…¶ä¸­ {version} ä¸ºå½“å‰ yak å¼•æ“ç‰ˆæœ¬ï¼‰
// =============================================================================

// =============================================================================
// CLI å‚æ•°é…ç½®æ¨¡å— - å‘½ä»¤è¡Œæ¥å£å®šä¹‰
// åŠŸèƒ½: å®šä¹‰è„šæœ¬çš„å‘½ä»¤è¡Œå‚æ•°ï¼Œé…ç½®è¾“å‡ºè·¯å¾„ã€embedding æœåŠ¡ç­‰
// =============================================================================

// è¾“å‡º RAG æ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ï¼Œé»˜è®¤ä½¿ç”¨ç‰ˆæœ¬åŒ–å‘½åï¼‰
outputRagPath = cli.String(
    "output",
    cli.setVerboseName("è¾“å‡ºè·¯å¾„"),
    cli.setDefault(""),
    cli.setHelp("Output RAG export file path for AI tools index (default: aitool-search-index-{version}.rag)")
)

// Yak ç‰ˆæœ¬å‚æ•°ï¼ˆå¯é€‰ï¼Œé»˜è®¤è‡ªåŠ¨æ£€æµ‹ï¼‰
versionParam = cli.String(
    "version",
    cli.setVerboseName("ç‰ˆæœ¬"),
    cli.setDefault(""),
    cli.setHelp("Yak engine version (default: auto-detect)")
)

ragCollectionName = "yaklang-ai-tools"

// å…¨å±€RAGç³»ç»Ÿå˜é‡
ragSystem = nil

// å…¨å±€è®¡æ•°å™¨å˜é‡
successCount = 0
failedCount = 0
failedTools = []

// Embedding æœåŠ¡å™¨åœ°å€ï¼ˆå†…ç½®æœåŠ¡ï¼Œæ— éœ€é…ç½®ï¼‰
embeddingHost = cli.String(
    "embedding-host",
    cli.setDefault(""),
    cli.setHelp("Embedding server address (leave empty to use built-in service)")
)

// Embedding æœåŠ¡å™¨ç«¯å£ï¼ˆå†…ç½®æœåŠ¡ï¼Œæ— éœ€é…ç½®ï¼‰
embeddingPort = cli.Int(
    "embedding-port",
    cli.setDefault(0),
    cli.setHelp("Embedding server port (leave empty to use built-in service)")
)

// TOTP å¯†é’¥ï¼ˆå¯é€‰ï¼Œå¦‚æœ embedding æœåŠ¡éœ€è¦éªŒè¯ï¼‰
totpSecret = cli.String(
    "totp-secret",
    cli.setDefault(""),
    cli.setHelp("TOTP secret for embedding service authentication (optional)")
)

// è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
timeout = cli.Int(
    "timeout",
    cli.setDefault(30),
    cli.setHelp("HTTP request timeout in seconds")
)

// AI API Modelï¼ˆå¯é€‰ï¼Œç”¨äºæŒ‡å®šæ¨¡å‹ï¼‰
AIAPIModel = cli.String(
    "ai-api-model",
    cli.setDefault(""),
    cli.setHelp("AI API Model for AI service (optional, uses built-in config if not specified)")
)

// AI API Domainï¼ˆå¯é€‰ï¼‰
AIAPIDomain = cli.String(
    "ai-api-domain",
    cli.setDefault(""),
    cli.setHelp("AI API Domain for AI service (optional, uses built-in config if not specified)")
)

cli.check()

// =============================================================================
// è·å– Yak ç‰ˆæœ¬å¹¶è®¾ç½®é»˜è®¤è¾“å‡ºè·¯å¾„
// =============================================================================

// è·å–å½“å‰ Yak å¼•æ“ç‰ˆæœ¬
yakVersion = "dev"  // é»˜è®¤ç‰ˆæœ¬
if versionParam != "" {
    yakVersion = versionParam
}

log.info("Yak Engine Version: %s", yakVersion)

// å¦‚æœæ²¡æœ‰æŒ‡å®šè¾“å‡ºè·¯å¾„ï¼Œä½¿ç”¨é»˜è®¤çš„ç‰ˆæœ¬åŒ–å‘½å
if outputRagPath == "" {
    outputRagPath = sprintf("aitool-search-index-%s.rag", yakVersion)
    log.info("Using default output path: %s", outputRagPath)
}

// =============================================================================
// å‚æ•°éªŒè¯æ¨¡å—
// =============================================================================

if outputRagPath == "" {
    die("Required parameter: --output")
}

log.info("=== AI Tools Index Builder Configuration ===")
log.info("Output: %s", outputRagPath)
log.info("Collection: %s", ragCollectionName)
if embeddingHost == "" || embeddingPort == 0 {
    log.info("Embedding Service: Built-in (aibalance free)")
} else {
    log.info("Embedding Server: %s:%d", embeddingHost, embeddingPort)
}
if totpSecret != "" {
    log.info("TOTP Auth: Enabled")
} else {
    log.info("TOTP Auth: Disabled")
}
if AIAPIModel != "" {
    log.info("AI API Model: %s", AIAPIModel)
}
if AIAPIDomain != "" {
    log.info("AI API Domain: %s", AIAPIDomain)
}
log.info("Using built-in AI configuration")

// =============================================================================
// å·¥å…·å‡½æ•°å®šä¹‰
// åŠŸèƒ½: ä¿®å¤å†…ç½®å‡½æ•°çš„å·²çŸ¥é—®é¢˜
// =============================================================================

// ä¿®å¤ len å‡½æ•° - æ­£ç¡®è®¡ç®— rune æ•°é‡è€Œä¸æ˜¯ byte æ•°é‡
len = (s) => {
    n = 0
    for i in s {
        n++
    }
    return n
}

// =============================================================================
// Embedding å¤„ç†å‡½æ•°å®šä¹‰
// åŠŸèƒ½: å°è£… embedding è¯·æ±‚é€»è¾‘ï¼Œæ”¯æŒ TOTP éªŒè¯
// =============================================================================

prod_env_embeddingHandle = func(text) {
    if text == "" {
        log.error("Empty text for embedding")
        return nil
    }

    // ä¼˜åŒ–æ—¥å¿—è¾“å‡ºï¼šæ˜¾ç¤ºæ–‡æœ¬é¢„è§ˆ
    if len(text) <= 100 {
        log.info("Generating embedding for text (length: %d): %s", len(text), text)
    } else {
        preview = str.TrimSpace(text[:100])
        log.info("Generating embedding for text (length: %d), preview: %s...", len(text), preview)
    }

    // å¦‚æœé…ç½®äº† TOTPï¼Œç”ŸæˆéªŒè¯ç 
    totpCode = ""
    if totpSecret != "" {
        totpCode = twofa.GetUTCCode(totpSecret)
        currentTime = time.Now().Unix()
        log.info("Generated TOTP code: %s (timestamp: %d)", totpCode, currentTime)
    }

    // æ„å»ºè¯·æ±‚ä½“
    requestBody = json.dumps({
        "input": text,
        "model": "embedding",
    })

    // æ„å»º HTTP è¯·æ±‚
    httpRequest = sprintf(`POST /embeddings HTTP/1.1
Host: %s
Content-Type: application/json`, embeddingHost)

    // å¦‚æœæœ‰ TOTPï¼Œæ·»åŠ éªŒè¯å¤´
    if totpCode != "" {
        httpRequest = sprintf(`%s
X-TOTP-Code: %s`, httpRequest, totpCode)
    }

    httpRequest = sprintf(`%s
Content-Length: %d

%s`, httpRequest, len(requestBody), requestBody)

    // å‘é€è¯·æ±‚
    try {
        rsp, _, err = poc.HTTP(
            httpRequest,
            poc.host(embeddingHost),
            poc.port(embeddingPort),
            poc.https(true),
            poc.timeout(timeout),
        )

        if err != nil {
            log.error("Failed to send embedding request: %v", err)
            return nil
        }

        // è·å–çŠ¶æ€ç 
        statusCode = poc.GetStatusCodeFromResponse(rsp)

        if statusCode != 200 {
            log.error("Embedding request failed with status code: %d", statusCode)
            _, body = poc.Split(rsp)
            log.error("Response body: %s", string(body))
            return nil
        }

        // è§£æå“åº”
        _, body = poc.Split(rsp)
        responseData = json.loads(body)

        if responseData["data"] == nil || len(responseData["data"]) == 0 {
            log.error("No embedding data in response")
            return nil
        }

        embeddingData = responseData["data"][0]
        embedding = embeddingData["embedding"]

        log.info("Embedding generated successfully (dimension: %d)", len(embedding))
        return embedding

    } catch embeddingErr {
        log.error("Failed to generate embedding: %v", embeddingErr)
        return nil
    }
}

// å¸¦é‡è¯•çš„ embedding å¤„ç†å‡½æ•°
prod_env_embeddingHandle_with_retry = func(text) {
    maxRetries = 5
    for i = 0; i < maxRetries; i++ {
        if i > 0 {
            log.warn("ğŸ”„ [RETRY %d/%d] Retrying embedding request...", i, maxRetries-1)
        }

        result = prod_env_embeddingHandle(text)
        if result != nil {
            if i > 0 {
                log.info("âœ“ Embedding succeeded after %d retries", i)
            }
            return result
        }

        if i < maxRetries - 1 {
            // ç­‰å¾…æ—¶é—´é€’å¢ï¼šç¬¬1æ¬¡é‡è¯•ç­‰1ç§’ï¼Œç¬¬2æ¬¡ç­‰2ç§’ï¼Œç¬¬3æ¬¡ç­‰3ç§’ï¼Œç¬¬4æ¬¡ç­‰4ç§’
            // è¿™æ ·å¯ä»¥è®© TOTP æœ‰æ›´å¤§æœºä¼šåˆ‡æ¢åˆ°æ–°çš„æ—¶é—´çª—å£
            waitSeconds = i + 1
            log.warn("â³ Embedding failed, waiting %d seconds before retry...", waitSeconds)
            time.Sleep(waitSeconds)
        }
    }

    log.error("âŒ Embedding failed after %d attempts, giving up", maxRetries)
    return nil
}

embeddingHandle = prod_env_embeddingHandle_with_retry

// =============================================================================
// RAG é›†åˆåˆ›å»ºæ¨¡å—
// åŠŸèƒ½: åˆ›å»ºæ–°çš„ AI å·¥å…· RAG é›†åˆ
// =============================================================================

log.info("")
log.info("=== Step 1: Creating AI Tools RAG collection ===")

// ç§»é™¤ç°æœ‰é›†åˆ
rag.DeleteCollection(ragCollectionName)
log.info("âœ“ New RAG collection created: %s", ragCollectionName)

// =============================================================================
// åŠ è½½ RAG Collection
// åŠŸèƒ½: ä½¿ç”¨å†…ç½® embedding æœåŠ¡åŠ è½½ RAG é›†åˆ
// =============================================================================

log.info("")
log.info("=== Step 2: Loading RAG collection ===")

var err
// å¦‚æœæ²¡æœ‰æŒ‡å®šå¤–éƒ¨embeddingæœåŠ¡å™¨ï¼Œä½¿ç”¨å†…ç½®æœåŠ¡
if embeddingHost == "" || embeddingPort == 0 {
    log.info("Using built-in embedding service")
    ragSystem, err = rag.Get(ragCollectionName)
} else {
    log.info("Using external embedding service: %s:%d", embeddingHost, embeddingPort)
    ragSystem, err = rag.Get(ragCollectionName, rag.embeddingHandle(embeddingHandle))
}

if err != nil {
    log.error("Failed to load RAG collection: %v", err)
    die(sprintf("Failed to load RAG collection: %v", err))
}

log.info("âœ“ RAG collection loaded successfully: %s", ragCollectionName)

// =============================================================================
// è·å–å¹¶å¤„ç† AI å·¥å…· (å¹¶å‘ä¼˜åŒ–ç‰ˆæœ¬)
// åŠŸèƒ½: ä½¿ç”¨å¹¶å‘æ¨¡å‹éå†æ‰€æœ‰ AI å·¥å…·ï¼Œä½¿ç”¨ liteforge ç”Ÿæˆç´¢å¼•ï¼Œæ’å…¥ RAG ç³»ç»Ÿ
// =============================================================================

log.info("")
log.info("=== Step 3: Processing AI Tools (Concurrent) ===")

totalTools = 0
processedTools = 0

// é¦–å…ˆç»Ÿè®¡å·¥å…·æ€»æ•°
for ins in db.YieldAllAITools() {
    totalTools++
}

log.info("Found %d AI tools to process", totalTools)

// åˆ›å»ºå¹¶å‘æ§åˆ¶
maxConcurrency = 5  // æœ€å¤§å¹¶å‘æ•°ï¼Œå¢åŠ å¹¶å‘æå‡å¤„ç†é€Ÿåº¦
wg = sync.NewSizedWaitGroup(maxConcurrency)

log.info("Using concurrent processing with max concurrency: %d", maxConcurrency)

// å®šä¹‰å¤„ç†å•ä¸ªå·¥å…·çš„å‡½æ•°
processTool = func(toolInfo, toolIndex) {
    defer wg.Done()

    toolId = toolInfo["name"]
    toolName = toolInfo["name"]

    log.info("[%d/%d] Processing AI Tool: %s (ID: %s)", toolIndex, totalTools, toolName, toolId)

    // ä½¿ç”¨å…¨å±€å˜é‡è®¡æ•°ï¼Œä¸å†ä½¿ç”¨result map

    try {
        // æ„å»ºå·¥å…·çš„ç´¢å¼•å†…å®¹ï¼ˆåŒ…å«æè¿°ä¿¡æ¯ï¼‰
        content = sprintf("å·¥å…·åç§°: %s\n", toolName)
        if toolInfo["description"] != "" {
            content += sprintf("æè¿°: %s\n", toolInfo["description"])
        }
        if len(toolInfo["keywords"]) > 0 {
            content += sprintf("å…³é”®è¯: %s\n", str.Join(toolInfo["keywords"], ", "))
        }
        if toolInfo["verboseName"] != "" {
            content += sprintf("è¯¦ç»†åç§°: %s\n", toolInfo["verboseName"])
        }

        log.info("  Processing tool: %s (description length: %d)", toolName, len(content))

        // æ„å»ºAIé—®é¢˜ç”Ÿæˆæç¤ºï¼ˆåŒ…å«ä»£ç ä»¥è·å¾—æ›´å¥½çš„é—®é¢˜è´¨é‡ï¼‰
        questionPromptContent = content
        // å°è¯•æ·»åŠ ä»£ç å†…å®¹ï¼ˆä¸è¶…è¿‡10kå­—èŠ‚ï¼‰
        if toolInfo["content"] != "" && toolInfo["content"] != nil {
            codeContent = sprintf("\nä»£ç ç¤ºä¾‹:\n%s", toolInfo["content"])
            if len(questionPromptContent) + len(codeContent) <= 10000 {
                questionPromptContent += codeContent
                log.info("  Added code content to AI prompt (total: %d bytes)", len(questionPromptContent))
            } else {
                // å¦‚æœåŠ ä¸Šä»£ç ä¼šè¶…è¿‡10kï¼Œåªæ·»åŠ éƒ¨åˆ†ä»£ç 
                maxCodeLen = 10000 - len(questionPromptContent) - 50
                if maxCodeLen > 100 {
                    truncatedCode = sprintf("\nä»£ç ç¤ºä¾‹:\n%s...", toolInfo["content"][:maxCodeLen])
                    questionPromptContent += truncatedCode
                    log.info("  Added truncated code content to AI prompt (total: %d bytes)", len(questionPromptContent))
                }
            }
        }

        // ä½¿ç”¨AIç”Ÿæˆå·¥å…·çš„æœç´¢é—®é¢˜ç´¢å¼•
        log.info("  Generating search questions using AI...")
        questionPrompt = sprintf(`è¯·ä¸ºä»¥ä¸‹AIå·¥å…·ç”Ÿæˆ5ä¸ªæœç´¢é—®é¢˜ï¼Œè¿™äº›é—®é¢˜åº”è¯¥æ˜¯ä¸€ä¸ªç”¨æˆ·å¯èƒ½ç”¨æ¥æŸ¥æ‰¾è¿™ä¸ªå·¥å…·çš„è‡ªç„¶è¯­è¨€æŸ¥è¯¢ã€‚è¦æ±‚ï¼š
1. é—®é¢˜è¦å…·ä½“ã€å®ç”¨
2. æ¶µç›–å·¥å…·çš„ä¸»è¦åŠŸèƒ½
3. ä½¿ç”¨ä¸åŒçš„è¡¨è¿°æ–¹å¼
4. æ¯ä¸ªé—®é¢˜ä¸è¶…è¿‡50ä¸ªå­—ç¬¦

å·¥å…·ä¿¡æ¯ï¼š
%s

è¯·ä»¥JSONæ ¼å¼è¿”å›ï¼š
{
  "questions": ["é—®é¢˜1", "é—®é¢˜2", "é—®é¢˜3", "é—®é¢˜4", "é—®é¢˜5"]
}`, questionPromptContent)

        // ç¡®ä¿å†…å®¹ä¸è¶…é•¿ï¼Œé™åˆ¶åœ¨2000å­—èŠ‚ä»¥å†…
        if len(questionPrompt) > 2000 {
            questionPrompt = questionPrompt[:2000] + "..."
            log.info("  Content truncated to 2000 bytes for AI processing")
        }

        // ä½¿ç”¨liteforge.Executeç”Ÿæˆé—®é¢˜ç´¢å¼•
        schema = jsonschema.ActionObject(
            jsonschema.paramObjectArray("questions",
                jsonschema.title("ç”Ÿæˆçš„æœç´¢é—®é¢˜åˆ—è¡¨"),
                jsonschema.required(),
                jsonschema.paramString("question",
                    jsonschema.description("ç”Ÿæˆçš„æœç´¢é—®é¢˜"),
                    jsonschema.required()
                )
            )
        )

        result = liteforge.Execute(questionPrompt, liteforge.output(schema))~
        log.info("  LiteForge executed successfully, result type: %T", result)

        if result != nil {
            log.info("  AI generated questions successfully")

            // ä½¿ç”¨æ­£ç¡®çš„æ–¹æ³•è·å–ç»“æœ
            questions = result.GetInvokeParamsArray("questions")
            log.info("  Successfully extracted %d questions", len(questions))

            if questions != nil && len(questions) > 0 {
                log.info("  Generated %d questions for tool %s", len(questions), toolName)

                // å°†æ¯ä¸ªé—®é¢˜ä½œä¸ºç´¢å¼•å­˜å‚¨åˆ°RAGï¼ˆæ·»åŠ å…ƒä¿¡æ¯ï¼‰
                questionIndex = 0
                for questionObj in questions {
                    questionIndex++
                    questionText = questionObj.GetString("question")
                    indexId = sprintf("%s_q%d", toolId, questionIndex)
                    questionContent = sprintf("é—®é¢˜: %s\nå·¥å…·: %s", questionText, toolName)

                    // æ·»åŠ å…ƒä¿¡æ¯
                    metadata = [
                        rag.docMetadata("tool_name", toolName),
                        rag.docMetadata("tool_id", toolId),
                        rag.docMetadata("yak_version", yakVersion),
                        rag.docMetadata("index_type", "question"),
                        rag.docMetadata("question_text", questionText),
                        rag.docMetadata("question_index", sprintf("%d", questionIndex))
                    ]

                    err = ragSystem.Add(indexId, questionContent, metadata...)
                    if err != nil {
                        log.error("  Failed to insert question index %s: %v", indexId, err)
                    } else {
                        log.info("  âœ“ Inserted question index: %s", questionText)
                    }
                }

                // åŒæ—¶å­˜å‚¨åŸå§‹å·¥å…·æè¿°ä½œä¸ºåŸºç¡€ç´¢å¼•ï¼ˆæ·»åŠ å…ƒä¿¡æ¯ï¼‰
                baseIndexId = sprintf("%s_base", toolId)
                baseContent = sprintf("å·¥å…·åç§°: %s\næè¿°: %s\nå…³é”®è¯: %s",
                    toolName,
                    toolInfo["description"] || "æ— æè¿°",
                    str.Join(toolInfo["keywords"] || [], ", "))

                // æ·»åŠ åŸºç¡€ç´¢å¼•çš„å…ƒä¿¡æ¯
                baseMetadata = [
                    rag.docMetadata("tool_name", toolName),
                    rag.docMetadata("tool_id", toolId),
                    rag.docMetadata("yak_version", yakVersion),
                    rag.docMetadata("index_type", "base"),
                    rag.docMetadata("verbose_name", toolInfo["verboseName"] || ""),
                    rag.docMetadata("keywords", str.Join(toolInfo["keywords"] || [], ", "))
                ]

                err = ragSystem.Add(baseIndexId, baseContent, baseMetadata...)
                if err != nil {
                    log.error("  Failed to insert base index %s: %v", baseIndexId, err)
                } else {
                    log.info("  âœ“ Inserted base index for tool: %s", toolName)
                }

                log.info("âœ“ [%d/%d] Successfully processed tool: %s (%d questions generated)", toolIndex, totalTools, toolName, len(questions))
                successCount++

            } else {
                log.warn("  No valid questions generated, using fallback")
                throw("No valid questions in AI response")
            }
        } else {
            log.warn("  AI question generation failed for tool %s, using fallback", toolName)
            // å›é€€åˆ°åŸºç¡€ç´¢å¼•
            baseIndexId = sprintf("%s_base", toolId)
            baseContent = sprintf("å·¥å…·åç§°: %s\næè¿°: %s\nå…³é”®è¯: %s",
                toolName,
                toolInfo["description"] || "æ— æè¿°",
                str.Join(toolInfo["keywords"] || [], ", "))

            // æ·»åŠ åŸºç¡€ç´¢å¼•çš„å…ƒä¿¡æ¯ï¼ˆå›é€€æƒ…å†µï¼‰
            baseMetadata = [
                rag.docMetadata("tool_name", toolName),
                rag.docMetadata("tool_id", toolId),
                rag.docMetadata("yak_version", yakVersion),
                rag.docMetadata("index_type", "base_fallback"),
                rag.docMetadata("verbose_name", toolInfo["verboseName"] || ""),
                rag.docMetadata("keywords", str.Join(toolInfo["keywords"] || [], ", "))
            ]

            err = ragSystem.Add(baseIndexId, baseContent, baseMetadata...)
            if err != nil {
                log.error("  Failed to insert fallback index %s: %v", baseIndexId, err)
                log.info("âœ— [%d/%d] Failed to process tool: %s", toolIndex, totalTools, toolName)
                failedCount++
                failedTools = append(failedTools, toolName)
            } else {
                log.info("  âœ“ Inserted fallback index for tool: %s", toolName)
                log.info("âœ“ [%d/%d] Successfully processed tool with fallback: %s", toolIndex, totalTools, toolName)
                successCount++
            }
        }

    } catch processErr {
        log.error("âœ— [%d/%d] Failed to process tool %s: %v", toolIndex, totalTools, toolName, processErr)
        failedCount++
        failedTools = append(failedTools, toolName)
    }

    // å¤„ç†å®Œæˆï¼Œä¸å†éœ€è¦å‘é€ç»“æœ
}

// å¯åŠ¨å¹¶å‘å¤„ç†
toolIndex = 0
for ins in db.YieldAllAITools() {
    toolIndex++
    wg.Add(1)
    // åˆ›å»ºå·¥å…·ä¿¡æ¯çš„å‰¯æœ¬ï¼Œé¿å…å¹¶å‘è®¿é—®é—®é¢˜
    toolInfo = {
        "name": ins.Name,
        "description": ins.Description,
        "verboseName": ins.VerboseName,
        "keywords": ins.Keywords
    }
    go processTool(toolInfo, toolIndex)
}

// ç­‰å¾…æ‰€æœ‰å¹¶å‘ä»»åŠ¡å®Œæˆ
wg.Wait()

log.info("")
log.info("=== Processing Results ===")
log.info("Success: %d tools", successCount)
log.info("Failed: %d tools", failedCount)

if failedCount > 0 {
    log.warn("Failed tools:")
    for i, toolName := range failedTools {
        log.warn("  %d. %s", i+1, toolName)
    }
}

// =============================================================================
// å¯¼å‡º RAG æ–‡ä»¶
// åŠŸèƒ½: å°†æ„å»ºå¥½çš„ AI å·¥å…·ç´¢å¼• RAG å¯¼å‡ºåˆ°æ–‡ä»¶
// =============================================================================

log.info("")
log.info("=== Step 4: Exporting AI Tools RAG file ===")

try {
    err = rag.Export(ragCollectionName, outputRagPath)
    if err != nil {
        log.error("Failed to export RAG: %v", err)
        die(sprintf("Failed to export RAG to %s", outputRagPath))
    }

    // éªŒè¯å¯¼å‡ºçš„æ–‡ä»¶
    if !file.IsExisted(outputRagPath) {
        log.error("Export succeeded but file does not exist: %s", outputRagPath)
        die("Failed to verify exported RAG file")
    }

    // è·å–æ–‡ä»¶å¤§å°
    fileInfo = file.Stat(outputRagPath)~
    fileSize = fileInfo.Size()

    log.info("âœ“ AI Tools RAG file exported successfully: %s", outputRagPath)
    log.info("  File size: %d bytes (%.2f MB)", fileSize, float64(fileSize)/1024/1024)

} catch exportErr {
    log.error("Failed to export RAG: %v", exportErr)
    die(sprintf("Failed to export RAG: %v", exportErr))
}

// =============================================================================
// ç”ŸæˆæŠ¥å‘Š
// åŠŸèƒ½: ç”Ÿæˆ Markdown æ ¼å¼çš„æ„å»ºæŠ¥å‘Š
// =============================================================================

log.info("")
log.info("=== Step 5: Generating build report ===")

reportPath = str.Replace(outputRagPath, ".rag", ".build-report.md", 1)

reportLines = []
reportLines = append(reportLines, "# AI å·¥å…·ç´¢å¼•æ„å»ºæŠ¥å‘Š\n")
reportLines = append(reportLines, sprintf("**æ„å»ºæ—¶é—´**: %s\n", time.Now().Format("2006-01-02 15:04:05")))
reportLines = append(reportLines, sprintf("**Yak ç‰ˆæœ¬**: %s\n", yakVersion))
reportLines = append(reportLines, sprintf("**è¾“å‡º RAG**: %s\n", outputRagPath))
reportLines = append(reportLines, sprintf("**é›†åˆåç§°**: %s\n\n", ragCollectionName))
reportLines = append(reportLines, "## å¤„ç†ç»Ÿè®¡\n\n")
reportLines = append(reportLines, sprintf("- AI å·¥å…·æ€»æ•°: %d\n", totalTools))
reportLines = append(reportLines, sprintf("- æˆåŠŸå¤„ç†: %d\n", successCount))
reportLines = append(reportLines, sprintf("- å¤„ç†å¤±è´¥: %d\n\n", failedCount))

if successCount > 0 {
    reportLines = append(reportLines, "## æˆåŠŸå¤„ç†çš„å·¥å…·\n\n")
    idx = 1
    for ins in db.YieldAllAITools() {
        toolName = ins.Name
        isFailed := false
        for _, failedTool := range failedTools {
            if failedTool == toolName {
                isFailed = true
                break
            }
        }

        if !isFailed {
            reportLines = append(reportLines, sprintf("%d. %s\n", idx, toolName))
            idx++
        }
    }
    reportLines = append(reportLines, "\n")
}

if failedCount > 0 {
    reportLines = append(reportLines, "## å¤„ç†å¤±è´¥çš„å·¥å…·\n\n")
    for i, toolName := range failedTools {
        reportLines = append(reportLines, sprintf("%d. %s\n", i+1, toolName))
    }
    reportLines = append(reportLines, "\n")
}

reportLines = append(reportLines, "## Embedding é…ç½®\n\n")
reportLines = append(reportLines, sprintf("- æœåŠ¡å™¨: %s:%d\n", embeddingHost, embeddingPort))
if totpSecret != "" {
    reportLines = append(reportLines, "- TOTP è®¤è¯: å¯ç”¨\n")
} else {
    reportLines = append(reportLines, "- TOTP è®¤è¯: ç¦ç”¨\n")
}
reportLines = append(reportLines, sprintf("- è¶…æ—¶æ—¶é—´: %d ç§’\n\n", timeout))
reportLines = append(reportLines, "## è¾“å‡ºæ–‡ä»¶ä¿¡æ¯\n\n")
reportLines = append(reportLines, sprintf("- æ–‡ä»¶è·¯å¾„: %s\n", outputRagPath))
if file.IsExisted(outputRagPath) {
    fileInfo = file.Stat(outputRagPath)~
    fileSize = fileInfo.Size()
    reportLines = append(reportLines, sprintf("- æ–‡ä»¶å¤§å°: %d bytes (%.2f MB)\n", fileSize, float64(fileSize)/1024/1024))
}

reportContent = str.Join(reportLines, "")

// ä¿å­˜æŠ¥å‘Š
err = file.Save(reportPath, reportContent)
if err != nil {
    log.warn("Failed to write report: %v", err)
} else {
    log.info("âœ“ Build report generated: %s", reportPath)
}

// æ‰“å°æŠ¥å‘Šåˆ°æ§åˆ¶å°
println("")
println(reportContent)

// =============================================================================
// ç”Ÿæˆ JSON æŠ¥å‘Š
// åŠŸèƒ½: ç”Ÿæˆæœºå™¨å¯è¯»çš„ JSON æ ¼å¼æ„å»ºæŠ¥å‘Š
// =============================================================================

log.info("")
log.info("=== Step 6: Generating JSON report ===")

jsonReportPath = str.Replace(outputRagPath, ".rag", ".build-report.json", 1)

// è·å–è¾“å‡ºæ–‡ä»¶ä¿¡æ¯
outputFileSize = 0
if file.IsExisted(outputRagPath) {
    fileInfo = file.Stat(outputRagPath)~
    outputFileSize = fileInfo.Size()
}

// æ”¶é›†æˆåŠŸå’Œå¤±è´¥çš„å·¥å…·åˆ—è¡¨
successTools = []
for ins in db.YieldAllAITools() {
    toolName = ins.Name
    isFailed := false
    for _, failedTool := range failedTools {
        if failedTool == toolName {
            isFailed = true
            break
        }
    }
    if !isFailed {
        successTools = append(successTools, toolName)
    }
}

// æ„å»º JSON æ•°æ®ç»“æ„
jsonData = {
    "build_time": time.Now().Format("2006-01-02 15:04:05"),
    "build_timestamp": time.Now().Unix(),
    "yak_version": yakVersion,
    "status": failedCount == 0 ? "success" : "partial_failure",
    "config": {
        "output_rag": outputRagPath,
        "collection_name": ragCollectionName,
        "embedding_host": "***",
        "embedding_port": "***",
        "totp_enabled": totpSecret != "",
        "timeout": timeout,
        "ai_api_model": "***",
        "ai_api_domain": "***",
    },
    "statistics": {
        "total_tools": totalTools,
        "success_count": successCount,
        "failed_count": failedCount,
    },
    "tools": {
        "success": successTools,
        "failed": failedTools,
    },
    "output": {
        "rag_file": outputRagPath,
        "rag_file_size_bytes": outputFileSize,
        "rag_file_size_mb": sprintf("%.2f", float64(outputFileSize)/1024/1024),
        "markdown_report": reportPath,
        "json_report": jsonReportPath,
    },
}

// è½¬æ¢ä¸º JSON å­—ç¬¦ä¸²
jsonString = json.dumps(jsonData)

// ä¿å­˜ JSON æŠ¥å‘Š
err = file.Save(jsonReportPath, jsonString)
if err != nil {
    log.warn("Failed to write JSON report: %v", err)
} else {
    log.info("âœ“ JSON report generated: %s", jsonReportPath)
}

// =============================================================================
// æ€»ç»“è¾“å‡º
// =============================================================================

log.info("")
log.info("=== Build Summary ===")
log.info("âœ“ AI Tools index build completed for Yak v%s", yakVersion)
log.info("  - Total tools: %d", totalTools)
log.info("  - Success: %d tools", successCount)
log.info("  - Failed: %d tools", failedCount)
log.info("  - Output: %s", outputRagPath)
log.info("  - Report: %s", reportPath)
log.info("  - JSON Report: %s", jsonReportPath)

if failedCount > 0 {
    log.warn("âš ï¸  Some tools failed to process, please check the report")
    os.Exit(1)
} else {
    log.info("âœ“ All tools processed successfully")
    os.Exit(0)
}
