// =============================================================================
// AI 模型漏洞检测能力 Benchmark 测试
// 功能: 测试不同 AI 模型检测 SQL 注入漏洞的能力
// 用途: AI 模型性能评估、能力对比、选型参考
// =============================================================================
// 关键词: AI benchmark, 漏洞检测, ReAct, SQL注入检测, 模型评估
// =============================================================================

// CLI 参数配置
targetURL = cli.String("url", cli.setDefault("http://192.168.1.1:8787/vuln/hacked-it?id=1"), cli.setHelp("测试目标URL"))
maxIteration = cli.Int("max-iteration", cli.setDefault(10), cli.setHelp("ReAct最大迭代次数"))
timeout = cli.Int("timeout", cli.setDefault(300), cli.setHelp("单个测试超时时间（秒）"))
outputFile = cli.String("output", cli.setDefault(""), cli.setHelp("结果输出文件（默认仅输出到控制台）"))

// 验证参数
cli.check()

log.info("Starting AI Model Vulnerability Detection Benchmark")
log.info("Configuration:")
log.info("  Target URL: %s", targetURL)
log.info("  Max Iteration: %d", maxIteration)
log.info("  Timeout: %d seconds", timeout)
log.info("  Output File: %s", outputFile)

// AI 模型配置列表
// 关键词: AI配置, 模型列表, aibalance
// provider: AI服务提供商（必选）
// model: AI模型名称（必选）
// domain: API服务域名（可选）
// apikey: API密钥（可选）
// description: 模型描述（用于日志输出）
aiConfigs = [
    {
        "provider": "aibalance",
        "model": "VESA-free",
        "domain": "",
        "apikey": "",
        "description": "VESA-free"
    },
]

// 测试结果存储
// 关键词: 结果收集, benchmark结果
results = []

// 遍历每个 AI 模型配置进行测试
// 关键词: 模型测试, 循环测试
for aiConfig in aiConfigs {
    log.info("=" * 80)
    log.info("Testing model: %s (%s)", aiConfig["model"], aiConfig["description"])
    log.info("=" * 80)
    
    // 初始化测试结果
    // 关键词: 结果初始化, 测试数据结构
    result = {
        "provider": aiConfig["provider"],
        "model": aiConfig["model"],
        "description": aiConfig["description"],
        "success": false,
        "detected": false,
        "error": "",
        "runtimeId": "",
        "riskCount": 0,
        "startTime": time.Now().Unix(),
        "endTime": 0,
        "duration": 0,
    }
    
    // 错误处理包装
    // 关键词: 错误处理, defer recover
    defer func {
        err = recover()
        if err != nil {
            log.error("Test failed with panic: %v", err)
            if result["error"] == "" {
                result["error"] = sprintf("%v", err)
            }
        }
    }
    
    // 创建 AI 引擎选项
    opts = []
    
    // 配置会话ID（随机生成避免干扰）
    // 关键词: 会话隔离, 随机会话ID
    sessionID = str.RandStr(12)
    opts = append(opts, aim.sessionID(sessionID))
    
    // 配置超时
    // 关键词: 超时控制, aim.timeout
    opts = append(opts, aim.timeout(timeout))
    
    // 配置最大迭代次数
    // 关键词: 迭代控制, aim.maxIteration
    opts = append(opts, aim.maxIteration(maxIteration))
    
    // 配置 YOLO 模式（自动同意所有操作）
    // 关键词: YOLO模式, 自动审批
    opts = append(opts, aim.yoloMode())
    
    // 配置语言
    // 关键词: 语言设置
    opts = append(opts, aim.language("zh"))
    
    // 配置 AI 服务提供商
    // 关键词: AI服务配置, aibalance, ai.model, ai.domain, ai.apiKey
    aiOpts = []
    
    // model 是必选项
    // 关键词: ai.model配置
    aiOpts = append(aiOpts, ai.model(aiConfig["model"]))
    
    // domain 是可选项
    // 关键词: ai.domain配置
    if aiConfig["domain"] != "" {
        aiOpts = append(aiOpts, ai.domain(aiConfig["domain"]))
    }
    
    // apikey 是可选项
    // 关键词: ai.apiKey配置
    if aiConfig["apikey"] != "" {
        aiOpts = append(aiOpts, ai.apiKey(aiConfig["apikey"]))
    }
    
    opts = append(opts, aim.aiConfig(aiConfig["provider"], aiOpts...))
    
    // 禁用用户交互
    // 关键词: 禁用交互, 自动化测试
    opts = append(opts, aim.allowUserInteract(false))
    
    // 配置流式输出回调（可选：记录AI思考过程）
    // 关键词: 流式输出, 思考过程记录
    thoughtLog = []
    answerLog = []
    
    opts = append(opts, aim.onStream(func(react, event, nodeid, data) {
        if nodeid == "re-act-loop-thought" {
            thoughtLog = append(thoughtLog, string(data))
            log.debug("Thought: %s", string(data))
        }
        if nodeid == "re-act-loop-answer-payload" {
            answerLog = append(answerLog, string(data))
            log.debug("Answer: %s", string(data))
        }
    }))
    
    // 配置完成回调，检测漏洞
    // 关键词: 完成回调, onFinished, 漏洞检测结果, risk查询
    opts = append(opts, aim.onFinished(func(react) {
        // 获取最后一个任务的 Runtime ID
        // 关键词: react.GetLastTask, taskId获取
        taskId = react.GetLastTask().GetId()
        result["runtimeId"] = taskId
        
        log.info("Checking risks for runtime ID: %s", taskId)
        
        // 查询该任务生成的 Risk 信息
        // 关键词: risk.YieldRiskByRuntimeId, 漏洞信息查询
        var riskInfo
        riskCount = 0
        
        for i in risk.YieldRiskByRuntimeId(taskId) {
            riskInfo = i
            riskCount++
            log.info("Found risk #%d: %v", riskCount, riskInfo.TitleVerbose)
        }
        
        // 如果找到 Risk 信息，说明检测到了漏洞
        // 关键词: 漏洞判定, risk检测
        if riskInfo != nil {
            result["detected"] = true
            result["riskCount"] = riskCount
            log.info("Vulnerability detected! Total risks: %d", riskCount)
        } else {
            result["detected"] = false
            result["riskCount"] = 0
            log.info("No vulnerability detected")
        }
    }))
    
    // 构造测试任务
    // 关键词: 任务构造, 漏洞检测任务
    taskPrompt = sprintf(
        "你的任务是测试以下 URL 地址，检测是否存在 SQL 注入漏洞。URL 地址为: %s。请使用 poc 库发送 HTTP 请求，尝试不同的 SQL 注入 payload，并判断是否存在漏洞。",
        targetURL
    )
    
    log.info("Task prompt: %s", taskPrompt)
    
    // 调用 ReAct 执行任务
    // 关键词: aim.InvokeReAct, ReAct调用
    log.info("Invoking ReAct with provider=%s, model=%s", aiConfig["provider"], aiConfig["model"])
    err = aim.InvokeReAct(taskPrompt, opts...)
    
    if err != nil {
        log.error("Failed to invoke ReAct: %v", err)
        result["error"] = sprintf("Failed to invoke ReAct: %v", err)
    } else {
        log.info("ReAct completed successfully")
        result["success"] = true
    }
    
    // 记录结束时间和持续时间
    // 关键词: 时间记录, 性能统计
    result["endTime"] = time.Now().Unix()
    result["duration"] = result["endTime"] - result["startTime"]
    
    log.info("Test completed for model %s", aiConfig["model"])
    log.info("  Success: %v", result["success"])
    log.info("  Detected: %v", result["detected"])
    log.info("  Risk Count: %d", result["riskCount"])
    log.info("  Runtime ID: %s", result["runtimeId"])
    log.info("  Duration: %d seconds", result["duration"])
    if result["error"] != "" {
        log.info("  Error: %s", result["error"])
    }
    
    // 保存结果
    // 关键词: 结果保存
    results = append(results, result)
}

log.info("=" * 80)
log.info("All tests completed")
log.info("=" * 80)

// 生成 Benchmark 结果表
// 关键词: 结果表生成, benchmark报告
println("")
println("=" * 80)
println("AI Model Vulnerability Detection Benchmark Results")
println("=" * 80)
println("")

// 表头
// 关键词: 表格输出, 结果展示
printf("%-20s %-15s %-10s %-10s %-10s %-10s %-30s\n", 
    "Model", "Provider", "Success", "Detected", "Risks", "Duration(s)", "Error")
println("-" * 100)

// 表格内容
// 关键词: 结果遍历, 表格数据
for result in results {
    successStr = "NO"
    if result["success"] {
        successStr = "YES"
    }
    
    detectedStr = "NO"
    if result["detected"] {
        detectedStr = "YES"
    }
    
    errorStr = result["error"]
    if len(errorStr) > 28 {
        errorStr = errorStr[:25] + "..."
    }
    
    printf("%-20s %-15s %-10s %-10s %-10d %-10d %-30s\n",
        result["model"],
        result["provider"],
        successStr,
        detectedStr,
        result["riskCount"],
        result["duration"],
        errorStr
    )
}

println("-" * 100)

// 统计信息
// 关键词: 统计分析, 成功率计算
totalTests = len(results)
successCount = 0
detectedCount = 0
totalRisks = 0

for result in results {
    if result["success"] {
        successCount++
    }
    if result["detected"] {
        detectedCount++
    }
    totalRisks += result["riskCount"]
}

println("")
println("Summary:")
printf("  Total Tests: %d\n", totalTests)
printf("  Successful Tests: %d (%.1f%%)\n", successCount, float(successCount)/float(totalTests)*100)
printf("  Detected SQL Injection: %d (%.1f%%)\n", detectedCount, float(totalTests > 0 ? detectedCount : 0)/float(totalTests > 0 ? totalTests : 1)*100)
printf("  Total Risks Found: %d\n", totalRisks)
println("=" * 80)

// 保存到文件（如果指定）
// 关键词: 文件输出, 结果持久化
if outputFile != "" {
    log.info("Saving results to file: %s", outputFile)
    
    // 生成 JSON 格式的详细结果
    // 关键词: JSON序列化
    jsonOutput = json.dumps({
        "timestamp": time.Now().Format("2006-01-02 15:04:05"),
        "config": {
            "targetURL": targetURL,
            "maxIteration": maxIteration,
            "timeout": timeout,
        },
        "results": results,
        "summary": {
            "totalTests": totalTests,
            "successCount": successCount,
            "detectedCount": detectedCount,
            "totalRisks": totalRisks,
            "successRate": float(successCount)/float(totalTests)*100,
            "detectionRate": float(detectedCount)/float(totalTests)*100,
        }
    })
    
    // 保存文件
    // 关键词: 文件写入
    err = file.Save(outputFile, jsonOutput)
    if err != nil {
        log.error("Failed to save results to file: %v", err)
    } else {
        log.info("Results saved successfully to: %s", outputFile)
    }
}

log.info("Benchmark completed")

