#!/usr/bin/env yak

// =============================================================================
// YakScript æœç´¢ç´¢å¼•æ„å»ºå·¥å…· - Build YakScript (Plugins) Search Index
// åŠŸèƒ½: ä»æ•°æ®åº“ä¸­è·å–æ‰€æœ‰ YakScript (æ’ä»¶)ï¼Œæ„å»ºç»Ÿä¸€çš„æœç´¢ç´¢å¼•
// ç”¨é€”: ä¸ºæ‰€æœ‰ Yak æ’ä»¶æ„å»ºå¯æœç´¢çš„é—®é¢˜ç´¢å¼•ï¼Œè®©ç”¨æˆ·èƒ½é€šè¿‡è‡ªç„¶è¯­è¨€æŸ¥è¯¢æ‰¾åˆ°åˆé€‚çš„æ’ä»¶
//
// æ ¸å¿ƒè®¾è®¡:
// - ä½¿ç”¨ db.YieldYakScriptAll() è·å–æ‰€æœ‰ Yak è„šæœ¬/æ’ä»¶
// - çŸ¥è¯†æ¡ç›®ï¼ˆæ’ä»¶æè¿°ï¼‰-> å¤šä¸ªé—®é¢˜ç´¢å¼•
// - é—®é¢˜ç´¢å¼•ç”¨äºè¯­ä¹‰æœç´¢
// - æœç´¢ç»“æœé€šè¿‡ entry_id å…³è”åˆ°çŸ¥è¯†æ¡ç›®
//
// ä½¿ç”¨ç¤ºä¾‹:
// go run common/yak/cmd/yak.go scripts/build-yakscript-search-index.yak --output /tmp/plugins.rag
//
// åº”ç”¨åœºæ™¯: Yak æ’ä»¶ç´¢å¼•æ„å»ºã€æ’ä»¶æœç´¢ç³»ç»Ÿã€è‡ªåŠ¨åŒ–ç´¢å¼•æ›´æ–°
// =============================================================================

__DESC__ = "Build search index for YakScript (plugins) using BuildSearchIndexKnowledge"

yakit.AutoInitYakit()

// =============================================================================
// CLI å‚æ•°é…ç½®æ¨¡å—
// æ‰€æœ‰å‚æ•°å‡ä¸ºå¯é€‰ï¼Œé»˜è®¤ä½¿ç”¨å†…ç½®æœåŠ¡ï¼Œæ— éœ€é¢å¤–é…ç½®
// =============================================================================

// è¾“å‡º RAG æ–‡ä»¶è·¯å¾„ï¼ˆå¿…éœ€ï¼‰
outputRagPath = cli.String(
    "output",
    cli.setVerboseName("è¾“å‡ºè·¯å¾„"),
    cli.setDefault("/tmp/plugins.rag"),
    cli.setHelp("Output RAG export file path. Example: /tmp/plugins.rag")
)

// å¹¶å‘æ•°
maxConcurrency = cli.Int(
    "concurrency",
    cli.setDefault(5),
    cli.setHelp("Maximum number of concurrent processing tasks")
)

// æµ‹è¯•æ¨¡å¼ï¼šé™åˆ¶å¤„ç†çš„æ’ä»¶æ•°é‡ï¼ˆ0 è¡¨ç¤ºå¤„ç†å…¨éƒ¨ï¼‰
testLimit = cli.Int(
    "limit",
    cli.setVerboseName("æµ‹è¯•é™åˆ¶"),
    cli.setDefault(0),
    cli.setHelp("Limit the number of plugins to process (0 = all, for testing use 3)")
)

// å¼ºåˆ¶é‡å»ºï¼ˆå¿½ç•¥å·²æœ‰çš„ RAG æ–‡ä»¶ï¼‰
forceRebuild = cli.Bool(
    "force",
    cli.setVerboseName("å¼ºåˆ¶é‡å»º"),
    cli.setDefault(false),
    cli.setHelp("Force rebuild index, ignore existing RAG file")
)

// å…è®¸ nuclei-templates ä»“åº“å¯¼å…¥çš„ POCï¼ˆé»˜è®¤è¿‡æ»¤æ‰ï¼‰
allowNucleiTemplatesRepos = cli.Bool(
    "allow-nuclei-templates-repos",
    cli.setVerboseName("å…è®¸ä»“åº“ Nuclei"),
    cli.setDefault(false),
    cli.setHelp("Allow nuclei templates imported from nuclei-templates repository (default: filter out)")
)

// åŒ…å« yak åŸç”Ÿæ’ä»¶å’Œ codec ç±»å‹æ’ä»¶ï¼ˆé»˜è®¤è¿‡æ»¤æ‰ï¼‰
includeYakNativeAndCodec = cli.Bool(
    "include-yaknative-n-codec",
    cli.setVerboseName("åŒ…å«åŸç”Ÿæ’ä»¶"),
    cli.setDefault(false),
    cli.setHelp("Include yak native plugins and codec type plugins (default: filter out)")
)

cli.check()

// =============================================================================
// ç‰ˆæœ¬æ£€æµ‹å’Œè¾“å‡ºè·¯å¾„é…ç½®
// =============================================================================

// ä½¿ç”¨å†…ç½®çš„ YAK_VERSION å˜é‡è·å–ç‰ˆæœ¬
yakVersion = YAK_VERSION
if yakVersion == "" || yakVersion == undefined {
    yakVersion = "dev"
}

log.info("=== YakScript (Plugins) Search Index Builder ===")
log.info("ğŸ·ï¸  Yak Version: %s", yakVersion)

// å¤„ç†è¾“å‡ºè·¯å¾„
finalOutputPath = outputRagPath

// ç¡®ä¿ä»¥ .rag ç»“å°¾
if !str.HasSuffix(finalOutputPath, ".rag") {
    finalOutputPath = finalOutputPath + ".rag"
}

log.info("ğŸ“ Output RAG: %s", finalOutputPath)
log.info("âš¡ Concurrency: %d", maxConcurrency)
log.info("ğŸ”„ Force Rebuild: %v", forceRebuild)
if testLimit > 0 {
    log.info("ğŸ§ª Test Mode: Limiting to %d plugins", testLimit)
}
log.info("ğŸ”§ Options:")
log.info("   - Allow nuclei-templates repos: %v", allowNucleiTemplatesRepos)
log.info("   - Include yak native & codec: %v", includeYakNativeAndCodec)

// =============================================================================
// RAG ç³»ç»Ÿåˆå§‹åŒ–ï¼ˆæ”¯æŒå¢é‡æ›´æ–°ï¼‰
// =============================================================================

ragCollectionName = "yaklang-yakscript-plugins"

// æ£€æŸ¥ RAG æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼Œå†³å®šæ˜¯å¢é‡æ›´æ–°è¿˜æ˜¯å…¨æ–°æ„å»º
existingRagFile = file.IsExisted(finalOutputPath)
incrementalMode = existingRagFile && !forceRebuild

if incrementalMode {
    log.info("")
    log.info("=== Incremental Update Mode ===")
    log.info("ğŸ“‚ Found existing RAG file: %s", finalOutputPath)
    log.info("ğŸ”„ Will perform incremental update (use --force to rebuild)")
    
    // å…ˆåˆ é™¤å¯èƒ½å­˜åœ¨çš„åŒåé›†åˆï¼Œé¿å…å†²çª
    rag.DeleteCollection(ragCollectionName)
    
    // å¯¼å…¥ç°æœ‰çš„ RAG æ–‡ä»¶
    try {
        err = rag.Import(finalOutputPath, rag.importName(ragCollectionName))
        if err != nil {
            log.warn("âš ï¸  Failed to import existing RAG file: %v", err)
            log.info("ğŸ”„ Falling back to full rebuild mode")
            incrementalMode = false
            rag.DeleteCollection(ragCollectionName)
        } else {
            log.info("âœ“ Successfully imported existing RAG file")
        }
    } catch importErr {
        log.warn("âš ï¸  Failed to import existing RAG file: %v", importErr)
        log.info("ğŸ”„ Falling back to full rebuild mode")
        incrementalMode = false
        rag.DeleteCollection(ragCollectionName)
    }
} else {
    log.info("")
    log.info("=== Full Build Mode ===")
    if existingRagFile && forceRebuild {
        log.info("ğŸ”„ Force rebuild requested, ignoring existing file")
    } else {
        log.info("ğŸ“ No existing RAG file found, creating new index")
    }
    // ç§»é™¤ç°æœ‰é›†åˆ
    rag.DeleteCollection(ragCollectionName)
}

log.info("")
log.info("=== Initializing RAG System ===")

ragSystem, err = rag.Get(ragCollectionName)
if err != nil {
    log.error("âŒ Failed to initialize RAG system: %v", err)
    die(sprintf("Failed to initialize RAG system: %v", err))
}

log.info("âœ“ RAG system initialized successfully")
log.info("   ğŸ“š Collection name: %s", ragCollectionName)

// è·å–ç°æœ‰æ–‡æ¡£æ•°é‡
existingDocCount = 0
try {
    existingDocCount, _ = ragSystem.CountDocuments()
    log.info("   ğŸ“Š Existing documents: %d", existingDocCount)
} catch countErr {
    log.debug("Failed to count existing documents: %v", countErr)
}

// =============================================================================
// é¢„åŠ è½½å·²å­˜åœ¨çš„çŸ¥è¯†æ¡ç›®ï¼ˆç”¨äºå¿«é€Ÿå»é‡æ£€æŸ¥ï¼‰
// =============================================================================

// ä¸€æ¬¡æ€§é¢„åŠ è½½æ‰€æœ‰å·²å­˜åœ¨çš„çŸ¥è¯†æ¡ç›®çš„ KnowledgeTitle
// å­˜å‚¨åœ¨å†…å­˜ map ä¸­ï¼Œç”¨äº O(1) å¿«é€ŸæŸ¥æ‰¾
existingKnowledgeTitles = {}  // map[string]bool

// é¢„åŠ è½½å‡½æ•° - ä¸€æ¬¡æ€§è·å–æ‰€æœ‰å·²å­˜åœ¨çš„çŸ¥è¯†æ¡ç›®ï¼ˆä½¿ç”¨ DISTINCT é«˜æ•ˆæŸ¥è¯¢ï¼‰
preloadExistingKnowledge = func() {
    if !incrementalMode {
        return
    }
    
    log.info("ğŸ“‹ Preloading existing knowledge titles (using DISTINCT query)...")
    preloadStart = time.Now()
    
    try {
        // ä½¿ç”¨ DBQueryUniqueKnowledgeTitles ç›´æ¥è·å–å”¯ä¸€æ ‡é¢˜ï¼ˆSQL DISTINCTï¼Œé«˜æ•ˆï¼‰
        titles, err = rag.DBQueryUniqueKnowledgeTitles(rag.dbQueryCollection(ragCollectionName), rag.dbQueryLimit(50000))
        if err != nil {
            log.warn("Failed to preload knowledge titles: %v", err)
            return
        }
        
        // å­˜å‚¨åˆ° map ä¸­
        for _, title := range titles {
            if title != "" {
                existingKnowledgeTitles[title] = true
            }
        }
        
        preloadElapsed = time.Since(preloadStart)
        log.info("âœ“ Preloaded %d unique knowledge titles in %v", len(existingKnowledgeTitles), preloadElapsed)
    } catch preloadErr {
        log.warn("Failed to preload knowledge titles: %v", preloadErr)
    }
}

// å¿«é€Ÿæ£€æŸ¥æ’ä»¶æ˜¯å¦å·²å­˜åœ¨ï¼ˆä½¿ç”¨é¢„åŠ è½½çš„ mapï¼ŒO(1) æŸ¥æ‰¾ï¼‰
checkPluginExists = func(scriptName) {
    if !incrementalMode {
        return false
    }
    
    // ç›´æ¥ä»å†…å­˜ map æŸ¥æ‰¾ï¼ŒO(1) å¤æ‚åº¦ï¼Œçº³ç§’çº§
    if scriptName in existingKnowledgeTitles {
        return true
    }
    
    return false
}

// =============================================================================
// è¿‡æ»¤å‡½æ•°ï¼šè·³è¿‡å†…éƒ¨æ’ä»¶ã€mock å’Œæµ‹è¯•æ’ä»¶
// =============================================================================

// åŸºäºåç§°çš„è¿‡æ»¤
shouldSkipByName = func(name) {
    lowerName = str.ToLower(name)
    // è¿‡æ»¤ mock_ å¼€å¤´çš„æ’ä»¶ï¼ˆæµ‹è¯•ç”¨ï¼‰
    if str.HasPrefix(lowerName, "mock_") {
        return true
    }
    // è¿‡æ»¤åŒ…å« mock çš„æ’ä»¶
    if str.Contains(lowerName, "mock") {
        return true
    }
    // è¿‡æ»¤ sleep æ’ä»¶ï¼ˆæµ‹è¯•ç”¨ï¼‰
    if lowerName == "sleep" || str.HasPrefix(lowerName, "sleep_") {
        return true
    }
    // è¿‡æ»¤ test_ å¼€å¤´çš„æ’ä»¶
    if str.HasPrefix(lowerName, "test_") {
        return true
    }
    // è¿‡æ»¤åŒ…å« test çš„æ’ä»¶
    if str.Contains(lowerName, "test") {
        return true
    }
    return false
}

// åŸºäºæ’ä»¶å±æ€§çš„è¿‡æ»¤ï¼ˆå†…éƒ¨æ’ä»¶ï¼‰
shouldSkipByAttribute = func(ins) {
    // è¿‡æ»¤è¢«æ ‡è®°ä¸ºå¿½ç•¥çš„æ’ä»¶ï¼ˆå†…éƒ¨æ’ä»¶ï¼Œä¸å¸Œæœ›è¢«æœ¬åœ°æ’ä»¶åº“æŸ¥çœ‹åˆ°ï¼‰
    if ins.Ignored {
        return true, "Ignored=true (internal plugin)"
    }
    // è¿‡æ»¤å†å²è®°å½•æ’ä»¶
    if ins.IsHistory {
        return true, "IsHistory=true (history record)"
    }
    // è¿‡æ»¤å¼ºåˆ¶äº¤äº’æ¨¡å¼çš„æ’ä»¶ï¼ˆä¸èƒ½ä½œä¸ºæ¨¡å—ä½¿ç”¨ï¼‰
    if ins.ForceInteractive {
        return true, "ForceInteractive=true (interactive only)"
    }
    return false, ""
}

// åŸºäºæ’ä»¶ç±»å‹çš„è¿‡æ»¤ï¼ˆyak åŸç”Ÿæ’ä»¶å’Œ codec æ’ä»¶ï¼‰
// è¿™äº›æ’ä»¶ä¸åƒå…¶ä»–æ’ä»¶å¯ä»¥ä½¿ç”¨å›ºå®šè¾“å…¥æ¥æµ‹è¯•
shouldSkipByType = func(scriptType) {
    if !includeYakNativeAndCodec {
        if scriptType == "yak" {
            return true, "Type=yak (native plugin, use --include-yaknative-n-codec to include)"
        }
        if scriptType == "codec" {
            return true, "Type=codec (codec plugin, use --include-yaknative-n-codec to include)"
        }
    }
    return false, ""
}

// åˆ¤æ–­ nuclei è„šæœ¬æ˜¯å¦ä» nuclei-templates ä»“åº“å¯¼å…¥
// ç‰¹å¾ï¼šFromLocal=true, IsExternal=true, ä¸”æ²¡æœ‰çº¿ä¸Š UUID/OnlineId
isNucleiFromTemplatesRepo = func(ins) {
    if ins.Type != "nuclei" {
        return false
    }
    // ä» nuclei-templates ä»“åº“å¯¼å…¥çš„ç‰¹å¾ï¼š
    // 1. FromLocal = trueï¼ˆæœ¬åœ°å¯¼å…¥ï¼‰
    // 2. IsExternal = trueï¼ˆå¤–éƒ¨å¯¼å…¥ï¼‰
    // 3. Uuid ä¸ºç©º æˆ– OnlineId = 0ï¼ˆæ²¡æœ‰çº¿ä¸Šä¿¡æ¯ï¼‰
    if ins.FromLocal && ins.IsExternal {
        uuid = ins.Uuid || ""
        onlineId = ins.OnlineId || 0
        if uuid == "" || onlineId == 0 {
            return true
        }
    }
    return false
}

// åŸºäº nuclei æ¥æºçš„è¿‡æ»¤ï¼ˆä»“åº“å¯¼å…¥çš„ nuclei æ¨¡æ¿ï¼‰
shouldSkipNucleiFromRepo = func(ins) {
    if !allowNucleiTemplatesRepos {
        if isNucleiFromTemplatesRepo(ins) {
            return true, "Nuclei from templates repo (use --allow-nuclei-templates-repos to include)"
        }
    }
    return false, ""
}

// =============================================================================
// è·å– YakScript åˆ—è¡¨
// =============================================================================

log.info("")
log.info("=== Loading YakScript (Plugins) ===")

candidateItems = []  // å€™é€‰é¡¹ï¼ˆé€šè¿‡åŸºæœ¬è¿‡æ»¤çš„ï¼‰
skippedCount = 0
skippedByNameCount = 0
skippedByAttrCount = 0
skippedByTypeCount = 0
skippedByNucleiRepoCount = 0

// è·³è¿‡åŸå› ç»Ÿè®¡
skipReasons = {}

// ç¬¬ä¸€é˜¶æ®µï¼šå¿«é€Ÿæ”¶é›†æ‰€æœ‰å€™é€‰æ’ä»¶ï¼ˆä¸æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ï¼‰
log.info("ğŸ“‹ Phase 1: Collecting candidate plugins (fast filtering)...")
collectStartTime = time.Now()

for ins in db.YieldYakScriptAll() {
    scriptName = ins.ScriptName || ""
    scriptType = ins.Type || "unknown"
    
    // åŸºäºåç§°çš„è¿‡æ»¤ï¼ˆmock å’Œ test ç›¸å…³çš„æ’ä»¶ï¼‰
    if shouldSkipByName(scriptName) {
        skippedCount++
        skippedByNameCount++
        continue
    }
    
    // åŸºäºå±æ€§çš„è¿‡æ»¤ï¼ˆå†…éƒ¨æ’ä»¶ï¼‰
    shouldSkip, skipReason = shouldSkipByAttribute(ins)
    if shouldSkip {
        skippedCount++
        skippedByAttrCount++
        if skipReason in skipReasons {
            skipReasons[skipReason] = skipReasons[skipReason] + 1
        } else {
            skipReasons[skipReason] = 1
        }
        continue
    }
    
    // åŸºäºç±»å‹çš„è¿‡æ»¤ï¼ˆyak åŸç”Ÿæ’ä»¶å’Œ codec æ’ä»¶ï¼‰
    shouldSkip, skipReason = shouldSkipByType(scriptType)
    if shouldSkip {
        skippedCount++
        skippedByTypeCount++
        if skipReason in skipReasons {
            skipReasons[skipReason] = skipReasons[skipReason] + 1
        } else {
            skipReasons[skipReason] = 1
        }
        continue
    }
    
    // åŸºäº nuclei æ¥æºçš„è¿‡æ»¤ï¼ˆä»“åº“å¯¼å…¥çš„ nuclei æ¨¡æ¿ï¼‰
    shouldSkip, skipReason = shouldSkipNucleiFromRepo(ins)
    if shouldSkip {
        skippedCount++
        skippedByNucleiRepoCount++
        if skipReason in skipReasons {
            skipReasons[skipReason] = skipReasons[skipReason] + 1
        } else {
            skipReasons[skipReason] = 1
        }
        continue
    }
    
    // å°è£…ä¸ºç»Ÿä¸€æ ¼å¼
    item = {
        "script_name": scriptName,
        "type": scriptType,
        "help": ins.Help || "",
        "tags": ins.Tags || "",
        "author": ins.Author || "",
        "level": ins.Level || "",
        "content": ins.Content || "",
        "is_general_module": ins.IsGeneralModule,
        "general_module_verbose": ins.GeneralModuleVerbose || "",
    }
    candidateItems = append(candidateItems, item)
}

collectElapsed = time.Since(collectStartTime)
log.info("âœ“ Collected %d candidate plugins in %v", len(candidateItems), collectElapsed)
log.info("   â­ï¸  Skipped by filters: %d", skippedCount)

// ç¬¬äºŒé˜¶æ®µï¼šé¢„åŠ è½½å¹¶æ£€æŸ¥å·²å­˜åœ¨çš„æ¡ç›®ï¼ˆå¢é‡æ›´æ–°æ¨¡å¼ï¼‰
allItems = []
skippedByExistsCount = 0
typeStats = {}

if incrementalMode && len(candidateItems) > 0 {
    // ä¸€æ¬¡æ€§é¢„åŠ è½½æ‰€æœ‰å·²å­˜åœ¨çš„çŸ¥è¯†æ¡ç›®åˆ°å†…å­˜
    preloadExistingKnowledge()
    
    log.info("")
    log.info("ğŸ“‹ Phase 2: Filtering existing entries (O(1) memory lookup)...")
    checkStartTime = time.Now()
    
    // ä½¿ç”¨é¢„åŠ è½½çš„ map è¿›è¡Œå¿«é€Ÿ O(1) æ£€æŸ¥
    for _, item := range candidateItems {
        scriptName = item["script_name"]
        
        if checkPluginExists(scriptName) {
            skippedByExistsCount++
            continue
        }
        
        // æµ‹è¯•æ¨¡å¼é™åˆ¶
        if testLimit > 0 && len(allItems) >= testLimit {
            continue
        }
        
        // ç»Ÿè®¡ç±»å‹
        scriptType = item["type"]
        if scriptType in typeStats {
            typeStats[scriptType] = typeStats[scriptType] + 1
        } else {
            typeStats[scriptType] = 1
        }
        
        allItems = append(allItems, item)
    }
    
    checkElapsed = time.Since(checkStartTime)
    log.info("âœ“ Existence check completed in %v (for %d candidates)", checkElapsed, len(candidateItems))
} else {
    // éå¢é‡æ¨¡å¼æˆ–æ— å€™é€‰é¡¹ï¼Œç›´æ¥ä½¿ç”¨æ‰€æœ‰å€™é€‰é¡¹
    for _, item := range candidateItems {
        if testLimit > 0 && len(allItems) >= testLimit {
            break
        }
        
        scriptType = item["type"]
        if scriptType in typeStats {
            typeStats[scriptType] = typeStats[scriptType] + 1
        } else {
            typeStats[scriptType] = 1
        }
        
        allItems = append(allItems, item)
    }
}

scriptCount = len(allItems)

log.info("")
log.info("âœ“ Found %d new YakScript plugins to process", scriptCount)
log.info("   â­ï¸  Skipped total: %d", skippedCount + skippedByExistsCount)
log.info("      - By name (mock/test): %d", skippedByNameCount)
log.info("      - By attribute (internal): %d", skippedByAttrCount)
log.info("      - By type (yak/codec): %d", skippedByTypeCount)
log.info("      - By nuclei repo source: %d", skippedByNucleiRepoCount)
if incrementalMode {
    log.info("   âœ“ Already indexed: %d", skippedByExistsCount)
}

// æ‰“å°è·³è¿‡åŸå› ç»Ÿè®¡
if len(skipReasons) > 0 {
    log.info("")
    log.info("=== Skip Reasons (by attribute) ===")
    for reason, count := range skipReasons {
        log.info("   ğŸš« %s: %d", reason, count)
    }
}

// æ‰“å°ç±»å‹ç»Ÿè®¡
log.info("")
log.info("=== Plugin Type Statistics ===")
for t, count := range typeStats {
    log.info("   ğŸ“¦ %s: %d", t, count)
}

if testLimit > 0 {
    log.info("")
    log.info("ğŸ§ª Test Mode: Only processing first %d plugins", testLimit)
}

totalCount = len(allItems)
log.info("")
log.info("ğŸ“Š Total new items to process: %d", totalCount)

if totalCount == 0 {
    if incrementalMode {
        log.info("âœ“ All plugins are already indexed, nothing to update")
        // ç›´æ¥å¯¼å‡ºç°æœ‰æ•°æ®
        try {
            err = rag.Export(ragCollectionName, finalOutputPath)
            if err != nil {
                log.error("âŒ Failed to export RAG file: %v", err)
                die(sprintf("Failed to export RAG file: %v", err))
            }
            log.info("âœ“ RAG file exported (no changes): %s", finalOutputPath)
        } catch exportErr {
            log.error("âŒ Failed to export RAG file: %v", exportErr)
            die(sprintf("Failed to export RAG file: %v", exportErr))
        }
        os.Exit(0)
    } else {
        log.warn("âš ï¸  No YakScript plugins found in database")
        die("No items to process")
    }
}

// =============================================================================
// å¹¶å‘å¤„ç†è®¾ç½®
// =============================================================================

wg = sync.NewSizedWaitGroup(maxConcurrency)
resultsChan = make(chan map[string]any, totalCount)

// ç»Ÿè®¡å˜é‡
totalQuestions = 0
questionsMutex = sync.NewMutex()

// å¤„ç†å•ä¸ªé¡¹ç›®çš„å‡½æ•°
processItem = func(itemIndex, totalItems, itemInfo) {
    defer wg.Done()

    scriptName = itemInfo["script_name"]
    scriptType = itemInfo["type"]
    help = itemInfo["help"]
    tags = itemInfo["tags"]
    author = itemInfo["author"]
    level = itemInfo["level"]
    content = itemInfo["content"]
    isGeneralModule = itemInfo["is_general_module"]
    generalModuleVerbose = itemInfo["general_module_verbose"]

    result = {
        "script_name": scriptName,
        "type": scriptType,
        "help": help,
        "success": false,
        "error": nil,
        "questions_generated": 0,
    }

    try {
        log.info("")
        log.info("========================================")
        log.info("ğŸ”Œ [%d/%d] Processing: %s", itemIndex, totalItems, scriptName)
        log.info("   ğŸ†” Name: %s", scriptName)
        log.info("   ğŸ“¦ Type: %s", scriptType)
        if help != "" {
            helpPreview = help
            if len(helpPreview) > 100 {
                helpPreview = helpPreview[:100] + "..."
            }
            log.info("   ğŸ“‹ Help: %s", helpPreview)
        }
        if tags != "" {
            log.info("   ğŸ·ï¸  Tags: %s", tags)
        }
        if author != "" {
            log.info("   ğŸ‘¤ Author: %s", author)
        }
        log.info("----------------------------------------")

        // æ„å»ºæè¿°æ–‡æœ¬ï¼ˆä½œä¸ºçŸ¥è¯†æ¡ç›®å†…å®¹ï¼‰
        typeDescription = getTypeDescription(scriptType)
        
        itemDescription = sprintf(`æ’ä»¶åç§°: %s
æ’ä»¶ç±»å‹: %s (%s)
åŠŸèƒ½æè¿°: %s
æ ‡ç­¾: %s
ä½œè€…: %s
å®‰å…¨ç­‰çº§: %s

è¿™æ˜¯ä¸€ä¸ª Yaklang %s ç±»å‹çš„æ’ä»¶ï¼Œå¯ä»¥ç”¨äº:
- %s

ä½¿ç”¨åœºæ™¯:
- å®‰å…¨æµ‹è¯•å’Œæ¼æ´è¯„ä¼°
- è‡ªåŠ¨åŒ–æ¸—é€æµ‹è¯•ä»»åŠ¡
- é›†æˆåˆ° Yaklang å®‰å…¨æµ‹è¯•æ¡†æ¶
- MITM ä»£ç†æµ‹è¯•å’Œæµé‡åˆ†æ`,
            scriptName,
            scriptType,
            typeDescription,
            help || "å®‰å…¨æµ‹è¯•ä»»åŠ¡",
            tags,
            author,
            level,
            typeDescription,
            help || "å®‰å…¨æµ‹è¯•ä»»åŠ¡")

        // å¦‚æœæ˜¯é€šç”¨æ¨¡å—ï¼Œæ·»åŠ é¢å¤–ä¿¡æ¯
        if isGeneralModule && generalModuleVerbose != "" {
            itemDescription = itemDescription + sprintf("\n\né€šç”¨æ¨¡å—åç§°: %s", generalModuleVerbose)
        }

        log.info("   ğŸ”¨ Step 1: Building search index...")
        log.info("   ğŸ“ Description length: %d bytes", len(itemDescription))

        // AI èƒ½åŠ›åœºæ™¯çš„ extraPrompt - å¼ºåŒ–æ’ä»¶æ„å›¾è¯†åˆ«
        pluginExtraPrompt = sprintf(`
ã€Yak æ’ä»¶æœç´¢åœºæ™¯å¼ºåŒ–è¯´æ˜ã€‘
è¿™æ˜¯ä¸€ä¸ª Yaklang %s ç±»å‹çš„å®‰å…¨æ’ä»¶ï¼Œç”¨äºå®‰å…¨æµ‹è¯•ã€è‡ªåŠ¨åŒ–ä»»åŠ¡ã€æ¼æ´æ£€æµ‹ç­‰åœºæ™¯ã€‚

ç”Ÿæˆé—®é¢˜æ—¶ï¼Œè¯·ç‰¹åˆ«å…³æ³¨ï¼š
1. ç”¨æˆ·å¯èƒ½ç”¨ä»€ä¹ˆè‡ªç„¶è¯­è¨€æè¿°æ¥æ‰¾åˆ°è¿™ä¸ªæ’ä»¶ï¼Ÿï¼ˆå¦‚ï¼š"æˆ‘æƒ³æ‰«æ SQL æ³¨å…¥" â†’ SQL æ³¨å…¥æ£€æµ‹æ’ä»¶ï¼‰
2. ç”¨æˆ·å¯èƒ½é‡åˆ°ä»€ä¹ˆå®‰å…¨é—®é¢˜éœ€è¦è¿™ä¸ªæ’ä»¶ï¼Ÿï¼ˆå¦‚ï¼š"å¦‚ä½•æ£€æµ‹ XSS æ¼æ´ï¼Ÿ" â†’ XSS æ‰«ææ’ä»¶ï¼‰
3. ç”¨æˆ·å¯èƒ½æœ‰ä»€ä¹ˆæ¸—é€æµ‹è¯•éœ€æ±‚ï¼Ÿï¼ˆå¦‚ï¼š"æ£€æµ‹ç½‘ç«™æ¼æ´" â†’ æ¼æ´æ‰«ææ’ä»¶ï¼‰
4. ä½¿ç”¨åœºæ™¯æè¿°ï¼ˆå¦‚ï¼š"éœ€è¦åˆ†æ HTTP æµé‡" â†’ MITM æ’ä»¶ï¼‰

é—®é¢˜åº”è¯¥è¦†ç›–ï¼š
- åœºæ™¯æ„å›¾æè¿°ï¼ˆ"æˆ‘æƒ³è¦..."ã€"éœ€è¦..."ï¼‰
- åŠŸèƒ½æŸ¥è¯¢ï¼ˆ"æœ‰ä»€ä¹ˆæ’ä»¶å¯ä»¥..."ã€"æœ‰ä»€ä¹ˆè„šæœ¬å¯ä»¥..."ï¼‰
- é—®é¢˜è§£å†³ï¼ˆ"å¦‚ä½•..."ã€"æ€ä¹ˆ..."ï¼‰
- æ’ä»¶æ¨èï¼ˆ"ç”¨ä»€ä¹ˆæ’ä»¶..."ã€"æ¨èä¸€ä¸ª..."ï¼‰
- æ¼æ´æ£€æµ‹ï¼ˆ"æ£€æµ‹..."ã€"æ‰«æ..."ï¼‰
`, typeDescription)

        // ä½¿ç”¨ BuildSearchIndexKnowledge æ„å»ºæœç´¢ç´¢å¼•
        // ä¼ å…¥ search_type å’Œ search_target ä½œä¸ºçŸ¥è¯†æ¡ç›®çš„å…ƒæ•°æ®
        // search_type: æ’ä»¶ç±»å‹æè¿°ï¼Œsearch_target: æ’ä»¶åç§°
        // ä½¿ç”¨ noPotentialQuestions å‹ç¼©å­˜å‚¨å¤§å°
        log.info("   ğŸ¤– Step 2: Calling AI to generate search questions...")
        searchTypeDesc = sprintf("Yakæ’ä»¶[%s]", typeDescription)
        searchResult, buildErr = rag.BuildSearchIndexKnowledge(
            ragCollectionName, 
            itemDescription, 
            rag.extraPrompt(pluginExtraPrompt),
            rag.setSearchMeta(searchTypeDesc, scriptName),
            rag.noPotentialQuestions()
        )
        if buildErr != nil {
            log.error("   âŒ Failed to build search index: %v", buildErr)
            log.error("   âŒ Error details: script=%s, type=%s, desc_len=%d", scriptName, scriptType, len(itemDescription))
            result["error"] = buildErr
            resultsChan <- result
            return
        }

        // æ‰“å°ç”Ÿæˆçš„é—®é¢˜
        questionsGenerated = len(searchResult.Questions)
        log.info("   âœ… Step 3: AI generated %d question indexes", questionsGenerated)
        log.info("   ğŸ“‹ Knowledge Entry ID: %s", searchResult.EntryID)
        log.info("   ğŸ“š Generated questions:")
        for i, q := range searchResult.Questions {
            log.info("      ğŸ”¸ Q%d: %s", i+1, q)
        }

        // æ›´æ–°å…¨å±€è®¡æ•°
        questionsMutex.Lock()
        totalQuestions += questionsGenerated
        questionsMutex.Unlock()

        log.info("   âœ“ Successfully indexed plugin: %s (entry_id: %s)", scriptName, searchResult.EntryID)
        
        result["success"] = true
        result["questions_generated"] = questionsGenerated
        result["entry_id"] = searchResult.EntryID

    } catch processErr {
        log.error("   âŒ Unexpected error: %v", processErr)
        result["error"] = sprintf("%v", processErr)
    }

    resultsChan <- result
}

// è·å–æ’ä»¶ç±»å‹çš„ä¸­æ–‡æè¿°
getTypeDescription = func(scriptType) {
    typeMap = {
        "yak": "Yak è„šæœ¬",
        "mitm": "MITM ä»£ç†æ’ä»¶",
        "port-scan": "ç«¯å£æ‰«ææ’ä»¶",
        "nuclei": "Nuclei æ¼æ´æ¨¡æ¿",
        "codec": "ç¼–è§£ç æ’ä»¶",
        "packet-hack": "æ•°æ®åŒ…å¤„ç†æ’ä»¶",
        "payload": "Payload ç”Ÿæˆæ’ä»¶",
        "poc": "PoC æ¼æ´æ£€æµ‹æ’ä»¶",
        "fuzzer": "æ¨¡ç³Šæµ‹è¯•æ’ä»¶",
    }
    if scriptType in typeMap {
        return typeMap[scriptType]
    }
    return scriptType + " æ’ä»¶"
}

// =============================================================================
// å¹¶å‘å¤„ç† YakScript æ’ä»¶
// =============================================================================

log.info("")
log.info("=== Processing YakScript Plugins (Concurrent, max %d) ===", maxConcurrency)

// å¯åŠ¨å¹¶å‘å¤„ç†
for i, itemInfo := range allItems {
    wg.Add(1)
    go processItem(i+1, totalCount, itemInfo)
}

// ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
wg.Wait()
close(resultsChan)

// æ”¶é›†ç»“æœ
successCount = 0
failedCount = 0
failedItems = []
totalQuestionsFromResults = 0

// æŒ‰ç±»å‹ç»Ÿè®¡æˆåŠŸæ•°
successTypeStats = {}

for result := range resultsChan {
    if result["success"] {
        successCount++
        totalQuestionsFromResults += result["questions_generated"]
        scriptType = result["type"]
        if scriptType in successTypeStats {
            successTypeStats[scriptType] = successTypeStats[scriptType] + 1
        } else {
            successTypeStats[scriptType] = 1
        }
    } else {
        failedCount++
        failedItems = append(failedItems, sprintf("%s (%s)", result["script_name"], result["type"]))
    }
}

log.info("")
log.info("=== Processing Results ===")
log.info("ğŸ“Š Total new items: %d", totalCount)
log.info("âœ“ Total successful: %d", successCount)
log.info("âœ— Total failed: %d", failedCount)
log.info("ğŸ“š Total questions generated: %d", totalQuestions)

// æ‰“å°æŒ‰ç±»å‹çš„æˆåŠŸç»Ÿè®¡
log.info("")
log.info("=== Success by Type ===")
for t, count := range successTypeStats {
    log.info("   âœ“ %s: %d", t, count)
}

if incrementalMode {
    log.info("")
    log.info("=== Incremental Update Summary ===")
    log.info("   ğŸ“Š Previously indexed: %d documents", existingDocCount)
    log.info("   âœ“ Skipped (already exists): %d plugins", skippedByExistsCount)
    log.info("   â• Newly added: %d plugins", successCount)
}

if failedCount > 0 {
    log.warn("Failed items:")
    for i, itemName := range failedItems {
        log.warn("  %d. %s", i+1, itemName)
    }
}

// =============================================================================
// è·å–æœ€ç»ˆæ–‡æ¡£æ•°é‡
// =============================================================================

log.info("")
log.info("=== Final Statistics ===")

finalDocCount = 0
try {
    finalDocCount, _ = ragSystem.CountDocuments()
    log.info("ğŸ“Š Final document count: %d", finalDocCount)
    if incrementalMode {
        log.info("   - Previous documents: %d", existingDocCount)
        log.info("   - New documents added: %d", finalDocCount - existingDocCount)
    } else {
        log.info("   - Knowledge entries: %d", successCount)
        log.info("   - Question indexes: %d", totalQuestions)
    }
} catch countErr {
    log.warn("âš ï¸  Failed to get document count: %v", countErr)
}

// =============================================================================
// å¯¼å‡º RAG æ–‡ä»¶
// =============================================================================

log.info("")
log.info("=== Exporting RAG File ===")

try {
    err = rag.Export(ragCollectionName, finalOutputPath)
    if err != nil {
        log.error("âŒ Failed to export RAG file: %v", err)
        die(sprintf("Failed to export RAG file: %v", err))
    }

    if !file.IsExisted(finalOutputPath) {
        log.error("âŒ Export succeeded but file does not exist: %s", finalOutputPath)
        die("Failed to verify exported RAG file")
    }

    fileInfo = file.Stat(finalOutputPath)~
    fileSize = fileInfo.Size()

    log.info("âœ“ RAG file exported: %s", finalOutputPath)
    log.info("   ğŸ“ File size: %d bytes (%.2f MB)", fileSize, float64(fileSize)/1024/1024)

} catch exportErr {
    log.error("âŒ Failed to export RAG file: %v", exportErr)
    die(sprintf("Failed to export RAG file: %v", exportErr))
}

// =============================================================================
// ç”Ÿæˆæ„å»ºæŠ¥å‘Š
// =============================================================================

log.info("")
log.info("=== Generating Build Report ===")

reportPath = str.Replace(finalOutputPath, ".rag", ".build-report.md", 1)

report = sprintf("# YakScript æ’ä»¶æœç´¢ç´¢å¼•æ„å»ºæŠ¥å‘Š\n\n")
report += sprintf("**æ„å»ºæ—¶é—´**: %s\n\n", time.Now().Format("2006-01-02 15:04:05"))
report += sprintf("**Yak ç‰ˆæœ¬**: %s\n\n", yakVersion)
report += sprintf("**RAG æ–‡ä»¶**: %s\n\n", finalOutputPath)
report += sprintf("**é›†åˆåç§°**: %s\n\n", ragCollectionName)
report += sprintf("**æ„å»ºæ¨¡å¼**: %s\n\n", incrementalMode ? "å¢é‡æ›´æ–°" : "å…¨é‡æ„å»º")

report += "## ç´¢å¼•ç»“æ„\n\n"
report += "æœ¬ç´¢å¼•é‡‡ç”¨ **çŸ¥è¯†æ¡ç›® -> å¤šé—®é¢˜ç´¢å¼•** çš„ç»“æ„ï¼š\n\n"
report += "- **çŸ¥è¯†æ¡ç›® (knowledge_entry)**: å­˜å‚¨æ’ä»¶çš„å®Œæ•´æè¿°ä¿¡æ¯\n"
report += "- **é—®é¢˜ç´¢å¼• (question_index)**: æ¯ä¸ªçŸ¥è¯†æ¡ç›®å¯¹åº”å¤šä¸ªæœç´¢é—®é¢˜\n"
report += "- é—®é¢˜ç´¢å¼•é€šè¿‡ `entry_id` å…³è”åˆ°çŸ¥è¯†æ¡ç›®\n\n"

report += "## æ•°æ®æ¥æº\n\n"
report += sprintf("æœ¬ç´¢å¼•åŒ…å« `db.YieldYakScriptAll()` è¿”å›çš„æ‰€æœ‰ Yak è„šæœ¬/æ’ä»¶ã€‚\n\n")

report += "## æ’ä»¶ç±»å‹ç»Ÿè®¡\n\n"
report += "| ç±»å‹ | æ€»æ•° | æˆåŠŸå¤„ç† |\n"
report += "|------|------|----------|\n"
for t, count := range typeStats {
    successNum = 0
    if t in successTypeStats {
        successNum = successTypeStats[t]
    }
    report += sprintf("| %s | %d | %d |\n", t, count, successNum)
}
report += "\n"

if incrementalMode {
    report += "## å¢é‡æ›´æ–°ç»Ÿè®¡\n\n"
    report += sprintf("| æŒ‡æ ‡ | æ•°å€¼ |\n")
    report += sprintf("|------|------|\n")
    report += sprintf("| åŸæœ‰æ–‡æ¡£æ•° | %d |\n", existingDocCount)
    report += sprintf("| è·³è¿‡å·²å­˜åœ¨çš„æ’ä»¶ | %d |\n", skippedByExistsCount)
    report += sprintf("| æ–°å¢æ’ä»¶æ•° | %d |\n", totalCount)
    report += sprintf("| æ–°å¢æˆåŠŸ | %d |\n", successCount)
    report += sprintf("| æ–°å¢å¤±è´¥ | %d |\n", failedCount)
    report += sprintf("| æœ€ç»ˆæ–‡æ¡£æ•° | %d |\n\n", finalDocCount)
} else {
    report += "## æ„å»ºç»Ÿè®¡\n\n"
    report += sprintf("| æŒ‡æ ‡ | æ•°å€¼ |\n")
    report += sprintf("|------|------|\n")
    report += sprintf("| æ’ä»¶æ€»æ•° | %d |\n", totalCount)
    report += sprintf("| æˆåŠŸå¤„ç† | %d |\n", successCount)
    report += sprintf("| å¤„ç†å¤±è´¥ | %d |\n", failedCount)
    report += sprintf("| è·³è¿‡æ•°é‡ | %d |\n", skippedCount)
    report += sprintf("| çŸ¥è¯†æ¡ç›®æ•° | %d |\n", successCount)
    report += sprintf("| é—®é¢˜ç´¢å¼•æ•° | %d |\n", totalQuestions)
    report += sprintf("| æ€»æ–‡æ¡£æ•° | %d |\n\n", finalDocCount)
}

if failedCount > 0 {
    report += "## å¤„ç†å¤±è´¥çš„é¡¹ç›®\n\n"
    for i, itemName := range failedItems {
        report += sprintf("%d. %s\n", i+1, itemName)
    }
    report += "\n"
}

report += "## æ„å»ºé€‰é¡¹\n\n"
report += "| é€‰é¡¹ | å€¼ |\n"
report += "|------|------|\n"
report += sprintf("| `--allow-nuclei-templates-repos` | %v |\n", allowNucleiTemplatesRepos)
report += sprintf("| `--include-yaknative-n-codec` | %v |\n\n", includeYakNativeAndCodec)

report += "## è¿‡æ»¤è§„åˆ™\n\n"
report += "### åŸºäºåç§°çš„è¿‡æ»¤\n\n"
report += "ä»¥ä¸‹åç§°æ¨¡å¼çš„æ’ä»¶è¢«è‡ªåŠ¨è¿‡æ»¤ï¼š\n\n"
report += "- åç§°ä»¥ `mock_` å¼€å¤´\n"
report += "- åç§°åŒ…å« `mock`\n"
report += "- åç§°ä¸º `sleep` æˆ–ä»¥ `sleep_` å¼€å¤´\n"
report += "- åç§°ä»¥ `test_` å¼€å¤´\n"
report += "- åç§°åŒ…å« `test`\n\n"
report += "### åŸºäºå±æ€§çš„è¿‡æ»¤ï¼ˆå†…éƒ¨æ’ä»¶ï¼‰\n\n"
report += "ä»¥ä¸‹å±æ€§çš„æ’ä»¶è¢«è‡ªåŠ¨è¿‡æ»¤ï¼š\n\n"
report += "- `Ignored = true`: æ ‡è®°ä¸ºå¿½ç•¥çš„å†…éƒ¨æ’ä»¶\n"
report += "- `IsHistory = true`: å†å²è®°å½•æ’ä»¶\n"
report += "- `ForceInteractive = true`: å¼ºåˆ¶äº¤äº’æ¨¡å¼çš„æ’ä»¶\n\n"

report += "### åŸºäºç±»å‹çš„è¿‡æ»¤\n\n"
if !includeYakNativeAndCodec {
    report += "ä»¥ä¸‹ç±»å‹çš„æ’ä»¶è¢«é»˜è®¤è¿‡æ»¤ï¼ˆä½¿ç”¨ `--include-yaknative-n-codec` å¯åŒ…å«ï¼‰ï¼š\n\n"
    report += "- `yak`: Yak åŸç”Ÿè„šæœ¬ï¼ˆä¸èƒ½ä½¿ç”¨å›ºå®šè¾“å…¥æµ‹è¯•ï¼‰\n"
    report += "- `codec`: ç¼–è§£ç æ’ä»¶ï¼ˆä¸èƒ½ä½¿ç”¨å›ºå®šè¾“å…¥æµ‹è¯•ï¼‰\n\n"
} else {
    report += "å·²å¯ç”¨ `--include-yaknative-n-codec`ï¼Œyak å’Œ codec ç±»å‹æ’ä»¶è¢«åŒ…å«ã€‚\n\n"
}

report += "### åŸºäº Nuclei æ¥æºçš„è¿‡æ»¤\n\n"
if !allowNucleiTemplatesRepos {
    report += "ä» nuclei-templates ä»“åº“å¯¼å…¥çš„ POC è¢«é»˜è®¤è¿‡æ»¤ï¼ˆä½¿ç”¨ `--allow-nuclei-templates-repos` å¯åŒ…å«ï¼‰ã€‚\n\n"
    report += "ä»“åº“å¯¼å…¥çš„ç‰¹å¾ï¼š\n"
    report += "- `FromLocal = true` ä¸” `IsExternal = true`\n"
    report += "- `Uuid` ä¸ºç©º æˆ– `OnlineId = 0`\n\n"
} else {
    report += "å·²å¯ç”¨ `--allow-nuclei-templates-repos`ï¼Œä»“åº“å¯¼å…¥çš„ nuclei POC è¢«åŒ…å«ã€‚\n\n"
}

// æ·»åŠ è·³è¿‡åŸå› ç»Ÿè®¡åˆ°æŠ¥å‘Š
if len(skipReasons) > 0 {
    report += "### è·³è¿‡åŸå› ç»Ÿè®¡\n\n"
    report += "| åŸå›  | æ•°é‡ |\n"
    report += "|------|------|\n"
    for reason, count := range skipReasons {
        report += sprintf("| %s | %d |\n", reason, count)
    }
    report += "\n"
}

report += "## å¢é‡æ›´æ–°æœºåˆ¶\n\n"
report += "å½“ RAG æ–‡ä»¶å·²å­˜åœ¨æ—¶ï¼Œè„šæœ¬ä¼šè‡ªåŠ¨è¿›å…¥å¢é‡æ›´æ–°æ¨¡å¼ï¼š\n\n"
report += "1. å¯¼å…¥ç°æœ‰çš„ RAG æ–‡ä»¶åˆ°å†…å­˜\n"
report += "2. å¯¹æ¯ä¸ªå¾…å¤„ç†çš„æ’ä»¶ï¼Œä½¿ç”¨æ¨¡ç³Šæœç´¢æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨\n"
report += "3. æ£€æŸ¥æ–¹å¼ï¼šæœç´¢æ’ä»¶åç§° â†’ è·å–çŸ¥è¯†æ¡ç›® â†’ æ£€æŸ¥ Content æ˜¯å¦åŒ…å« `æ’ä»¶åç§°: xxx`\n"
report += "4. å¦‚æœ Content åŒ…å«è¯¥æ’ä»¶åç§°ï¼Œåˆ™è·³è¿‡è¯¥æ¡ç›®\n"
report += "5. åªæ·»åŠ æ–°çš„æ¡ç›®ï¼ŒèŠ‚çœ AI è°ƒç”¨æˆæœ¬\n\n"
report += "ä½¿ç”¨ `--force` å‚æ•°å¯å¼ºåˆ¶å…¨é‡é‡å»ºã€‚\n\n"

report += "## æœç´¢è¯´æ˜\n\n"
report += "æœç´¢æ—¶ï¼Œç³»ç»Ÿä¼šï¼š\n\n"
report += "1. é€šè¿‡é—®é¢˜ç´¢å¼•è¿›è¡Œè¯­ä¹‰æœç´¢\n"
report += "2. æ‰¾åˆ°åŒ¹é…çš„é—®é¢˜åï¼Œé€šè¿‡ `entry_id` è·å–å¯¹åº”çš„çŸ¥è¯†æ¡ç›®\n"
report += "3. è¿”å›å®Œæ•´çš„æ’ä»¶ä¿¡æ¯\n\n"

report += "### Metadata å­—æ®µè¯´æ˜\n\n"
report += "| å­—æ®µ | è¯´æ˜ |\n"
report += "|------|------|\n"
report += "| `index_type` | æ–‡æ¡£ç±»å‹ï¼š`knowledge_entry` æˆ– `question_index` |\n"
report += "| `entry_id` | çŸ¥è¯†æ¡ç›®çš„å”¯ä¸€æ ‡è¯†ç¬¦ |\n"
report += "| `question_index` | é—®é¢˜æ–‡æœ¬ï¼ˆä»… question_index ç±»å‹æœ‰ï¼‰ |\n"
report += "| `search_type` | æ’ä»¶ç±»å‹æè¿°ï¼šå¦‚ `Yakæ’ä»¶[MITM ä»£ç†æ’ä»¶]` |\n"
report += "| `search_target` | æ’ä»¶åç§°ï¼ˆç”¨äºå¢é‡æ›´æ–°æ—¶çš„å»é‡æ£€æŸ¥ï¼‰ |\n"
report += "| `type` | æ’ä»¶ç±»å‹ï¼šå¦‚ `yak`, `mitm`, `port-scan` ç­‰ |\n"

// ä¿å­˜æŠ¥å‘Š
file.Save(reportPath, report)~
log.info("âœ“ Build report generated: %s", reportPath)

// =============================================================================
// æœ€ç»ˆæ€»ç»“
// =============================================================================

log.info("")
log.info("=== Build Complete ===")
log.info("âœ“ YakScript plugins search index built successfully")
log.info("   ğŸ“ RAG File: %s", finalOutputPath)
log.info("   ğŸ“„ Report: %s", reportPath)
log.info("   ğŸ“Š Plugins: %d processed", successCount)
log.info("   ğŸ“š Questions: %d generated", totalQuestions)
if incrementalMode {
    log.info("   ğŸ”„ Mode: Incremental update")
    log.info("   â­ï¸  Skipped: %d already indexed", skippedByExistsCount)
}
log.info("")
log.info("ğŸ” To search the index, use RAG search with the exported file.")

if failedCount > 0 {
    os.Exit(1)
} else {
    os.Exit(0)
}

