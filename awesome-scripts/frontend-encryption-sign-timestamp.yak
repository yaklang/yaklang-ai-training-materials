/*
前端加密分析 - 签名验证与时间戳防护

场景: 前端对请求参数进行签名，结合时间戳和随机数防止重放攻击。
本脚本演示如何分析签名算法、伪造签名、绕过时间戳验证。

关键词: 参数签名, HMAC签名, MD5签名, 时间戳验证, 随机数nonce
关键词: 重放攻击, 签名伪造, 参数排序, 盐值salt, JavaScript逆向
*/

println("\n=== 前端签名验证与时间戳防护实战 ===\n")

println("=== 一、常见签名算法分析 ===\n")

// 关键词: 参数准备, 业务数据
println("[1] 准备业务参数")
params = {
    "username": "testuser",
    "action": "transfer",
    "amount": "1000",
    "to_account": "account123"
}
println("  业务参数:")
for k, v in params {
    println(f"    ${k}: ${v}")
}

// 关键词: 时间戳生成, Unix时间戳
println("\n[2] 添加时间戳和随机数")
timestamp = string(time.Now().Unix())
nonce = codec.EncodeToHex(randn(8))
params["timestamp"] = timestamp
params["nonce"] = nonce
println(f"  timestamp: ${timestamp}")
println(f"  nonce: ${nonce}")

// 关键词: 参数排序, 字典序排序, 签名前处理
println("\n[3] 参数排序 (签名算法关键步骤)")
println("  说明: 大多数签名算法要求参数按key排序")

// 获取所有key并排序
keys = []
for k in params {
    keys = append(keys, k)
}
keys = str.Sort(keys)

println("  排序后的key:")
for k in keys {
    println(f"    ${k}")
}

// 关键词: 参数拼接, 签名字符串构造
println("\n[4] 方案A: 参数拼接签名 (k1=v1&k2=v2)")
signStr = ""
for i, k in keys {
    if i > 0 {
        signStr += "&"
    }
    signStr += f"${k}=${params[k]}"
}
println(f"  拼接字符串: ${signStr}")

// 关键词: MD5签名, 哈希签名
println("\n[5] MD5 签名")
md5Sign = codec.Md5(signStr)
println(f"  MD5签名: ${md5Sign}")

// 关键词: 加盐签名, 密钥混淆
secretKey = "mySecretKey123"
println(f"\n[6] 加盐 MD5 签名 (secret: {secretKey})")
saltedStr = signStr + "&key=" + secretKey
saltedMd5 = codec.Md5(saltedStr)
println(f"  加盐字符串: ${saltedStr}")
println(f"  加盐MD5签名: ${saltedMd5}")

// 关键词: HMAC签名, 消息认证码
println("\n[7] HMAC-SHA256 签名")
hmacSign = codec.HmacSHA256(secretKey, signStr)
hmacHex = codec.EncodeToHex(hmacSign)
println(f"  HMAC-SHA256: ${hmacHex}")

// 关键词: SHA256签名
println("\n[8] SHA256 签名")
sha256Sign = codec.Sha256(signStr)
println(f"  SHA256签名: ${sha256Sign}")

println("\n=== 二、签名验证模拟 ===\n")

// 关键词: 服务端签名验证
println("[服务端] 验证客户端签名")

// 模拟接收到的请求
receivedParams = params
receivedSign = saltedMd5

println(f"  接收签名: ${receivedSign}")

// 关键词: 时间戳验证, 时间窗口
println("\n[1] 时间戳验证 (5分钟有效期)")
currentTime = time.Now().Unix()
requestTime = int(receivedParams["timestamp"])
timeDiff = currentTime - requestTime

println(f"  当前时间: ${currentTime}")
println(f"  请求时间: ${requestTime}")
println(f"  时间差: ${timeDiff} 秒")

maxTimeDiff = 300  // 5分钟
if timeDiff > maxTimeDiff || timeDiff < -10 {
    println(f"  [✗] 时间戳验证失败: 超过{maxTimeDiff}秒")
} else {
    println("  [✓] 时间戳验证通过")
}

// 关键词: 签名重算, 签名比对
println("\n[2] 重新计算签名")
serverKeys = []
for k in receivedParams {
    if k != "sign" {  // 排除sign字段本身
        serverKeys = append(serverKeys, k)
    }
}
serverKeys = str.Sort(serverKeys)

serverSignStr = ""
for i, k in serverKeys {
    if i > 0 {
        serverSignStr += "&"
    }
    serverSignStr += f"${k}=${receivedParams[k]}"
}
serverSignStr += "&key=" + secretKey
serverSign = codec.Md5(serverSignStr)

println(f"  服务端计算: ${serverSign}")
println(f"  客户端签名: ${receivedSign}")

// 关键词: 签名验证比对
assert serverSign == receivedSign, "签名验证失败"
println("  [✓] 签名验证通过")

println("\n=== 三、攻击场景: 签名伪造 ===\n")

// 关键词: 参数篡改场景
println("[场景1] 修改金额并伪造签名")

// 拦截原始请求
attackParams = {
    "username": "testuser",
    "action": "transfer",
    "amount": "1",  // 篡改金额
    "to_account": "attacker_account",  // 篡改收款账户
    "timestamp": string(time.Now().Unix()),
    "nonce": codec.EncodeToHex(randn(8))
}

println("  篡改参数:")
println(f"    amount: 1000 -> ${attackParams['amount']}")
println(f"    to_account: account123 -> ${attackParams['to_account']}")

// 关键词: 签名伪造, 密钥泄露
println("\n  假设已获取密钥: ${secretKey}")
println("  重新计算签名:")

attackKeys = str.Sort(["username", "action", "amount", "to_account", "timestamp", "nonce"])
attackSignStr = ""
for i, k in attackKeys {
    if i > 0 {
        attackSignStr += "&"
    }
    attackSignStr += f"${k}=${attackParams[k]}"
}
attackSignStr += "&key=" + secretKey
attackSign = codec.Md5(attackSignStr)

println(f"  伪造签名: ${attackSign}")

// 验证伪造的签名
attackParams["sign"] = attackSign
println("\n  [✓] 签名伪造成功，可以绕过验证")

println("\n=== 四、攻击场景: 重放攻击 ===\n")

// 关键词: 重放攻击, 请求重放
println("[场景2] 重放攻击演示")

originalRequest = {
    "username": "testuser",
    "action": "withdraw",
    "amount": "100",
    "timestamp": string(time.Now().Unix()),
    "nonce": codec.EncodeToHex(randn(8))
}

// 生成签名
replayKeys = str.Sort(["username", "action", "amount", "timestamp", "nonce"])
replaySignStr = ""
for i, k in replayKeys {
    if i > 0 {
        replaySignStr += "&"
    }
    replaySignStr += f"${k}=${originalRequest[k]}"
}
replaySignStr += "&key=" + secretKey
originalSign = codec.Md5(replaySignStr)

println(f"  原始请求时间: ${originalRequest['timestamp']}")
println(f"  原始签名: ${originalSign}")

// 模拟1分钟后重放
sleep(1)
println("\n  1秒后尝试重放相同请求...")

replayTime = time.Now().Unix()
timeDiff2 = replayTime - int(originalRequest["timestamp"])
println(f"  时间差: ${timeDiff2} 秒")

if timeDiff2 <= maxTimeDiff {
    println("  [!] 在有效时间窗口内，重放可能成功")
    println("  [防御] 需要使用 nonce 去重")
} else {
    println("  [✓] 超过时间窗口，重放失败")
}

println("\n=== 五、防护方案 ===\n")

// 关键词: nonce去重, 防重放
println("[1] Nonce 去重机制")
println("  - 服务端维护已使用的 nonce 集合")
println("  - 每个 nonce 只能使用一次")
println("  - nonce 需要足够随机 (建议16字节以上)")
println("")

usedNonces = {}  // 模拟已使用的nonce集合

testNonce = codec.EncodeToHex(randn(16))
println(f"  示例 nonce: ${testNonce}")

// 第一次请求
if usedNonces[testNonce] {
    println("  [✗] Nonce 已使用，拒绝请求")
} else {
    usedNonces[testNonce] = true
    println("  [✓] Nonce 有效，记录使用")
}

// 重放攻击
if usedNonces[testNonce] {
    println("  [✗] Nonce 重复，检测到重放攻击")
} else {
    println("  [✓] Nonce 有效")
}

// 关键词: 时间窗口, 滑动窗口
println("\n[2] 时间窗口优化")
println("  - 建议时间窗口: 30-300秒")
println("  - 考虑客户端时钟误差: ±10秒")
println("  - 过期的 nonce 可以从集合中移除")

// 关键词: 签名密钥管理
println("\n[3] 密钥管理")
println("  - 不要在前端硬编码密钥")
println("  - 使用动态密钥或会话密钥")
println("  - 定期轮换密钥")
println("  - 不同用户使用不同密钥")

// 关键词: 签名算法选择
println("\n[4] 签名算法建议")
println("  - 避免使用 MD5 (已不安全)")
println("  - 推荐 HMAC-SHA256")
println("  - 考虑使用 RSA 签名 (非对称)")
println("  - 添加版本号，支持算法升级")

println("\n=== 六、完整防护示例 ===\n")

// 关键词: 完整签名验证流程
println("[安全的签名验证流程]")

secureParams = {
    "user_id": "user123",
    "operation": "transfer",
    "amount": "500",
    "version": "v2"  // API版本
}

// 1. 添加时间戳和nonce
secureTimestamp = string(time.Now().Unix())
secureNonce = codec.EncodeToHex(randn(16))
secureParams["timestamp"] = secureTimestamp
secureParams["nonce"] = secureNonce

println("1. 参数准备:")
for k, v in secureParams {
    println(f"   ${k}: ${v}")
}

// 2. 参数排序
secureKeys = []
for k in secureParams {
    secureKeys = append(secureKeys, k)
}
secureKeys = str.Sort(secureKeys)

// 3. 使用 HMAC-SHA256
secureSignStr = ""
for i, k in secureKeys {
    if i > 0 {
        secureSignStr += "&"
    }
    secureSignStr += f"${k}=${secureParams[k]}"
}

secureSecret = "SecureKey" + string(time.Now().Format("20060102"))  // 每日轮换
secureHmac = codec.HmacSHA256(secureSecret, secureSignStr)
secureSign = codec.EncodeBase64(secureHmac)

println(f"\n2. HMAC-SHA256 签名: ${secureSign[:40]}...")

// 4. 验证流程
println("\n3. 服务端验证:")
println("   ✓ 检查时间戳 (±5分钟)")
println("   ✓ 检查 nonce 唯一性")
println("   ✓ 重新计算签名并比对")
println("   ✓ 检查 API 版本")

println("\n=== 测试完成 ===\n")

println("总结:")
println("  ✓ MD5/SHA256/HMAC 签名算法")
println("  ✓ 时间戳验证机制")
println("  ✓ Nonce 去重防重放")
println("  ✓ 参数排序和拼接")
println("  ✓ 签名伪造攻击演示")
println("  ✓ 完整防护方案")
println("")

/*
签名验证核心 API:

哈希函数:
- codec.Md5(data) - MD5哈希
- codec.Sha1(data) - SHA1哈希
- codec.Sha256(data) - SHA256哈希

HMAC签名:
- codec.HmacSHA1(key, data) - HMAC-SHA1
- codec.HmacSHA256(key, data) - HMAC-SHA256
- codec.HmacMD5(key, data) - HMAC-MD5

编码工具:
- codec.EncodeToHex(data) - Hex编码
- codec.EncodeBase64(data) - Base64编码

工具函数:
- str.Sort(array) - 字符串数组排序
- time.Now().Unix() - 时间戳
- randn(length) - 随机字节

签名流程:
1. 收集业务参数
2. 添加 timestamp 和 nonce
3. 参数按 key 排序
4. 拼接: k1=v1&k2=v2&k3=v3
5. 添加密钥: ...&key=secret
6. 计算签名: HMAC-SHA256(key, str)
7. 附加到请求: sign=xxx

验证流程:
1. 检查时间戳 (防过期)
2. 检查 nonce (防重放)
3. 重新计算签名
4. 比对签名值
5. 验证业务参数

攻击场景:
- 密钥泄露 -> 签名伪造
- 时间窗口过大 -> 重放攻击
- 无 nonce -> 重放攻击
- 弱哈希算法 -> 碰撞攻击
*/

