// =============================================================================
// AI 模型漏洞检测能力 Benchmark 测试
// 功能: 测试不同 AI 模型检测 SQL 注入漏洞的能力，支持 Web 界面和命令行模式
// 用途: AI 模型性能评估、能力对比、选型参考
// =============================================================================
// 关键词: AI benchmark, 漏洞检测, ReAct, SQL注入检测, 模型评估, Web界面
// =============================================================================

// CLI 参数配置
// 关键词: CLI参数, 配置选项
webMode = cli.Bool("web", cli.setDefault(false), cli.setHelp("启动Web界面模式"))
port = cli.Int("port", cli.setDefault(9093), cli.setHelp("Web服务端口"))
configFile = cli.String("config", cli.setDefault(""), cli.setHelp("测试配置文件路径(JSON格式，包含testConfigs，必需)"))
aiConfigFile = cli.String("ai-config", cli.setDefault(""), cli.setHelp("AI配置文件路径(JSON格式，包含aiConfigs，必需)"))
outputDir = cli.String("output-dir", cli.setDefault(""), cli.setHelp("报告输出目录（默认不保存，每个测试生成独立报告文件）"))
reportPrefix = cli.String("report-prefix", cli.setDefault("benchmark-report"), cli.setHelp("报告文件名前缀"))
frontendPath = cli.String("frontend", cli.setDefault(""), cli.setHelp("前端HTML文件路径（可选，默认自动查找）"))
yakEngineVersion = cli.String("yaklang-engine-version", cli.setDefault(""), cli.setHelp("Yaklang引擎版本（用于报告记录）"))

// 可选的覆盖参数（优先级高于配置文件）
targetURL = cli.String("url", cli.setDefault(""), cli.setHelp("测试目标URL（覆盖配置文件）"))
maxIteration = cli.Int("max-iteration", cli.setDefault(0), cli.setHelp("ReAct最大迭代次数（覆盖配置文件）"))
timeout = cli.Int("timeout", cli.setDefault(0), cli.setHelp("单个测试超时时间/秒（覆盖配置文件）"))

// 变量替换参数（用于替换配置文件中的 {{variable-name}} 占位符）
// 关键词: 变量替换, 配置变量, --var
varParams = cli.StringSlice("var", cli.setHelp("设置变量，格式: key=value，可多次使用，用于替换配置中的 {{key}} 占位符"))

// 验证参数
cli.check()

// 解析变量参数为映射表
// 关键词: 变量解析, 变量映射
globalVars = {}
for varParam in varParams {
    if str.Contains(varParam, "=") {
        parts = str.SplitN(varParam, "=", 2)
        if len(parts) == 2 {
            key = str.TrimSpace(parts[0])
            value = str.TrimSpace(parts[1])
            globalVars[key] = value
            log.info("Variable set: %s=***", key)  // 不打印敏感值
        }
    } else {
        log.warn("Invalid variable format (expected key=value): %s", varParam)
    }
}

// 替换字符串中的变量占位符 {{variable-name}}
// 关键词: 变量替换函数
func replaceVariables(text) {
    if text == nil || text == undefined {
        return text
    }
    
    result = sprintf("%v", text)
    for key, value in globalVars {
        placeholder = sprintf("{{%s}}", key)
        result = str.ReplaceAll(result, placeholder, value)
    }
    return result
}

// 递归替换配置对象中的所有字符串变量
// 关键词: 配置替换, 递归替换
func replaceConfigVariables(config) {
    if config == nil || config == undefined {
        return config
    }
    
    // 如果是字符串，直接替换
    configType = typeof(config)
    if configType == "string" {
        return replaceVariables(config)
    }
    
    // 如果是数组，递归处理每个元素
    if configType == "slice" {
        result = []
        for item in config {
            result = append(result, replaceConfigVariables(item))
        }
        return result
    }
    
    // 如果是映射，递归处理每个值
    if configType == "map" {
        result = {}
        for key, value in config {
            result[key] = replaceConfigVariables(value)
        }
        return result
    }
    
    // 其他类型直接返回
    return config
}

log.info("Starting AI Model Vulnerability Detection Benchmark")

if outputDir != "" {
    log.info("Report dir: %v" % outputDir)
}

// 安装并启动 vulinbox 靶场
// 关键词: vulinbox, 靶场安装, 自动启动
log.info("=" * 80)
log.info("Setting up vulinbox target environment...")
log.info("=" * 80)

// 安装 vulinbox
log.info("Installing vulinbox...")
err = toolbox.Install("vulinbox")
if err != nil {
    log.error("Failed to install vulinbox: %v", err)
    die(sprintf("Failed to install vulinbox: %v. Please check your network connection.", err))
}
log.info("Vulinbox installed successfully")

// 启动 vulinbox
// 关键词: vulinbox启动, 后台服务
startVulinbox = () => {
    ctx, cancel = context.WithCancel(context.Background())
    
    go func {
        defer func {
            err = recover()
            if err != nil {
                log.error("Vulinbox process panic: %v", err)
            }
        }
        
        vulinboxPath = file.Join(os.GetHomeDir(), "yakit-projects", "projects", "libs", "vulinbox")
        log.info("Starting vulinbox from: %s", vulinboxPath)
        
        // 启动 vulinbox (HTTP mode, safe mode, 127.0.0.1:8787)
        res, err = exec.SystemContext(ctx, vulinboxPath + " --nohttps --safe --host 127.0.0.1 --port 8787")
        if err != nil {
            log.error("Vulinbox process error: %v", err)
        }
        log.info("Vulinbox process output: %s", res)
    }
    
    return cancel
}

log.info("Starting vulinbox on http://127.0.0.1:8787")
vulinboxCancel = startVulinbox()

// 等待服务启动成功
log.info("Waiting for vulinbox to be ready...")
time.Sleep(5)

// 验证 vulinbox 是否启动成功
testUrl = "http://127.0.0.1:8787"
log.info("Testing vulinbox connectivity: %s", testUrl)
rsp, req, err = poc.Get(testUrl, poc.timeout(5))
if err != nil {
    log.warn("Failed to connect to vulinbox: %v", err)
    log.warn("Vulinbox might not be ready yet, but continuing anyway...")
} else {
    log.info("✓ Vulinbox is running successfully on http://127.0.0.1:8787")
}

log.info("=" * 80)

// 注册清理函数，确保程序退出时停止 vulinbox
defer func {
    log.info("Stopping vulinbox...")
    if vulinboxCancel != nil {
        vulinboxCancel()
    }
    log.info("Vulinbox stopped")
}

// 全局变量
// 关键词: 全局状态, 测试结果
globalResults = []
globalMutex = sync.NewMutex()

// 执行单个模型测试的核心函数
// 关键词: 核心测试函数, 模型测试
func runModelTest(aiConfig, testConfig, onProgress) {
    log.info("=" * 80)
    log.info("Testing model: %s (%s)", aiConfig["model"], aiConfig["description"])
    log.info("=" * 80)
    
    // 初始化测试结果
    // 关键词: 结果初始化, 测试数据结构
    result = {
        "provider": aiConfig["provider"],
        "model": aiConfig["model"],
        "description": aiConfig["description"],
        "testName": testConfig["name"],
        "targetURL": testConfig["targetURL"],
        "taskPrompt": testConfig["taskPrompt"],
        "maxIteration": testConfig["maxIteration"],
        "timeout": testConfig["timeout"],
        "riskMatchKeywords": testConfig["riskMatchKeywords"],
        "yakEngineVersion": yakEngineVersion,
        "success": false,
        "detected": false,
        "error": "",
        "runtimeId": "",
        "riskCount": 0,
        "matchedRiskCount": 0,
        "risks": [],
        "startTime": time.Now().Unix(),
        "endTime": 0,
        "duration": 0,
        "thoughtLog": [],
        "answerLog": [],
    }
    
    // 错误处理包装
    // 关键词: 错误处理, defer recover
    defer func {
        err = recover()
        if err != nil {
            log.error("Test failed with panic: %v", err)
            if result["error"] == "" {
                result["error"] = sprintf("%v", err)
            }
        }
        
        // 记录结束时间
        result["endTime"] = time.Now().Unix()
        result["duration"] = result["endTime"] - result["startTime"]
        result["timestamp"] = time.Now().Format("2006-01-02 15:04:05")
        
        // 保存结果到全局列表
        globalMutex.Lock()
        globalResults = append(globalResults, result)
        globalMutex.Unlock()
        
        // 单个测试结果已保存到全局列表，批次报告在所有测试完成后保存
        
        // 通知进度
        if onProgress != nil {
            onProgress(result)
        }
    }
    
    // 创建 AI 引擎选项
    opts = []
    
    // 配置会话ID（随机生成避免干扰）
    // 关键词: 会话隔离, 随机会话ID
    sessionID = str.RandStr(12)
    opts = append(opts, aim.sessionID(sessionID))
    
    // 配置超时
    // 关键词: 超时控制, aim.timeout
    opts = append(opts, aim.timeout(testConfig["timeout"]))
    
    // 配置最大迭代次数
    // 关键词: 迭代控制, aim.maxIteration
    opts = append(opts, aim.maxIteration(int(testConfig["maxIteration"])))
    
    // 配置 YOLO 模式（自动同意所有操作）
    // 关键词: YOLO模式, 自动审批
    opts = append(opts, aim.yoloMode())
    
    // 配置语言
    // 关键词: 语言设置
    opts = append(opts, aim.language("zh"))
    
    // 配置 AI 服务提供商
    // 关键词: AI服务配置, aibalance, ai.model, ai.domain, ai.apiKey
    aiOpts = []
    
    // model 是必选项
    aiOpts = append(aiOpts, ai.model(aiConfig["model"]))
    
    // domain 是可选项
    if aiConfig["domain"] != "" && aiConfig["domain"] != undefined {
        aiOpts = append(aiOpts, ai.domain(aiConfig["domain"]))
    }
    
    // apikey 是可选项
    if aiConfig["apikey"] != "" && aiConfig["apikey"] != undefined {
        aiOpts = append(aiOpts, ai.apiKey(aiConfig["apikey"]))
    }
    
    opts = append(opts, aim.aiConfig(aiConfig["provider"], aiOpts...))
    
    // 禁用用户交互
    // 关键词: 禁用交互, 自动化测试
    opts = append(opts, aim.allowUserInteract(false))
    
    // 禁用 AI Forge
    opts = append(opts, aim.disableAIForge(true))
    
    // 生成唯一的结果标识符
    // 关键词: 结果标识, 唯一ID
    resultId = sprintf("%s-%s-%d", aiConfig["model"], testConfig["name"], time.Now().UnixNano())
    result["resultId"] = resultId
    
    // 配置流式输出回调（记录AI思考过程）
    // 关键词: 流式输出, 思考过程记录
    opts = append(opts, aim.onStream(func(react, event, nodeid, data) {
        if nodeid == "re-act-loop-thought" {
            result["thoughtLog"] = append(result["thoughtLog"], string(data))
            log.debug("Thought: %s", string(data))
            
            // 通知进度（思考过程）
            if onProgress != nil {
                onProgress({
                    "type": "thought",
                    "data": string(data),
                    "model": aiConfig["model"],
                    "resultId": resultId,
                })
            }
        }
        if nodeid == "re-act-loop-answer-payload" {
            result["answerLog"] = append(result["answerLog"], string(data))
            log.debug("Answer: %s", string(data))
            
            // 通知进度（回答内容）
            if onProgress != nil {
                onProgress({
                    "type": "answer",
                    "data": string(data),
                    "model": aiConfig["model"],
                    "resultId": resultId,
                })
            }
        }
    }))
    
    // 配置完成回调，检测漏洞
    // 关键词: 完成回调, onFinished, 漏洞检测结果
    opts = append(opts, aim.onFinished(func(react) {
        // 获取最后一个任务
        risks = react.GetLastTask().GetRisks()
        riskCount = len(risks)
        
        log.info("############################################################################################Found %d risk(s) in total", riskCount)
        
        // 遍历并记录所有 Risk 信息
        idx = 0
        matchedRiskCount = 0
        riskDetails = []
        
        for riskItem in risks {
            log.info("Risk #%d:", idx + 1)
            log.info("  Title: %s", riskItem.Title)
            log.info("  TitleVerbose: %s", riskItem.TitleVerbose)
            log.info("  RiskType: %s", riskItem.RiskType)
            log.info("  Severity: %s", riskItem.Severity)
            log.info("  URL: %s", riskItem.Url)
            log.info("  Host: %s", riskItem.Host)
            log.info("  Port: %d", riskItem.Port)
            if riskItem.Description != "" {
                log.info("  Description: %s", riskItem.Description)
            }
            if riskItem.Payload != "" {
                log.info("  Payload: %s", riskItem.Payload)
            }
            
            // 保存 Risk 详细信息
            riskDetail = {
                "title": riskItem.Title,
                "titleVerbose": riskItem.TitleVerbose,
                "riskType": riskItem.RiskType,
                "severity": riskItem.Severity,
                "url": riskItem.Url,
                "host": riskItem.Host,
                "port": riskItem.Port,
                "description": riskItem.Description,
                "payload": riskItem.Payload,
                "matched": false,
            }
            
            // 检查是否匹配关键词
            // 关键词: Risk匹配, 关键词验证
            riskMatchKeywords = testConfig["riskMatchKeywords"]
            if riskMatchKeywords != nil && riskMatchKeywords != undefined && len(riskMatchKeywords) > 0 {
                // 构建要检查的文本内容（标题、描述、类型等）
                riskText = sprintf("%s %s %s %s %s", 
                    riskItem.Title, 
                    riskItem.TitleVerbose, 
                    riskItem.RiskType,
                    riskItem.Description,
                    riskItem.Payload
                )
                riskTextLower = str.ToLower(riskText)
                
                // 检查是否包含任何关键词
                matched = false
                matchedKeywords = []
                for keyword in riskMatchKeywords {
                    keywordLower = str.ToLower(sprintf("%v", keyword))
                    if str.Contains(riskTextLower, keywordLower) {
                        matched = true
                        matchedKeywords = append(matchedKeywords, keyword)
                    }
                }
                
                if matched {
                    matchedRiskCount++
                    riskDetail["matched"] = true
                    riskDetail["matchedKeywords"] = matchedKeywords
                    log.info("  Matched keywords: %v", matchedKeywords)
                } else {
                    log.info("  Risk did not match configured keywords")
                }
            } else {
                // 如果没有配置关键词，默认所有 Risk 都算匹配
                matchedRiskCount++
                riskDetail["matched"] = true
            }
            
            riskDetails = append(riskDetails, riskDetail)
            idx++
        }
        
        // 保存 Risk 详细信息到结果
        result["risks"] = riskDetails
        
        // 根据匹配的 Risk 数量判断是否检测到漏洞
        // 关键词: 检测判断, 匹配统计
        result["riskCount"] = riskCount
        result["matchedRiskCount"] = matchedRiskCount
        
        if matchedRiskCount > 0 {
            result["detected"] = true
            log.info("Vulnerability detected! Total risks: %d, Matched risks: %d", riskCount, matchedRiskCount)
        } else {
            result["detected"] = false
            if riskCount > 0 {
                log.info("Found %d risk(s) but none matched the configured keywords", riskCount)
            } else {
                log.info("No vulnerability detected")
            }
        }
    }))
    
    // 构造测试任务
    // 关键词: 任务构造, 漏洞检测任务, 模板替换
    taskPromptTemplate = testConfig["taskPrompt"]
    
    // 如果配置中没有taskPrompt，使用默认模板
    if taskPromptTemplate == nil || taskPromptTemplate == undefined || taskPromptTemplate == "" {
        taskPromptTemplate = `你的任务是检测以下 URL 地址是否存在漏洞。

目标 URL: {{targetURL}}`
    }
    
    // 替换模板变量 {{targetURL}}
    // 关键词: 模板替换, str.ReplaceAll
    taskPrompt = str.ReplaceAll(taskPromptTemplate, "{{targetURL}}", testConfig["targetURL"])
    
    log.info("Task prompt: %s", taskPrompt)
    
    // 调用 ReAct 执行任务
    // 关键词: aim.InvokeReAct, ReAct调用
    log.info("Invoking ReAct with provider=%s, model=%s", aiConfig["provider"], aiConfig["model"])
    err = aim.InvokeReAct(taskPrompt, opts...)
    
    if err != nil {
        log.error("Failed to invoke ReAct: %v", err)
        result["error"] = sprintf("Failed to invoke ReAct: %v", err)
    } else {
        log.info("ReAct completed successfully")
        result["success"] = true
    }
    
    log.info("Test completed for model %s", aiConfig["model"])
    log.info("  Success: %v", result["success"])
    log.info("  Detected: %v", result["detected"])
    log.info("  Risk Count: %d (Matched: %d)", result["riskCount"], result["matchedRiskCount"])
    log.info("  Runtime ID: %s", result["runtimeId"])
    log.info("  Duration: %d seconds", result["duration"])
    if result["error"] != "" {
        log.info("  Error: %s", result["error"])
    }
}

// 保存批次报告（包含所有测试结果）
// 关键词: 报告保存, 批次报告, JSON输出
func saveBatchReport(results, testConfigs, aiConfigs) {
    // 确保输出目录存在
    if outputDir == "" {
        return
    }
    
    // 创建输出目录
    err = file.MkdirAll(outputDir)
    if err != nil {
        log.error("Failed to create output directory: %v", err)
        return
    }
    
    // 生成文件名：前缀-时间戳.json
    filename = sprintf("%s-%d.json", reportPrefix, timestamp())
    filepath = sprintf("%s/%s", outputDir, filename)
    
    // 统计信息
    totalTests = len(results)
    successCount = 0
    detectedCount = 0
    totalRisks = 0
    totalDuration = 0
    
    for result in results {
        if result["success"] {
            successCount++
        }
        if result["detected"] {
            detectedCount++
        }
        totalRisks += result["riskCount"]
        totalDuration += result["duration"]
    }
    
    // 提取测试配置名称列表
    testNames = []
    for tc in testConfigs {
        testNames = append(testNames, tc["name"])
    }
    
    // 提取模型列表
    models = []
    for ac in aiConfigs {
        models = append(models, {
            "model": ac["model"],
            "provider": ac["provider"],
            "description": ac["description"],
        })
    }
    
    // 构建批次报告
    report = {
        "reportType": "batch",
        "timestamp": time.Now().Format("2006-01-02 15:04:05"),
        "yakEngineVersion": yakEngineVersion,
        "summary": {
            "totalTests": totalTests,
            "successCount": successCount,
            "detectedCount": detectedCount,
            "totalRisks": totalRisks,
            "totalDuration": totalDuration,
            "successRate": float(successCount) / float(totalTests) * 100,
            "detectionRate": float(detectedCount) / float(totalTests) * 100,
        },
        "testConfigs": testConfigs,
        "aiConfigs": aiConfigs,
        "testNames": testNames,
        "models": models,
        "results": results,
    }
    
    // 转换为 JSON
    jsonOutput = json.dumps(report)
    
    // 保存到文件
    err = file.Save(filepath, jsonOutput)
    if err != nil {
        log.error("Failed to save batch report to %s: %v", filepath, err)
    } else {
        log.info("Batch report saved successfully to: %s", filepath)
    }
}

// 生成结果报告
// 关键词: 结果报告, 统计分析
func generateReport(results) {
    println("")
    println("=" * 80)
    println("AI Model Vulnerability Detection Benchmark Results")
    println("=" * 80)
    println("")
    
    // 表头
    printf("%-25s %-20s %-15s %-10s %-10s %-12s %-10s %-25s\n", 
        "Test Scenario", "Model", "Provider", "Success", "Detected", "Risks(M/T)", "Duration(s)", "Error")
    println("-" * 130)
    
    // 表格内容
    for result in results {
        successStr = "NO"
        if result["success"] {
            successStr = "YES"
        }
        
        detectedStr = "NO"
        if result["detected"] {
            detectedStr = "YES"
        }
        
        errorStr = result["error"]
        if len(errorStr) > 23 {
            errorStr = errorStr[:20] + "..."
        }
        
        // 构建 Risk 显示字符串：匹配数/总数
        matchedCount = result["matchedRiskCount"]
        totalCount = result["riskCount"]
        riskStr = sprintf("%d/%d", matchedCount, totalCount)
        
        // 测试场景名称
        testName = result["testName"]
        if testName == nil || testName == undefined || testName == "" {
            testName = result["targetURL"]
        }
        if len(testName) > 23 {
            testName = testName[:20] + "..."
        }
        
        printf("%-25s %-20s %-15s %-10s %-10s %-12s %-10d %-25s\n",
            testName,
            result["model"],
            result["provider"],
            successStr,
            detectedStr,
            riskStr,
            result["duration"],
            errorStr
        )
    }
    
    println("-" * 130)
    
    // 统计信息
    totalTests = len(results)
    successCount = 0
    detectedCount = 0
    totalRisks = 0
    
    for result in results {
        if result["success"] {
            successCount++
        }
        if result["detected"] {
            detectedCount++
        }
        totalRisks += result["riskCount"]
    }
    
    // 计算比率
    successRate = 0.0
    detectionRate = 0.0
    if totalTests > 0 {
        successRate = float(successCount)/float(totalTests)*100
        detectionRate = float(detectedCount)/float(totalTests)*100
    }
    
    println("")
    println("Summary:")
    printf("  Total Tests: %d\n", totalTests)
    printf("  Successful Tests: %d (%.1f%%)\n", successCount, successRate)
    printf("  Detected SQL Injection: %d (%.1f%%)\n", detectedCount, detectionRate)
    printf("  Total Risks Found: %d\n", totalRisks)
    println("=" * 80)
    
    return {
        "totalTests": totalTests,
        "successCount": successCount,
        "detectedCount": detectedCount,
        "totalRisks": totalRisks,
        "successRate": successRate,
        "detectionRate": detectionRate,
    }
}

// 加载配置文件
// 关键词: 配置加载, 统一加载
func loadConfigurations() {
    log.info("Loading configurations...")
    log.info("  Test Config File: %s", configFile)
    log.info("  AI Config File: %s", aiConfigFile)
    
    // 验证必需参数
    if configFile == "" {
        log.error("No test config file specified. Please use --config parameter")
        die("No test config file specified. Please use --config parameter to provide test configurations.\nExample: yak benchmark.yak --config test-config.json --ai-config ai-config.json")
    }
    
    if aiConfigFile == "" {
        log.error("No AI config file specified. Please use --ai-config parameter")
        die("No AI config file specified. Please use --ai-config parameter to provide AI configurations.\nExample: yak benchmark.yak --config test-config.json --ai-config ai-config.json")
    }
    
    // 加载测试配置
    log.info("Loading test config from file: %s", configFile)
    testConfigContent, err = file.ReadFile(configFile)
    if err != nil {
        log.error("Failed to read test config file: %v", err)
        die(sprintf("Failed to read test config file: %v", err))
    }
    
    testConfigData = json.loads(testConfigContent)
    if testConfigData == nil || testConfigData == undefined {
        log.error("Failed to parse test config file")
        die("Failed to parse test config file. Please ensure it is valid JSON.")
    }
    
    // 读取测试配置数组
    testConfigs = testConfigData["testConfigs"]
    if testConfigs == nil || len(testConfigs) == 0 {
        log.error("No test configs found in test config file")
        die("No test configs found in test config file. Please add 'testConfigs' array.")
    }
    
    // 应用变量替换到测试配置
    // 关键词: 变量替换应用, 测试配置变量替换
    if len(globalVars) > 0 {
        log.info("Applying %d variable(s) to test configs", len(globalVars))
        testConfigs = replaceConfigVariables(testConfigs)
    }
    
    log.info("Loaded %d test config(s)", len(testConfigs))
    
    // 加载 AI 配置
    log.info("Loading AI config from file: %s", aiConfigFile)
    aiConfigContent, err = file.ReadFile(aiConfigFile)
    if err != nil {
        log.error("Failed to read AI config file: %v", err)
        die(sprintf("Failed to read AI config file: %v", err))
    }
    
    aiConfigData = json.loads(aiConfigContent)
    if aiConfigData == nil || aiConfigData == undefined {
        log.error("Failed to parse AI config file")
        die("Failed to parse AI config file. Please ensure it is valid JSON.")
    }
    
    // 读取 AI 配置
    aiConfigs = aiConfigData["aiConfigs"]
    if aiConfigs == nil || len(aiConfigs) == 0 {
        log.error("No AI configs found in AI config file")
        die("No AI configs found in AI config file. Please add 'aiConfigs' array.")
    }
    
    // 应用变量替换到 AI 配置
    // 关键词: 变量替换应用, 配置变量替换
    if len(globalVars) > 0 {
        log.info("Applying %d variable(s) to AI configs", len(globalVars))
        aiConfigs = replaceConfigVariables(aiConfigs)
    }
    
    log.info("Loaded %d AI config(s)", len(aiConfigs))
    
    // 应用 CLI 参数覆盖
    if targetURL != "" || maxIteration > 0 || timeout > 0 {
        log.info("Applying CLI parameter overrides to all test configs")
        for idx, tc in testConfigs {
            if targetURL != "" {
                testConfigs[idx]["targetURL"] = targetURL
            }
            if maxIteration > 0 {
                testConfigs[idx]["maxIteration"] = maxIteration
            }
            if timeout > 0 {
                testConfigs[idx]["timeout"] = timeout
            }
        }
    }
    
    totalTests = len(aiConfigs) * len(testConfigs)
    log.info("Configuration Summary:")
    log.info("  AI Models: %d", len(aiConfigs))
    log.info("  Test Scenarios: %d", len(testConfigs))
    log.info("  Total Tests: %d", totalTests)
    
    return aiConfigs, testConfigs
}

// 执行所有测试
// 关键词: 测试执行, 主测试流程
func runAllTests(aiConfigs, testConfigs) {
    log.info("")
    log.info("=" * 80)
    log.info("Starting tests...")
    log.info("=" * 80)
    
    testIdx = 0
    totalTests = len(aiConfigs) * len(testConfigs)
    
    // 执行所有测试：每个 testConfig × 每个 aiConfig
    for testConfig in testConfigs {
        testName = testConfig["name"]
        if testName == nil || testName == undefined || testName == "" {
            testName = sprintf("Test-%s", testConfig["targetURL"])
        }
        
        log.info("")
        log.info("=" * 80)
        log.info("Test Scenario: %s", testName)
        log.info("  Target URL: %s", testConfig["targetURL"])
        log.info("  Max Iteration: %d", testConfig["maxIteration"])
        log.info("  Timeout: %d seconds", testConfig["timeout"])
        log.info("=" * 80)
        
        for aiConfig in aiConfigs {
            testIdx++
            log.info("[%d/%d] Testing: %s with %s", testIdx, totalTests, testName, aiConfig["model"])
            
            // 如果是 Web 模式，使用带进度回调的版本
            if webMode && webProgressCallback != nil {
                runModelTest(aiConfig, testConfig, webProgressCallback)
            } else {
                runModelTest(aiConfig, testConfig, nil)
            }
        }
    }
    
    log.info("")
    log.info("=" * 80)
    log.info("All tests completed")
    log.info("=" * 80)
    
    // 生成报告
    summary = generateReport(globalResults)
    
    // 如果是 Web 模式，发送完成消息
    if webMode {
        completeMsg = {
            "type": "test_completed",
            "results": globalResults,
            "summary": summary,
        }
        broadcastToWebSockets(completeMsg)
    }
    
    // 保存批次报告（包含所有测试结果）
    if outputDir != "" {
        saveBatchReport(globalResults, testConfigs, aiConfigs)
        log.info("Batch report saved to directory: %s", outputDir)
    }
    
    return summary
}

// 全局 WebSocket 连接管理
// 关键词: WebSocket连接池, 广播
globalWebSocketConns = []
globalWebSocketMutex = sync.NewMutex()
webProgressCallback = nil

// 广播消息到所有 WebSocket 连接
// 关键词: 消息广播
func broadcastToWebSockets(message) {
    globalWebSocketMutex.Lock()
    defer globalWebSocketMutex.Unlock()
    
    msgJson = json.dumps(message)
    for conn in globalWebSocketConns {
        err = conn.WriteMessage(1, msgJson)
        if err != nil {
            log.debug("Failed to send message to client: %v", err)
        }
    }
}

// Web服务器：启动HTTP服务器并推送测试进度
// 关键词: Web服务, HTTP服务器, WebSocket
func startWebServer(aiConfigs, testConfigs) {
    log.info("Starting Web server on port %d", port)
    
    // 准备配置信息
    configInfo = {
        "aiConfigs": aiConfigs,
        "testConfigs": testConfigs
    }
    
    // 加载前端HTML
    // 关键词: 前端加载, HTML文件
    var htmlContent
    htmlLoaded = false
    
    // 优先使用指定的前端路径
    if frontendPath != "" {
        content, readErr = file.ReadFile(frontendPath)
        if readErr == nil {
            htmlContent = content
            htmlLoaded = true
            log.info("HTML file loaded from specified path: %s", frontendPath)
        } else {
            log.warn("Failed to load HTML from specified path %s: %v, trying default paths...", frontendPath, readErr)
        }
    }
    
    // 如果没有指定路径或加载失败，使用默认路径列表
    if !htmlLoaded {
        possiblePaths = [
            "apps/ai-vuln-detection-benchmark/ai-model-vuln-detection-benchmark.html",
            "ai-model-vuln-detection-benchmark.html",
            "./ai-model-vuln-detection-benchmark.html",
        ]
        
        for htmlPath in possiblePaths {
            content, readErr = file.ReadFile(htmlPath)
            if readErr == nil {
                htmlContent = content
                htmlLoaded = true
                log.info("HTML file loaded from: %s", htmlPath)
                break
            }
        }
    }
    
    if !htmlLoaded {
        log.error("Failed to load frontend HTML file")
        die("Frontend HTML file not found. Please ensure ai-model-vuln-detection-benchmark.html exists.")
    }
    
    // 首页处理函数
    // 关键词: HTTP路由, 首页处理
    indexHandle = (rsp, req) => {
        log.info("Serving index.html to %s", req.RemoteAddr)
        rsp.Header().Set("Content-Type", "text/html; charset=utf-8")
        rsp.WriteHeader(200)
        rsp.Write(htmlContent)
    }
    
    // WebSocket 处理函数（仅用于推送测试进度）
    // 关键词: WebSocket处理, 消息推送
    testWSHandle = (conn) => {
        clientAddr = conn.RemoteAddr().String()
        log.info("New WebSocket connection from %s", clientAddr)
        
        defer func {
            err = recover()
            if err != nil {
                log.error("WebSocket handler panic: %v", err)
            }
            
            // 从连接池中移除
            globalWebSocketMutex.Lock()
            newConns = []
            for c in globalWebSocketConns {
                if c != conn {
                    newConns = append(newConns, c)
                }
            }
            globalWebSocketConns = newConns
            globalWebSocketMutex.Unlock()
            
            conn.Close()
            log.info("WebSocket connection closed for %s", clientAddr)
        }
        
        // 添加到连接池
        globalWebSocketMutex.Lock()
        globalWebSocketConns = append(globalWebSocketConns, conn)
        globalWebSocketMutex.Unlock()
        
        // 发送欢迎消息和配置信息
        welcomeMsg = {
            "type": "connected",
            "message": "WebSocket connected successfully",
            "config": configInfo
        }
        conn.WriteMessage(1, json.dumps(welcomeMsg))
        log.info("Sent welcome message with config to %s", clientAddr)
        
        // 保持连接活跃（只读取消息，不处理）
        for {
            _, _, err = conn.ReadMessage()
            if err != nil {
                log.debug("WebSocket connection closed by client %s: %v", clientAddr, err)
                break
            }
        }
    }
    
    // 设置全局进度回调函数
    webProgressCallback = func(progress) {
        // 发送进度更新到所有连接的客户端
        if progress["type"] == "thought" || progress["type"] == "answer" {
            // 流式输出
            progressMsg = {
                "type": "stream",
                "streamType": progress["type"],
                "model": progress["model"],
                "resultId": progress["resultId"],
                "data": progress["data"],
            }
            broadcastToWebSockets(progressMsg)
        } else {
            // 模型完成
            progressMsg = {
                "type": "model_completed",
                "result": progress,
            }
            broadcastToWebSockets(progressMsg)
        }
    }
    
    // API: 获取报告列表
    // 关键词: 报告列表API, JSON API
    reportsListHandle = (rsp, req) => {
        log.info("API request: GET /api/reports from %s", req.RemoteAddr)
        
        rsp.Header().Set("Content-Type", "application/json; charset=utf-8")
        rsp.Header().Set("Access-Control-Allow-Origin", "*")
        
        if outputDir == "" {
            rsp.WriteHeader(200)
            rsp.Write(json.dumps({
                "success": false,
                "message": "No output directory configured",
                "reports": []
            }))
            return
        }
        
        // 收集报告文件信息
        reports = []
        
        // 使用 file.Walk 遍历目录
        err = file.Walk(outputDir, func(info) {
            // 跳过目录
            if info.IsDir {
                return true
            }
            
            filename = info.Name
            filepath = info.Path
            
            // 只处理 JSON 文件
            if !str.HasSuffix(filename, ".json") {
                return true
            }
            
            // 获取文件修改时间
            modTime = info.BuildIn.ModTime().Unix()
            fileSize = info.BuildIn.Size()
            
            // 尝试读取文件内容获取更多信息
            content, err = file.ReadFile(filepath)
            reportData = {}
            if err == nil {
                reportData = json.loads(content)
            }
            
            // Check if it's a batch report or single report
            reportType = reportData["reportType"]
            
            reportInfo = {
                "filename": filename,
                "filepath": filepath,
                "modTime": modTime,
                "size": fileSize,
                "reportType": reportType,
                "timestamp": reportData["timestamp"],
                "yakEngineVersion": reportData["yakEngineVersion"],
            }
            
            if reportType == "batch" {
                // Batch report - include summary info
                reportInfo["summary"] = reportData["summary"]
                reportInfo["testNames"] = reportData["testNames"]
                reportInfo["models"] = reportData["models"]
            } else {
                // Single report (old format) - include individual fields
                reportInfo["testName"] = reportData["testName"]
                reportInfo["model"] = reportData["model"]
                reportInfo["provider"] = reportData["provider"]
                reportInfo["detected"] = reportData["detected"]
                reportInfo["success"] = reportData["success"]
                reportInfo["duration"] = reportData["duration"]
                reportInfo["riskCount"] = reportData["riskCount"]
                reportInfo["matchedRiskCount"] = reportData["matchedRiskCount"]
            }
            
            reports = append(reports, reportInfo)
            return true
        })
        
        if err != nil {
            log.error("Failed to walk reports directory: %v", err)
            rsp.WriteHeader(500)
            rsp.Write(json.dumps({
                "success": false,
                "message": sprintf("Failed to read reports: %v", err),
                "reports": []
            }))
            return
        }
        
        // 按修改时间降序排序
        // 使用简单的冒泡排序
        for i = 0; i < len(reports); i++ {
            for j = i + 1; j < len(reports); j++ {
                if reports[i]["modTime"] < reports[j]["modTime"] {
                    temp = reports[i]
                    reports[i] = reports[j]
                    reports[j] = temp
                }
            }
        }
        
        rsp.WriteHeader(200)
        rsp.Write(json.dumps({
            "success": true,
            "count": len(reports),
            "reports": reports
        }))
    }
    
    // API: 获取单个报告详情
    // 关键词: 报告详情API
    reportDetailHandle = (rsp, req) => {
        log.info("API request: GET /api/report from %s", req.RemoteAddr)
        
        rsp.Header().Set("Content-Type", "application/json; charset=utf-8")
        rsp.Header().Set("Access-Control-Allow-Origin", "*")
        
        // 获取文件名参数
        filename = req.URL.Query().Get("filename")
        if filename == "" {
            rsp.WriteHeader(400)
            rsp.Write(json.dumps({
                "success": false,
                "message": "Missing filename parameter"
            }))
            return
        }
        
        if outputDir == "" {
            rsp.WriteHeader(400)
            rsp.Write(json.dumps({
                "success": false,
                "message": "No output directory configured"
            }))
            return
        }
        
        // 读取报告文件
        filepath = sprintf("%s/%s", outputDir, filename)
        content, err = file.ReadFile(filepath)
        if err != nil {
            log.error("Failed to read report file %s: %v", filepath, err)
            rsp.WriteHeader(404)
            rsp.Write(json.dumps({
                "success": false,
                "message": sprintf("Report not found: %v", err)
            }))
            return
        }
        
        // 解析 JSON
        reportData = json.loads(content)
        if reportData == nil {
            rsp.WriteHeader(500)
            rsp.Write(json.dumps({
                "success": false,
                "message": "Failed to parse report JSON"
            }))
            return
        }
        
        rsp.WriteHeader(200)
        rsp.Write(json.dumps({
            "success": true,
            "report": reportData
        }))
    }
    
    // 注册路由
    handles = []
    handles = append(handles, httpserver.routeHandler("/", indexHandle))
    handles = append(handles, httpserver.routeHandler("/index.html", indexHandle))
    handles = append(handles, httpserver.routeHandler("/api/reports", reportsListHandle))
    handles = append(handles, httpserver.routeHandler("/api/report", reportDetailHandle))
    handles = append(handles, httpserver.wsRouteHandler("/benchmark/test", testWSHandle))
    
    // 在后台启动 HTTP 服务器
    go func {
        defer func {
            err = recover()
            if err != nil {
                log.error("HTTP server panic: %v", err)
            }
        }
        
        log.info("Starting HTTP server on 0.0.0.0:%d", port)
        println(f"\n✓ AI Benchmark Web service started on http://0.0.0.0:${port}")
        println(f"✓ WebSocket endpoint: ws://0.0.0.0:${port}/benchmark/test")
        println(f"✓ Tests will start automatically and results will be pushed to browser")
        println("")
        
        httpserver.Serve("0.0.0.0", port, handles...)
    }
    
    // 等待一秒确保服务器启动
    time.Sleep(1)
    
    // 发送测试开始通知
    totalTests = len(aiConfigs) * len(testConfigs)
    startMsg = {
        "type": "test_started",
        "totalTests": totalTests,
        "aiModelCount": len(aiConfigs),
        "testScenarioCount": len(testConfigs)
    }
    broadcastToWebSockets(startMsg)
}

// CLI模式：命令行执行
// 关键词: CLI模式, 命令行执行
// startCLIMode 已移除，现在使用统一的执行模式

// 主程序入口
// 关键词: 主程序, 入口函数, 统一模式
func main() {
    // 确保程序退出时清理资源
    defer func {
        err = recover()
        if err != nil {
            log.error("Program panic: %v", err)
        }
        
        // 停止 vulinbox
        if vulinboxCancel != nil {
            log.info("Stopping vulinbox...")
            vulinboxCancel()
            log.info("Vulinbox stopped")
        }
    }
    
    log.info("Starting AI Model Vulnerability Detection Benchmark")
    
    // 加载配置
    aiConfigs, testConfigs = loadConfigurations()
    
    // 如果启用 Web 模式，先启动 Web 服务器
    if webMode {
        startWebServer(aiConfigs, testConfigs)
    }
    
    // 执行测试
    runAllTests(aiConfigs, testConfigs)
    
    // 如果不是 Web 模式，程序结束
    if !webMode {
        log.info("Benchmark completed")
        // 停止 vulinbox
        if vulinboxCancel != nil {
            log.info("Stopping vulinbox...")
            vulinboxCancel()
            log.info("Vulinbox stopped")
        }
    } else {
        // Web 模式保持服务器运行
        log.info("Tests completed. Web server is still running. Press Ctrl+C to stop.")
        log.info("Vulinbox is still running on http://127.0.0.1:8787")
        
        // 监听信号以便优雅退出
        for {
            sleep(100)
        }
    }
}

main()

